
#include "_config.h"


const char use_name_first[20]={
"杭州路格科技有限公司"
};


const char title_first[20]={
#if (RF_MULTI_EN==1)
  "接收机HX"
#else
  "数据记录仪"
#endif
};

const char model_no_first[10]={
#if LCD_NO==8
  "Luge08"
#elif LCD_NO==7
  "Luge07"
#elif LCD_NO==20
  "Luge20"
#endif
};
const char serial_no_first[10]={
  "0123456789"
};
const char start_time_first[6]={
0x11,0x01,0x01,0x01,0x01,0x01
};

//================================================================================
const struct_channel channel_first[8]={
  //ch1..........................................................................
  #if ((JLY_MODEL==_20_SHT)||(JLY_MODEL==_20_NTC_SHT)||(JLY_MODEL==_2_NTC_HIH5030)||(JLY_MODEL==_3_1NTC_1HIH_1PT_F40_100)\
       ||(JLY_MODEL==_1_NTC)||(JLY_MODEL==_2_NTC)||(JLY_MODEL==_3_NTC)||(JLY_MODEL==_4_NTC)\
         ||(JLY_MODEL==_5_NTC)||(JLY_MODEL==_6_NTC)||(JLY_MODEL==_7_NTC)||(JLY_MODEL==_8_NTC)\
           ||(JLY_MODEL==_8_4NTC_4HIH5030)||(JLY_MODEL==_6_3NTC_3HIH5030)||(JLY_MODEL==_4_2NTC_2HIH5030)\
             ||(JLY_MODEL==_6_4NTC_2HIH5030)||(JLY_MODEL==_2_NTC_TRSF)||(JLY_MODEL==_3_2NTC_TRSF)\
               ||(JLY_MODEL==_6_3NTC_3TRSF)||(JLY_MODEL==_8_4NTC_4TRSF)||(JLY_MODEL==_4_NTC_HIH_NTC_TRSF)||(JLY_MODEL==_3_NTC_HIH_TRSF)\
                 ||(JLY_MODEL==_3_2NTC_1HIH)||(JLY_MODEL==_5_4NTC_1HIH)||(JLY_MODEL==_4_2NTC_2TRSF)\
                   ||(JLY_MODEL==_3_WD_SD_GH400_10umol)||(JLY_MODEL==_2_WD_SW_0_1000mm)||(JLY_MODEL==_2_WD_SW_0_500mm)\
                     ||(JLY_MODEL==_4_3NTC_1HIH)||(JLY_MODEL==_8B_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)\
                       ||(JLY_MODEL==_8B_WD_GZV200K_SD_YL01_TRWD_TRSF_FS_FX)||(JLY_MODEL==_2_WD_SW_0_3000mm)\
                        ||(JLY_MODEL==_4_WD_SD_CO2_5000_GZ200K)||(JLY_MODEL==_2_WD_SW_500_10mm)||(JLY_MODEL==_2_NTC_01YL)\
                          ||(JLY_MODEL==_5_4NTC_TRSF)||(JLY_MODEL==_5_1W1TRSF_1W1TRSF_1W)||(JLY_MODEL==_6_1W1TRSF_1W1TRSF_2W)\
                            ||(JLY_MODEL==_8_6NTC_2HIH)||(JLY_MODEL==_3_NTC_HIH5030_01YL)||(JLY_MODEL==_8_4NTC_2HIH_2TRSF)||(JLY_MODEL==_6_1NTC_1HIH_2NTC_2TRSF)\
                              ||(JLY_MODEL==_3_NTC_HIH_CO2_5000PPM)||(JLY_MODEL==_8_5NTC_3HIH)||(JLY_MODEL==_8_5NTC_HIH_NTC_HIH)\
                 ||(JLY_MODEL==_3_WD_SD_GZ100K)||(JLY_MODEL==_3_WD_SD_GZ200K)||(JLY_MODEL==_4_WD_SD_WD_GZ200K)\
                    ||(JLY_MODEL==_2_WD_GZ100K)||(JLY_MODEL==_2_WD_GZ200K)||(JLY_MODEL==_4_1NTC_1HIH_2NTC)||(JLY_MODEL==_6_1NTC_1HIH_4NTC)\
                    ||(JLY_MODEL==_6_WD_GZ100K_SD_YL01_FS_FX)||(JLY_MODEL==_6_WD_GZ100K_SD_YL05_FS_FX)||(JLY_MODEL==_5_WD_TRSF_GZ200K_WD_SD)\
                      ||(JLY_MODEL==_8_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)||(JLY_MODEL==_3B_WD_GZ100K_TRSF)||(JLY_MODEL==_8_7NTC_1HIH)\
                        ||(JLY_MODEL==_2_NTC_PH)||(JLY_MODEL==_4_WD_GZ100K_SD_YL01)||(JLY_MODEL==_3_WD_TRSF_GZ200K)||(JLY_MODEL==_8_134678NTC_25HIH)\
                          ||(JLY_MODEL==_5_WD_GZ100K_TRWD_TRSF_SD)||(JLY_MODEL==_7_WD_GZ100K_TRWD_TRSF_SD_YL01_QY)||(JLY_MODEL==_4_WD_SD_FS_FX)\
                            ||(JLY_MODEL==_2_NTC_ZWFS)||(JLY_MODEL==_6B_WD_SD_QY_YL01_FS_FX)||(JLY_MODEL==_3_WD_SD_QY)\
                              ||(JLY_MODEL==_2_WDHTU_SDHTU)||(JLY_MODEL==_7_6NTC_1HIH)||(JLY_MODEL==_6_5NTC_1HIH)||(JLY_MODEL==_4_WD_SD_CO2TTL5000_GZ200K)||(JLY_MODEL==_6_WD_SD_CO2TTL5000_GZ200K_WD_TRSF)\
                                ||(JLY_MODEL==_2_WDHIH6130_SDHIH6130)||(JLY_MODEL==_7_4NTC_2TRSF_1HIH)||(JLY_MODEL==_6_4NTC_1HIH_1TRSF)\
                                  ||(JLY_MODEL==_5_2NTC_2HIH_CO2_Z14_5000)||(JLY_MODEL==_7_3NTC_3HIH_CO2_Z14_5000)||(JLY_MODEL==_5_2NTC_2HIH_CO2_MISIR_5000)\
                                    ||(JLY_MODEL==_7_3NTC_3HIH_CO2_MISIR_5000)||(JLY_MODEL==_6_WD_SD_QY_YL01_FS_FX)||(JLY_MODEL==_3_WD_SD_CO2TTL10000)\
                                      ||(JLY_MODEL==_4_TRWD_TRSF_TYFS_ZF)||(JLY_MODEL==_8_3NTC_3HIH_2NTC)||(JLY_MODEL==_7RF_1NTC_1HIH_5F200)||(JLY_MODEL==_8RF_6NTC_2F200)\
                                        ||(JLY_MODEL==_6_2NTC_2HIH_2GZ100K)||(JLY_MODEL==_5_WD_SD_WD_GZ200K_CO2TTL5000)||(JLY_MODEL==_3_NTC_HIH_CO2TTL10BF)\
                                          ||(JLY_MODEL==_3_NTC_HIH_CO2TTL20BF)||(JLY_MODEL==_2RF_1NTC_1F200)||(JLY_MODEL==_7_WD_SD_WD_GZ200K_CO2TTL5000_2WD)||(JLY_MODEL==_3RF_2NTC_1F200)\
                           ||(JLY_MODEL==_8_NTC_HIH_CO2TTL5000_GZ200K_QY_NH3_H2S_CH4)||(JLY_MODEL==_7_WD_GZ200K_SD_YL01_FS_FX_TRWD)\
                             ||(JLY_MODEL==_2_WD_SW_1000_10mm)||(JLY_MODEL==_6RF_4NTC_2F200)||(JLY_MODEL==_8_WD_GZ200K_SD_YL01_FS_FX_TRWD_TRSF)\
                               ||(JLY_MODEL==_5_2WD_2SD_GZ200K)||(JLY_MODEL==_8_3NTC_3HIH5030_1HIH6130)||(JLY_MODEL==_2_NTC_HIH6130)||(JLY_MODEL==_6_3NTC_3EC5)\
                                 ||(JLY_MODEL==_2_wdNTC_sdSHT30)||(JLY_MODEL==_2_wdSHT30_sdSHT30)||(JLY_MODEL==_7RF_5NTC_2F200)||(JLY_MODEL==_3_2_NTC_1HIH))
  {20,80,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_8_DS18B20_F55_125)||(JLY_MODEL==_6_DS18B20_F55_125)||(JLY_MODEL==_1_DS18B20_F55_125)||(JLY_MODEL==_2_DS18B20_F55_125)||(JLY_MODEL==_2_DS18B20_HIH)\
    ||(JLY_MODEL==_4_DS18B20_F55_125)||(JLY_MODEL==_3_DS18B20_F55_125))
  {20,80,550+0x8000,1250,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  
  
  #elif ((JLY_MODEL==_1_K_F200_1350)||(JLY_MODEL==_2_K_F200_1350_COLD)||(JLY_MODEL==_2_K_F200_1350_DS_F55_125)||(JLY_MODEL==_3_K_F200_1350))
  {101,201,2000+0x8000,13500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_1_RTD_F200_300)||(JLY_MODEL==_4_RTD_F200_300)||(JLY_MODEL==_2RF_F200)||(JLY_MODEL==_1RF_F200)||(JLY_MODEL==_5RF_F200)\
    ||(JLY_MODEL==_3RF_F200)||(JLY_MODEL==_6RF_F200)||(JLY_MODEL==_4RF_2F200_2HIH))
  {101,201,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_8_4WD_0_80_4SD_0_100)
  {101,201,0,800,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_1_ROTYONIC)
  {101,701,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_1_DOOR)
  {101,201,0,1000,_A_D,_T_DOOR,_U_none,_S_1,_R_2V5},

  #elif (JLY_MODEL==_3_WD_F10_60_SD_0_100_JDSD_0_200)
  {20,80,100+0x8000,600,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_1_SMOKE)
  {101,201,0,1000,_A_D,_T_SMOKE,_U_none,_S_1,_R_2V5},  
  
  #elif ((JLY_MODEL==_1_SD420mA_0_100)||(JLY_MODEL==_2_SD420mA_0_100))
  {101,701,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_2V5},//VRE2.5
  
  #elif ((JLY_MODEL==_1_HIH5030)||(JLY_MODEL==_2_HIH5030)||(JLY_MODEL==_6_HIH5030)||(JLY_MODEL==_8_HIH5030)||(JLY_MODEL==_4_HIH5030))
  {101,701,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_1_PT_0_300)||(JLY_MODEL==_2_PT_0_300)||(JLY_MODEL==_2_1PT_0_300_1HIH)||(JLY_MODEL==_3_2PT_0_300_1HIH)\
    ||(JLY_MODEL==_3_PT_0_300)||(JLY_MODEL==_4_PT_0_300)||(JLY_MODEL==_6_2PT_2ROTYONIC_NTC_HIH)\
      ||(JLY_MODEL==_2_1PT_1ROTYONIC)||(JLY_MODEL==_5_4PT_0_300_1NTC)||(JLY_MODEL==_4_2PTH_2HIH)\
        ||(JLY_MODEL==_6_3PT_0_300_3HIH)||(JLY_MODEL==_8_4PT_0_300_4HIH)||(JLY_MODEL==_8_4PT_4ROTYONIC))
  {101,701,0,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_4_WD420mA_0_800)||(JLY_MODEL==_1_WD420mA_0_800))
  {101,701,0,8000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_1_WD420mA_0_500)
  {101,701,0,5000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  
  #elif (JLY_MODEL==_4_WD420mA_0_400)
  {101,701,0,4000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_3_DL_10A)
  {1001,7001,0,1000,_A_D,_T_DL,_U_a,_S_2,_R_2V5},
  
  #elif (JLY_MODEL==_3_DY_150v)
  {101,701,0,1500,_A_D,_T_DY,_U_v,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_2PT_F50_100_2HIH)
  {101,701,500+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_1_PT_0_200)
  {101,701,0,2000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  
  #elif  ((JLY_MODEL==_11_PT_F200_0))
  {101,701,2000+0x8000,0,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_1_PT_F40_70)
  {101,501,400+0x8000,700,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_1_PT_F40_100)||(JLY_MODEL==_2_PT_F40_100)||(JLY_MODEL==_4_PT_F40_100)||(JLY_MODEL==_6_1PT_F40_100_1HIH_2NTC_2HIH)\
    ||(JLY_MODEL==_8_4PT_F40_100_4HIH)||(JLY_MODEL==_4_2PT_F40_100_2HIH)||(JLY_MODEL==_3_PT_F40_100))
  {101,701,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_1_PT_F20_120)
  {101,701,200+0x8000,1200,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_1_PT_F40_120)
  {101,701,400+0x8000,1200,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif  (JLY_MODEL==_1_PT_F40_250)
  {101,701,400+0x8000,2500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_1_PT_F200_100)||(JLY_MODEL==_2_1PT_F200_100_1HIH)||(JLY_MODEL==_2_PT_F200_100)||(JLY_MODEL==_3_PT_F200_100)||(JLY_MODEL==_4_PT_F200_100)\
    ||(JLY_MODEL==_4_2PT_F200_100_2HIH))
  {101,701,2000+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_1_PT_F200_200)
  {101,701,2000+0x8000,2000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_2_PT_F100_100)||(JLY_MODEL==_1_PT_F100_100)||(JLY_MODEL==_4_PT_F100_100)||(JLY_MODEL==_3_PT_F100_100)||(JLY_MODEL==_3_PT_F100_100_2NTC)||(JLY_MODEL==_4_PT_F100_100_3NTC)\
    ||(JLY_MODEL==_8_3PT_F100_100_5NTC)||(JLY_MODEL==_2_1PT_F100_100_1HIH))
  {101,701,1000+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_EX},
  
  #elif  ((JLY_MODEL==_2_PT_F100_200)||(JLY_MODEL==_1_PT_F100_200)\
    ||(JLY_MODEL==_3_PT_F100_200)||(JLY_MODEL==_4_PT_F100_200)||(JLY_MODEL==_2_PT_F100_200_PH)\
      ||(JLY_MODEL==_2_1PT_F100_200_1HIH)||(JLY_MODEL==_5_4PT_F100_200_1NTC)||(JLY_MODEL==_4_1PT_F100_200_2NTC_1HIH)\
        ||(JLY_MODEL==_8_4PT_F100_200_4HIH)||(JLY_MODEL==_4_2PT_F100_200_2HIH)||(JLY_MODEL==_8_1PT_F100_200_7NTC)||(JLY_MODEL==_2_1PT_F100_200_1NTC))
  {101,701,1000+0x8000,2000,_A_D,_T_T,_U_OC,_S_1,_R_EX},
  
  #elif (JLY_MODEL==_2_1PT_F40_150_1HIH)
  {101,701,400+0x8000,1500,_A_D,_T_T,_U_OC,_S_1,_R_EX},
  
  #elif (JLY_MODEL==_8_4PT_F100_300_4HIH)
  {101,701,1000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_EX},
  

  
  #elif (JLY_MODEL==_4_PT_F150_150)
  {101,701,1500+0x8000,1500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_3_PT_F50_250)||(JLY_MODEL==_2_1PT_F50_250_1HIH)||(JLY_MODEL==_4_2PT_F50_250_2HIH)||(JLY_MODEL==_2_PT_F50_250)\
    ||(JLY_MODEL==_4_PT_F50_250))
  {101,701,500+0x8000,2500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_2_1PT_F50_200_1HIH)
  {101,701,500+0x8000,2000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_4_PT_F50_200)||(JLY_MODEL==_4_2PT_F50_200_2HIH))
  {101,701,500+0x8000,2000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_PT_F50_150)
  {101,701,500+0x8000,1500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_3_PT_F50_300)||(JLY_MODEL==_1_PT_F50_300))
  {101,701,500+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_PT_F50_300)
  {101,701,500+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_2_PT_F50_350)
  {101,701,500+0x8000,3500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_1_PT_F200_50)
  {101,701,2000+0x8000,500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_1_HCH2O_TTL_0_373)||(JLY_MODEL==_1_HCH2O_V_0_373))
  {101,201,0,373,_A_D,_T_CH2O,_U_mg_m3,_S_2,_R_2V5},//甲醛，2位小数
  
  
  #elif (JLY_MODEL==_1_SSFS_0_2000)
  {101,201,0,2000,_A_D,_T_SSFS,_U_x10w_m2,_S_1,_R_2V5},
  
  
  #elif  ((JLY_MODEL==_2_O2_CO2)||(JLY_MODEL==_1_O2)||(JLY_MODEL==_2_O2)||(JLY_MODEL==_2_O2_CO2_TTL_5000))
  {101,701,0,300,_A_D,_T_O2,_U_bf,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_1_CO2_COZIR_W10V)
  {101,701,0,100,_A_D,_T_CO2,_U_bf,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_1_CO2_2000PPM)||(JLY_MODEL==_2_CO2_2000_NTC))
  {20,80,0,2000,_A_D,_T_CO2,_U_x10ppm,_S_1,_R_AVCC},//基准AVCC
  #elif ((JLY_MODEL==_1_CO2_5000PPM)||(JLY_MODEL==_2_CO2_5000PPM)||(JLY_MODEL==_2_CO2_5000PPM_SD)||(JLY_MODEL==_2_CO2_5000PPM_O2)||(JLY_MODEL==_1_CO2_TTL_5000))
  {101,701,0,5000,_A_D,_T_CO2,_U_x10ppm,_S_1,_R_AVCC},//基准AVCC
  #elif (JLY_MODEL==_1_CO2_0_5)
  {101,701,0,500,_A_D,_T_CO2,_U_bf,_S_2,_R_AVCC},//基准AVCC
  #elif (JLY_MODEL==_1_CO2_MH410D_0_10)
  {101,701,0,1000,_A_D,_T_CO2,_U_bf,_S_2,_R_2V5},//基准2.5
  #elif (JLY_MODEL==_1_CO2_TTL_20BF)
  {101,701,0,2000,_A_D,_T_CO2,_U_bf,_S_2,_R_2V5},//基准2.5
  #elif ((JLY_MODEL==_1_CO2_Z14_5000)||(JLY_MODEL==_2_CO2_Z14_5000))
  {101,701,0,5000,_A_D,_T_CO2,_U_x10ppm,_S_1,_R_2V5},//基准2.5  
  
  #elif (JLY_MODEL==_1_CO2_MK400_2000)
  {101,701,0,2000,_A_D,_T_CO2,_U_x10ppm,_S_1,_R_2V5},//基准2.5  
  
  #elif (JLY_MODEL==_1_CO2_MISIR_5000)
  {101,701,0,5000,_A_D,_T_CO2,_U_x10ppm,_S_1,_R_AVCC},//基准vcc  
  #elif (JLY_MODEL==_1_CO2_SOHATECH_3K)
  {20,80,0,3000,_A_D,_T_CO2,_U_x10ppm,_S_1,_R_2V5},//基准2.5
  
  #elif (JLY_MODEL==_1_VOC_0_100)
  {101,701,0,1000,_A_D,_T_VOC,_U_none,_S_1,_R_2V5},//基准2.5

  #elif ((JLY_MODEL==_1_PM25_500)||(JLY_MODEL==_3_PM25_500)||(JLY_MODEL==_1_PM25_TTL_1000)||(JLY_MODEL==_1_PM25_V_1000)||(JLY_MODEL==_2_PM25_TTL1000_PM25V_1000)\
    ||(JLY_MODEL==_2_PM25_TTL1000_CO2_MISIR_5000)||(JLY_MODEL==_1_PM25_PWM_1000))
  {11,171,0,1000,_A_D,_T_PM25,_U_ug_m3,_S_0,_R_2V5},//整数
  
  #elif (JLY_MODEL==_1_GZ_100LX)
  {101,601,0,1000,_A_D,_T_GZ,_U_lx,_S_1,_R_AVCC},//1位小数
  #elif (JLY_MODEL==_1_GZ_1000LX)
  {101,601,0,10000,_A_D,_T_GZ,_U_lx,_S_1,_R_AVCC},//1位小数
  
  #elif ((JLY_MODEL==_1_PH_0_14)||(JLY_MODEL==_3_PH_14))
  {1001,7001,0,1400,_A_D,_T_PH,_U_ph,_S_2,_R_AVCC},//2位小数
  #elif (JLY_MODEL==_1_GZ_65K)
  {1001,6001,0,6500,_A_D,_T_GZ,_U_klx,_S_2,_R_AVCC},//2位小数
  #elif (JLY_MODEL==_1_GZ_100K)
  {1001,7001,0,10000,_A_D,_T_GZ,_U_klx,_S_2,_R_AVCC},//2位小数
  #elif (JLY_MODEL==_1_GZ_200K)
  {1001,7001,0,20000,_A_D,_T_GZ,_U_klx,_S_2,_R_AVCC},//2位小数
  #elif (JLY_MODEL==_1_GZV_200K)
  {1001,7001,0,20000,_A_D,_T_GZ,_U_klx,_S_2,_R_2V5},//基准2.5
  
  #elif (JLY_MODEL==_1_DZ_0_60_R)
  {1001,2001,0,6000,_T_QY,_T_GZ,_U_o,_S_2,_R_2V5},//2位小数
  
  #elif (JLY_MODEL==_1_SW_0_500mm)//4-20mA
  {101,701,0,5000,_A_D,_T_SW,_U_mm,_S_1,_R_2V5},
  #elif (JLY_MODEL==_1_SW_0_1000mm)//4-20mA
  {101,701,0,10000,_A_D,_T_SW,_U_mm,_S_1,_R_2V5},
  #elif (JLY_MODEL==_1_SW_0_3000mm)
  {101,701,0,30000,_A_D,_T_SW,_U_mm,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_1_SW_0_2000mm)
  {101,701,0,20000,_A_D,_T_SW,_U_mm,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_1_SW_200_10mm)
  {101,701,0,2000,_A_D,_T_SW,_U_x10mm,_S_1,_R_2V5},//4-20mA
  
  #elif (JLY_MODEL==_1_SW_1000_10mm)
  {101,701,0,10000,_A_D,_T_SW,_U_x10mm,_S_1,_R_2V5},//4-20mA
  
  #elif (JLY_MODEL==_2_SW_30m_SHD_20m)
  {101,701,0,3000,_A_D,_T_SW,_U_m,_S_2,_R_2V5},//4-20mA
  
  #elif (JLY_MODEL==_1_SW_500_10mm)
  {101,701,0,5000,_A_D,_T_SW,_U_x10mm,_S_1,_R_2V5},//4-20mA
  #elif (JLY_MODEL==_1_SW_0_50_m)
  {101,701,0,5000,_A_D,_T_SW,_U_m,_S_2,_R_2V5},//4-20mA,2位小数
  
  
  #elif (JLY_MODEL==_1_SDU_200_10mm)
  {101,701,0,2000,_A_D,_T_SDU,_U_x10mm,_S_1,_R_2V5},
 
  #elif (JLY_MODEL==_1_GH_400_10umol)
  {101,701,0,4000,_A_D,_T_GHYXFS,_U_x10umol,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_1_YALI_160_10kpa)||(JLY_MODEL==_2_YALI_160_10kpa_PTH))//160*10kpa
  {101,701,0,1600,_A_D,_T_QY,_U_x10kpa,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_1_YALI_400_kpa)
  {101,701,0,4000,_A_D,_T_QY,_U_kpa,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_1_SHR_30_120_kpa)
  {1001,7001,3000,12000,_A_D,_T_QY,_U_kpa,_S_2,_R_2V5},
  
 
  #elif (JLY_MODEL==_3_YALI_400_kpa)
  {101,701,0,4000,_A_D,_T_YALI,_U_kpa,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_1_YALI_F100_100_kpa)
  {101,701,1000+0X8000,1000,_A_D,_T_YALI,_U_kpa,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_1_DY_500_10mv)
  {101,701,0,5000,_A_D,_T_DY,_U_x10mv,_S_1,_R_2V5},
  
  
  #elif (JLY_MODEL==_2_FS_FX)
  {101,701,0,600,_A_D,_T_FS,_U_m_s,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_2_LS_SS)||(JLY_MODEL==_4_2LS_2SS))
  {1001,2001,100+0x8000,500,_A_D,_T_LS,_U_m_s,_S_2,_R_AVCC},
  
  
  #elif (JLY_MODEL==_3_FS_FX_01YL)
  {101,701,0,600,_A_D,_T_FS,_U_m_s,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_1_NTC_F20_120)||(JLY_MODEL==_2_NTC_F20_120))
  {20,80,200+0x8000,1200,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},

  #elif ((JLY_MODEL==_1_01YL)||(JLY_MODEL==_1_02YL)||(JLY_MODEL==_1_05YL))
  {101,701,0,10000,_A_D,_T_YL,_U_mm,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_1_CS)
  {101,701,0,30000,_A_D,_T_CS,_U_ci,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_3_CF)
  {0,500,0,1000,_A_D,_T_QY,_U_none,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_1_TRSF)||(JLY_MODEL==_3_TRSF)||(JLY_MODEL==_4_TRSF)||(JLY_MODEL==_5_TRSF)||(JLY_MODEL==_6_TRSF)||(JLY_MODEL==_2_TRSF))
  {101,701,0,1000,_A_D,_T_TRSF,_U_bf,_S_1,_R_2V5},

  #else
  {101,701,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  #endif
  
  //ch2.........................................................................
  #if ((JLY_MODEL==_2_NTC)||(JLY_MODEL==_3_NTC)||(JLY_MODEL==_4_NTC)||(JLY_MODEL==_5_NTC)||(JLY_MODEL==_3_PT_F100_100_2NTC)\
         ||(JLY_MODEL==_6_NTC)||(JLY_MODEL==_7_NTC)||(JLY_MODEL==_8_NTC)||(JLY_MODEL==_6_2NTC_2HIH_2GZ100K)\
           ||(JLY_MODEL==_6_4NTC_2HIH5030)||(JLY_MODEL==_3_2NTC_TRSF)||(JLY_MODEL==_8RF_6NTC_2F200)||(JLY_MODEL==_8_7NTC_1HIH)\
             ||(JLY_MODEL==_2_CO2_2000_NTC)||(JLY_MODEL==_5_4NTC_1HIH)||(JLY_MODEL==_7_6NTC_1HIH)||(JLY_MODEL==_6_5NTC_1HIH)\
               ||(JLY_MODEL==_4_3NTC_1HIH)||(JLY_MODEL==_5_4NTC_TRSF)||(JLY_MODEL==_8_5NTC_3HIH)||(JLY_MODEL==_8_6NTC_2HIH)\
                 ||(JLY_MODEL==_7_4NTC_2TRSF_1HIH)||(JLY_MODEL==_6_4NTC_1HIH_1TRSF)||(JLY_MODEL==_8_5NTC_HIH_NTC_HIH)||(JLY_MODEL==_3RF_2NTC_1F200)\
                   ||(JLY_MODEL==_4_1PT_F100_200_2NTC_1HIH)||(JLY_MODEL==_6RF_4NTC_2F200)||(JLY_MODEL==_8_1PT_F100_200_7NTC)||(JLY_MODEL==_2_1PT_F100_200_1NTC)\
                     ||(JLY_MODEL==_7RF_5NTC_2F200)||(JLY_MODEL==_4_PT_F100_100_3NTC)||(JLY_MODEL==_3_2_NTC_1HIH))
  {20,80,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_2RF_1NTC_1F200)
  {102,702,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_8_DS18B20_F55_125)||(JLY_MODEL==_6_DS18B20_F55_125)||(JLY_MODEL==_2_DS18B20_F55_125)||(JLY_MODEL==_2_K_F200_1350_DS_F55_125)\
    ||(JLY_MODEL==_4_DS18B20_F55_125)||(JLY_MODEL==_3_DS18B20_F55_125))
  {102,702,550+0x8000,1250,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_2_NTC_ZWFS)
  {102,702,0,1000,_A_D,_T_ZWFS,_U_UV,_S_2,_R_2V5},//2位小数
  
  #elif (JLY_MODEL==_2_O2_CO2_TTL_5000)
  {102,702,0,5000,_A_D,_T_CO2,_U_x10ppm,_S_1,_R_AVCC},//基准AVCC
  
  #elif ((JLY_MODEL==_20_SHT)||(JLY_MODEL==_20_NTC_SHT)||(JLY_MODEL==_2_NTC_HIH5030)\
       ||(JLY_MODEL==_2_1PT_0_300_1HIH)||(JLY_MODEL==_8_4NTC_4HIH5030)||(JLY_MODEL==_3_1NTC_1HIH_1PT_F40_100)\
         ||(JLY_MODEL==_4_2NTC_2HIH5030)||(JLY_MODEL==_6_3NTC_3HIH5030)||(JLY_MODEL==_6_1PT_F40_100_1HIH_2NTC_2HIH)\
           ||(JLY_MODEL==_2_HIH5030)||(JLY_MODEL==_4_NTC_HIH_NTC_TRSF)||(JLY_MODEL==_7RF_1NTC_1HIH_5F200)||(JLY_MODEL==_3_NTC_HIH_TRSF)\
            ||(JLY_MODEL==_3_2NTC_1HIH)||(JLY_MODEL==_2_1PT_F100_200_1HIH)||(JLY_MODEL==_2_1PT_F100_100_1HIH)||(JLY_MODEL==_2_1PT_F200_100_1HIH)||(JLY_MODEL==_4_HIH5030)\
              ||(JLY_MODEL==_3_WD_SD_GH400_10umol)||(JLY_MODEL==_2_1PT_F50_250_1HIH)||(JLY_MODEL==_2_1PT_F50_200_1HIH)\
                ||(JLY_MODEL==_4_WD_SD_CO2_5000_GZ200K)||(JLY_MODEL==_8_4WD_0_80_4SD_0_100)||(JLY_MODEL==_8_3NTC_3HIH5030_1HIH6130)\
                  ||(JLY_MODEL==_6_HIH5030)||(JLY_MODEL==_2_CO2_5000PPM_SD)||(JLY_MODEL==_4_WD_SD_WD_GZ200K)||(JLY_MODEL==_4_WD_SD_FS_FX)\
                    ||(JLY_MODEL==_4_2PTH_2HIH)||(JLY_MODEL==_3_NTC_HIH5030_01YL)||(JLY_MODEL==_4_2PT_F50_100_2HIH)||(JLY_MODEL==_3_WD_SD_CO2TTL10000)\
                      ||(JLY_MODEL==_8_4NTC_2HIH_2TRSF)||(JLY_MODEL==_6_1NTC_1HIH_2NTC_2TRSF)||(JLY_MODEL==_3_NTC_HIH_CO2_5000PPM)\
                        ||(JLY_MODEL==_3_WD_SD_GZ100K)||(JLY_MODEL==_3_WD_SD_GZ200K)||(JLY_MODEL==_6B_WD_SD_QY_YL01_FS_FX)\
                          ||(JLY_MODEL==_3_WD_SD_QY)||(JLY_MODEL==_2_WDHTU_SDHTU)||(JLY_MODEL==_4_1NTC_1HIH_2NTC)||(JLY_MODEL==_4_WD_SD_CO2TTL5000_GZ200K)||(JLY_MODEL==_6_WD_SD_CO2TTL5000_GZ200K_WD_TRSF)\
                            ||(JLY_MODEL==_2_WDHIH6130_SDHIH6130)||(JLY_MODEL==_5_2NTC_2HIH_CO2_Z14_5000)||(JLY_MODEL==_7_3NTC_3HIH_CO2_Z14_5000)\
                              ||(JLY_MODEL==_5_2NTC_2HIH_CO2_MISIR_5000)||(JLY_MODEL==_7_3NTC_3HIH_CO2_MISIR_5000)||(JLY_MODEL==_8_HIH5030)\
                                ||(JLY_MODEL==_6_WD_SD_QY_YL01_FS_FX)||(JLY_MODEL==_8_3NTC_3HIH_2NTC)||(JLY_MODEL==_6_1NTC_1HIH_4NTC)||(JLY_MODEL==_4_2PT_F200_100_2HIH)\
                                  ||(JLY_MODEL==_2_DS18B20_HIH)||(JLY_MODEL==_5_WD_SD_WD_GZ200K_CO2TTL5000)||(JLY_MODEL==_2_wdSHT30_sdSHT30)||(JLY_MODEL==_3_NTC_HIH_CO2TTL10BF)\
                                    ||(JLY_MODEL==_3_NTC_HIH_CO2TTL20BF)||(JLY_MODEL==_4_2PT_F50_200_2HIH)||(JLY_MODEL==_7_WD_SD_WD_GZ200K_CO2TTL5000_2WD)\
       ||(JLY_MODEL==_8_NTC_HIH_CO2TTL5000_GZ200K_QY_NH3_H2S_CH4)||(JLY_MODEL==_4_2PT_F40_100_2HIH)||(JLY_MODEL==_4_2PT_F100_200_2HIH)||(JLY_MODEL==_8_134678NTC_25HIH)\
         ||(JLY_MODEL==_4RF_2F200_2HIH)||(JLY_MODEL==_5_2WD_2SD_GZ200K)||(JLY_MODEL==_2_1PT_F40_150_1HIH)||(JLY_MODEL==_2_NTC_HIH6130)||(JLY_MODEL==_2_wdNTC_sdSHT30))
  {0,1000,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_3_WD_F10_60_SD_0_100_JDSD_0_200)
  {102,702,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_6_2PT_2ROTYONIC_NTC_HIH)||(JLY_MODEL==_2_1PT_1ROTYONIC))
  {102,702,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_2V5},
  
  #elif  (JLY_MODEL==_2_WD_SW_1000_10mm)  
  {102,702,0,10000,_A_D,_T_SW,_U_x10mm,_S_1,_R_2V5},//4-20mA
  
  #elif (JLY_MODEL==_3_PT_F50_300)
  {102,702,500+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_2_K_F200_1350_COLD)
  {102,202,0,1000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_WD420mA_0_800)
  {102,702,0,8000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_1_SD420mA_0_100)||(JLY_MODEL==_2_SD420mA_0_100))
  {102,702,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_2V5},//VRE2.5
  
  #elif (JLY_MODEL==_4_WD420mA_0_400)
  {102,702,0,4000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_3_K_F200_1350)
  {102,202,2000+0x8000,13500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_4_RTD_F200_300)||(JLY_MODEL==_2RF_F200)||(JLY_MODEL==_5RF_F200)||(JLY_MODEL==_3RF_F200)\
    ||(JLY_MODEL==_6RF_F200))
  {102,202,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_PT_F50_150)
  {102,702,500+0x8000,1500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif  JLY_MODEL==_2_O2
  {102,202,0,300,_A_D,_T_O2,_U_bf,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_3_DL_10A)
  {1002,7002,0,1000,_A_D,_T_DL,_U_a,_S_2,_R_2V5},
  
  #elif (JLY_MODEL==_3_DY_150v)
  {102,702,0,1500,_A_D,_T_DY,_U_v,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_2_SW_30m_SHD_20m)
  {102,702,0,2000,_A_D,_T_SDU,_U_m,_S_2,_R_2V5},//4-20mA
  
  #elif (JLY_MODEL==_2_PM25_TTL1000_PM25V_1000)
  {12,172,0,1000,_A_D,_T_PM25,_U_ug_m3,_S_0,_R_2V5},//整数
  
  #elif ((JLY_MODEL==_6_WD_GZ100K_SD_YL01_FS_FX)||(JLY_MODEL==_6_WD_GZ100K_SD_YL05_FS_FX)\
    ||(JLY_MODEL==_8_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)||(JLY_MODEL==_2_WD_GZ100K)\
      ||(JLY_MODEL==_8B_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)||(JLY_MODEL==_4_WD_GZ100K_SD_YL01)\
        ||(JLY_MODEL==_5_WD_GZ100K_TRWD_TRSF_SD)||(JLY_MODEL==_7_WD_GZ100K_TRWD_TRSF_SD_YL01_QY)\
          ||(JLY_MODEL==_3B_WD_GZ100K_TRSF))
  {1002,7002,0,10000,_A_D,_T_GZ,_U_klx,_S_2,_R_AVCC},//2位小数
  
  #elif ((JLY_MODEL==_2_WD_GZ200K)||(JLY_MODEL==_7_WD_GZ200K_SD_YL01_FS_FX_TRWD)||(JLY_MODEL==_8_WD_GZ200K_SD_YL01_FS_FX_TRWD_TRSF))
  {1002,7002,0,20000,_A_D,_T_GZ,_U_klx,_S_2,_R_AVCC},//2位小数
 
  #elif (JLY_MODEL==_8B_WD_GZV200K_SD_YL01_TRWD_TRSF_FS_FX)
  {102,702,0,2000,_A_D,_T_GZ,_U_klx,_S_1,_R_2V5},//基准2.5 ,1位小数
  
  #elif (JLY_MODEL==_2_CO2_5000PPM_O2)
  {102,702,0,300,_A_D,_T_O2,_U_bf,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_2_PM25_TTL1000_CO2_MISIR_5000)
  {102,702,0,5000,_A_D,_T_CO2,_U_x10ppm,_S_1,_R_AVCC},//基准VCC
  
  #elif (JLY_MODEL==_2_CO2_Z14_5000)
  {102,702,0,5000,_A_D,_T_CO2,_U_x10ppm,_S_1,_R_2V5},//基准2.5  
  
  #elif (JLY_MODEL==_3_PM25_500)
  {12,172,0,500,_A_D,_T_PM25,_U_ug_m3,_S_0,_R_2V5},//整数
  
  #elif (JLY_MODEL==_2_YALI_160_10kpa_PTH) 
  {102,702,0,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_2_NTC_PH)||(JLY_MODEL==_2_PT_F100_200_PH)||(JLY_MODEL==_3_PH_14))
  {1002,7002,0,1400,_A_D,_T_PH,_U_ph,_S_2,_R_2V5},//2位小数
  
  

  
  #elif (JLY_MODEL==_2_WD_SW_0_500mm) 
  {102,702,0,5000,_A_D,_T_SW,_U_mm,_S_1,_R_2V5},//4-20mA
  #elif (JLY_MODEL==_2_WD_SW_0_1000mm)
  {102,702,0,10000,_A_D,_T_SW,_U_mm,_S_1,_R_2V5},//4-20mA
  #elif (JLY_MODEL==_2_WD_SW_500_10mm)
  {102,702,0,5000,_A_D,_T_SW,_U_x10mm,_S_1,_R_2V5},//4-20mA
  #elif (JLY_MODEL==_2_WD_SW_0_3000mm)
  {102,702,0,30000,_A_D,_T_SW,_U_mm,_S_1,_R_2V5},//4-20mA
  
  #elif ((JLY_MODEL==_2_NTC_TRSF)||(JLY_MODEL==_6_3NTC_3TRSF)||(JLY_MODEL==_4_TRSF)\
    ||(JLY_MODEL==_3_TRSF)||(JLY_MODEL==_2_TRSF)||(JLY_MODEL==_6_3NTC_3EC5)\
       ||(JLY_MODEL==_8_4NTC_4TRSF)||(JLY_MODEL==_4_2NTC_2TRSF)||(JLY_MODEL==_5_TRSF)||(JLY_MODEL==_6_TRSF)\
         ||(JLY_MODEL==_5_1W1TRSF_1W1TRSF_1W)||(JLY_MODEL==_6_1W1TRSF_1W1TRSF_2W)\
           ||(JLY_MODEL==_4_TRWD_TRSF_TYFS_ZF)||(JLY_MODEL==_3_WD_TRSF_GZ200K)||(JLY_MODEL==_5_WD_TRSF_GZ200K_WD_SD))
  {102,702,0,1000,_A_D,_T_TRSF,_U_bf,_S_1,_R_2V5},
  #elif ((JLY_MODEL==_2_PT_0_300)||(JLY_MODEL==_3_PT_0_300)||(JLY_MODEL==_4_PT_0_300)||(JLY_MODEL==_5_4PT_0_300_1NTC)\
    ||(JLY_MODEL==_6_3PT_0_300_3HIH)||(JLY_MODEL==_8_4PT_0_300_4HIH)||(JLY_MODEL==_8_4PT_4ROTYONIC)||(JLY_MODEL==_3_2PT_0_300_1HIH))
  {102,702,0,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  #elif  ((JLY_MODEL==_21_PT_F80_60))
  {102,702,800+0x8000,600,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_2_PT_F40_100)||(JLY_MODEL==_4_PT_F40_100)||(JLY_MODEL==_8_4PT_F40_100_4HIH)||(JLY_MODEL==_3_PT_F40_100))
  {102,702,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  #elif  ((JLY_MODEL==_2_PT_F100_200)||(JLY_MODEL==_3_PT_F100_200)\
    ||(JLY_MODEL==_4_PT_F100_200)||(JLY_MODEL==_5_4PT_F100_200_1NTC)||(JLY_MODEL==_8_4PT_F100_200_4HIH))
  {102,702,1000+0x8000,2000,_A_D,_T_T,_U_OC,_S_1,_R_EX},
  
  #elif (JLY_MODEL==_8_4PT_F100_300_4HIH)
  {102,702,1000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_EX},
  
  #elif ((JLY_MODEL==_2_PT_F200_100)||(JLY_MODEL==_3_PT_F200_100)||(JLY_MODEL==_4_PT_F200_100))
  {102,702,2000+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_2_PT_F100_100)||(JLY_MODEL==_4_PT_F100_100)||(JLY_MODEL==_3_PT_F100_100)||(JLY_MODEL==_8_3PT_F100_100_5NTC))
  {102,702,1000+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_PT_F150_150)
  {102,702,1500+0x8000,1500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_PT_F50_300)
  {102,702,500+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  #elif ((JLY_MODEL==_3_PT_F50_250)||(JLY_MODEL==_4_2PT_F50_250_2HIH)||(JLY_MODEL==_2_PT_F50_250)||(JLY_MODEL==_4_PT_F50_250))
  {102,702,500+0x8000,2500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_PT_F50_200)
  {102,702,500+0x8000,2000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_2_NTC_01YL)
  {102,702,0,10000,_A_D,_T_YL,_U_mm,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_2_PT_F50_350)
  {102,702,500+0x8000,3500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_2_CO2_5000PPM))
  {102,702,0,5000,_A_D,_T_CO2,_U_x10ppm,_S_1,_R_AVCC},//基准AVCC
  
  #elif (JLY_MODEL==_2_O2_CO2)
  {102,702,0,1000,_A_D,_T_CO2,_U_bf,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_3_YALI_400_kpa)
  {102,702,0,4000,_A_D,_T_YALI,_U_kpa,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_2_NTC_F20_120)
  {20,80,200+0x8000,1200,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_2_FS_FX)
  {102,702,0,360,_A_D,_T_FX,_U_x10o,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_2_LS_SS)||(JLY_MODEL==_4_2LS_2SS))
  {1002,2002,0,1000,_A_D,_T_SS,_U_m,_S_2,_R_AVCC},
  
  #elif (JLY_MODEL==_3_FS_FX_01YL)
  {102,702,0,360,_A_D,_T_FX,_U_x10o,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_3_CF)
  {0,500,0,1000,_A_D,_T_QY,_U_none,_S_1,_R_AVCC},
  
  #else
  {102,702,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  #endif
  
  //ch3...........................................................................
  #if ((JLY_MODEL==_3_NTC)||(JLY_MODEL==_4_NTC)||(JLY_MODEL==_5_NTC)||(JLY_MODEL==_8RF_6NTC_2F200)\
       ||(JLY_MODEL==_6_NTC)||(JLY_MODEL==_7_NTC)||(JLY_MODEL==_8_NTC)||(JLY_MODEL==_5_WD_SD_WD_GZ200K_CO2TTL5000)\
         ||(JLY_MODEL==_8_4NTC_4HIH5030)||(JLY_MODEL==_4_2NTC_2HIH5030)||(JLY_MODEL==_4_1NTC_1HIH_2NTC)||(JLY_MODEL==_6_3NTC_3EC5)\
          ||(JLY_MODEL==_6_4NTC_2HIH5030)||(JLY_MODEL==_6_3NTC_3TRSF)||(JLY_MODEL==_4_WD_SD_WD_GZ200K)||(JLY_MODEL==_5_2WD_2SD_GZ200K)\
            ||(JLY_MODEL==_6_3NTC_3HIH5030)||(JLY_MODEL==_8_4NTC_4TRSF)||(JLY_MODEL==_7_4NTC_2TRSF_1HIH)||(JLY_MODEL==_6_4NTC_1HIH_1TRSF)\
              ||(JLY_MODEL==_4_NTC_HIH_NTC_TRSF)||(JLY_MODEL==_3_2NTC_1HIH)||(JLY_MODEL==_6_1PT_F40_100_1HIH_2NTC_2HIH)\
                ||(JLY_MODEL==_5_4NTC_1HIH)||(JLY_MODEL==_4_2NTC_2TRSF)||(JLY_MODEL==_7_6NTC_1HIH)||(JLY_MODEL==_7_WD_SD_WD_GZ200K_CO2TTL5000_2WD)\
                  ||(JLY_MODEL==_4_3NTC_1HIH)||(JLY_MODEL==_5_4NTC_TRSF)||(JLY_MODEL==_6_5NTC_1HIH)||(JLY_MODEL==_8_7NTC_1HIH)\
                    ||(JLY_MODEL==_5_1W1TRSF_1W1TRSF_1W)||(JLY_MODEL==_6_1W1TRSF_1W1TRSF_2W)||(JLY_MODEL==_8_5NTC_HIH_NTC_HIH)||(JLY_MODEL==_8_134678NTC_25HIH)\
                      ||(JLY_MODEL==_8_6NTC_2HIH)||(JLY_MODEL==_8_4NTC_2HIH_2TRSF)||(JLY_MODEL==_6_1NTC_1HIH_2NTC_2TRSF)||(JLY_MODEL==_8_5NTC_3HIH)\
                        ||(JLY_MODEL==_5_WD_GZ100K_TRWD_TRSF_SD)||(JLY_MODEL==_7_WD_GZ100K_TRWD_TRSF_SD_YL01_QY)||(JLY_MODEL==_3_PT_F100_100_2NTC)\
                          ||(JLY_MODEL==_5_2NTC_2HIH_CO2_Z14_5000)||(JLY_MODEL==_7_3NTC_3HIH_CO2_Z14_5000)||(JLY_MODEL==_5_2NTC_2HIH_CO2_MISIR_5000)\
                            ||(JLY_MODEL==_7_3NTC_3HIH_CO2_MISIR_5000)||(JLY_MODEL==_8_3NTC_3HIH_2NTC)||(JLY_MODEL==_6_1NTC_1HIH_4NTC)\
                              ||(JLY_MODEL==_4_1PT_F100_200_2NTC_1HIH)||(JLY_MODEL==_6RF_4NTC_2F200)||(JLY_MODEL==_8_1PT_F100_200_7NTC)||(JLY_MODEL==_8_3NTC_3HIH5030_1HIH6130)\
                                ||(JLY_MODEL==_7RF_5NTC_2F200)||(JLY_MODEL==_4_PT_F100_100_3NTC))
  {20,80,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_6_HIH5030)||(JLY_MODEL==_6_WD_GZ100K_SD_YL01_FS_FX)||(JLY_MODEL==_6_WD_GZ100K_SD_YL05_FS_FX)\
    ||(JLY_MODEL==_8_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)||(JLY_MODEL==_4_WD_GZ100K_SD_YL01)||(JLY_MODEL==_4_2PT_F50_250_2HIH)||(JLY_MODEL==_8_HIH5030)\
      ||(JLY_MODEL==_3_2PT_0_300_1HIH)||(JLY_MODEL==_6_2NTC_2HIH_2GZ100K)||(JLY_MODEL==_7_WD_GZ200K_SD_YL01_FS_FX_TRWD)\
        ||(JLY_MODEL==_4_HIH5030)||(JLY_MODEL==_8_WD_GZ200K_SD_YL01_FS_FX_TRWD_TRSF)||(JLY_MODEL==_3_2_NTC_1HIH))
  {103,703,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_3_NTC_HIH_CO2_5000PPM)
  {103,703,0,5000,_A_D,_T_CO2,_U_x10ppm,_S_1,_R_AVCC},//基准AVCC
  
  #elif (JLY_MODEL==_3RF_2NTC_1F200)
  {103,703,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_3_NTC_HIH_CO2TTL10BF)
  {103,703,0,1000,_A_D,_T_CO2,_U_bf,_S_2,_R_2V5},
  
  #elif (JLY_MODEL==_3_NTC_HIH_CO2TTL20BF)
  {103,703,0,2000,_A_D,_T_CO2,_U_bf,_S_2,_R_2V5},
  
  #elif (JLY_MODEL==_3_WD_F10_60_SD_0_100_JDSD_0_200)
  {103,703,0,2000,_A_D,_T_H,_U_g_m3,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_3_NTC_HIH5030_01YL)
  {103,703,0,10000,_A_D,_T_YL,_U_mm,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_4_WD420mA_0_800)
  {103,703,0,8000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_WD420mA_0_400)
  {103,703,0,4000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_2LS_2SS)
  {1003,2003,100+0x8000,500,_A_D,_T_LS,_U_m_s,_S_2,_R_AVCC},
  
  #elif (JLY_MODEL==_4_TRWD_TRSF_TYFS_ZF)
  {103,703,0,2000,_A_D,_T_TYFS,_U_x10w_m2,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_3_DL_10A)
  {1003,7003,0,1000,_A_D,_T_DL,_U_a,_S_2,_R_2V5},
  
  #elif (JLY_MODEL==_3_DY_150v)
  {103,703,0,1500,_A_D,_T_DY,_U_v,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_5RF_F200)||(JLY_MODEL==_3RF_F200)||(JLY_MODEL==_6RF_F200)||(JLY_MODEL==_4RF_2F200_2HIH))
  {103,203,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_3_K_F200_1350)
  {103,203,2000+0x8000,13500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_RTD_F200_300)
  {103,203,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_PT_F50_150)
  {103,703,500+0x8000,1500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_3_PT_F200_100)||(JLY_MODEL==_4_PT_F200_100)||(JLY_MODEL==_4_2PT_F200_100_2HIH))
  {103,703,2000+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_3_PT_F50_300)
  {103,703,500+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_4_PT_F100_100)||(JLY_MODEL==_3_PT_F100_100)||(JLY_MODEL==_8_3PT_F100_100_5NTC))
  {103,703,1000+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_3_PM25_500)
  {13,173,0,500,_A_D,_T_PM25,_U_ug_m3,_S_0,_R_2V5},//整数
  
  #elif ((JLY_MODEL==_8_DS18B20_F55_125)||(JLY_MODEL==_6_DS18B20_F55_125)||(JLY_MODEL==_4_DS18B20_F55_125)\
    ||(JLY_MODEL==_3_DS18B20_F55_125))
  {103,703,550+0x8000,1250,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},

  #elif (JLY_MODEL==_8_4WD_0_80_4SD_0_100)
  {103,203,0,800,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  
  #elif (JLY_MODEL==_4_WD_SD_FS_FX)
  {103,703,0,600,_A_D,_T_FS,_U_m_s,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_3_WD_SD_CO2TTL10000)
  {103,703,0,10000,_A_D,_T_CO2,_U_x10ppm,_S_1,_R_AVCC},//基准AVCC
  
  #elif ((JLY_MODEL==_4_WD_SD_CO2_5000_GZ200K)||(JLY_MODEL==_4_WD_SD_CO2TTL5000_GZ200K)||(JLY_MODEL==_6_WD_SD_CO2TTL5000_GZ200K_WD_TRSF)\
    ||(JLY_MODEL==_8_NTC_HIH_CO2TTL5000_GZ200K_QY_NH3_H2S_CH4))
  {103,703,0,5000,_A_D,_T_CO2,_U_x10ppm,_S_1,_R_AVCC},//基准AVCC

  #elif ((JLY_MODEL==_3_PT_0_300)||(JLY_MODEL==_4_PT_0_300)||(JLY_MODEL==_6_2PT_2ROTYONIC_NTC_HIH)\
    ||(JLY_MODEL==_5_4PT_0_300_1NTC)||(JLY_MODEL==_4_2PTH_2HIH)||(JLY_MODEL==_6_3PT_0_300_3HIH)||(JLY_MODEL==_8_4PT_4ROTYONIC)\
     ||(JLY_MODEL==_8_4PT_0_300_4HIH) )
  {103,703,0,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_2PT_F50_100_2HIH)
  {103,703,500+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_4_PT_F40_100)||(JLY_MODEL==_3_1NTC_1HIH_1PT_F40_100)||(JLY_MODEL==_8_4PT_F40_100_4HIH)\
    ||(JLY_MODEL==_4_2PT_F40_100_2HIH)||(JLY_MODEL==_3_PT_F40_100))
  {103,703,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_7RF_1NTC_1HIH_5F200)
  {103,703,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif  ((JLY_MODEL==_3_PT_F100_200)||(JLY_MODEL==_4_PT_F100_200)||(JLY_MODEL==_5_4PT_F100_200_1NTC)\
    ||(JLY_MODEL==_8_4PT_F100_200_4HIH)||(JLY_MODEL==_4_2PT_F100_200_2HIH))
  {103,703,1000+0x8000,2000,_A_D,_T_T,_U_OC,_S_1,_R_EX},
  
  #elif (JLY_MODEL==_8_4PT_F100_300_4HIH)
  {103,703,1000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_EX},
  
  #elif (JLY_MODEL==_4_PT_F150_150)
  {103,703,1500+0x8000,1500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_3_PT_F50_250)||(JLY_MODEL==_4_PT_F50_250))
  {103,703,500+0x8000,2500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_4_PT_F50_200)||(JLY_MODEL==_4_2PT_F50_200_2HIH))
  {103,703,500+0x8000,2000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_3_PH_14)
  {1003,7003,0,1400,_A_D,_T_PH,_U_ph,_S_2,_R_AVCC},//2位小数  
  
  #elif (JLY_MODEL==_3_WD_SD_GZ100K)
  {1003,7003,0,10000,_A_D,_T_GZ,_U_klx,_S_2,_R_AVCC},//2位小数
  
  #elif ((JLY_MODEL==_3_WD_SD_GZ200K)||(JLY_MODEL==_3_WD_TRSF_GZ200K)||(JLY_MODEL==_5_WD_TRSF_GZ200K_WD_SD))
  {1003,7003,0,20000,_A_D,_T_GZ,_U_klx,_S_2,_R_AVCC},//2位小数
  
  #elif ((JLY_MODEL==_8B_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)\
    ||(JLY_MODEL==_8B_WD_GZV200K_SD_YL01_TRWD_TRSF_FS_FX))
  {103,703,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_6B_WD_SD_QY_YL01_FS_FX)||(JLY_MODEL==_3_WD_SD_QY)||(JLY_MODEL==_6_WD_SD_QY_YL01_FS_FX))
  {1003,7003,3000,12000,_A_D,_T_QY,_U_kpa,_S_2,_R_2V5},//2bit
  
  #elif (JLY_MODEL==_3_YALI_400_kpa)
  {103,703,0,4000,_A_D,_T_YALI,_U_kpa,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_3_FS_FX_01YL)
  {103,703,0,10000,_A_D,_T_YL,_U_mm,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_3_WD_SD_GH400_10umol)
  {103,703,0,4000,_A_D,_T_GHYXFS,_U_x10umol,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_PT_F50_300)
  {103,703,500+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_3_CF)
  {0,500,0,1000,_A_D,_T_QY,_U_none,_S_1,_R_AVCC},
  
  
  #elif ((JLY_MODEL==_3_2NTC_TRSF)||(JLY_MODEL==_4_TRSF)||(JLY_MODEL==_5_TRSF)||(JLY_MODEL==_6_TRSF)\
    ||(JLY_MODEL==_3_TRSF)||(JLY_MODEL==_3B_WD_GZ100K_TRSF)||(JLY_MODEL==_3_NTC_HIH_TRSF))
  {103,703,0,1000,_A_D,_T_TRSF,_U_bf,_S_1,_R_2V5},
  #else
  {103,703,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  #endif
  
  //ch4...........................................................................
  #if ((JLY_MODEL==_4_NTC)||(JLY_MODEL==_5_NTC)||(JLY_MODEL==_6_NTC)||(JLY_MODEL==_7_6NTC_1HIH)||(JLY_MODEL==_4_1NTC_1HIH_2NTC)\
       ||(JLY_MODEL==_7_NTC)||(JLY_MODEL==_8_NTC)||(JLY_MODEL==_6_4NTC_2HIH5030)||(JLY_MODEL==_6_5NTC_1HIH)||(JLY_MODEL==_8_7NTC_1HIH)\
         ||(JLY_MODEL==_5_4NTC_1HIH)||(JLY_MODEL==_5_4NTC_TRSF)||(JLY_MODEL==_8_6NTC_2HIH)||(JLY_MODEL==_8_5NTC_3HIH)||(JLY_MODEL==_8_134678NTC_25HIH)\
           ||(JLY_MODEL==_7_4NTC_2TRSF_1HIH)||(JLY_MODEL==_6_4NTC_1HIH_1TRSF)||(JLY_MODEL==_8_5NTC_HIH_NTC_HIH)||(JLY_MODEL==_6_1NTC_1HIH_4NTC)\
             ||(JLY_MODEL==_8RF_6NTC_2F200)||(JLY_MODEL==_5_WD_TRSF_GZ200K_WD_SD)||(JLY_MODEL==_6RF_4NTC_2F200)||(JLY_MODEL==_8_1PT_F100_200_7NTC)\
               ||(JLY_MODEL==_7RF_5NTC_2F200)||(JLY_MODEL==_4_PT_F100_100_3NTC)||(JLY_MODEL==_8_3PT_F100_100_5NTC))
  {20,80,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_8_DS18B20_F55_125)||(JLY_MODEL==_6_DS18B20_F55_125)||(JLY_MODEL==_4_DS18B20_F55_125))
  {104,704,550+0x8000,1250,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_4_WD_SD_WD_GZ200K)||(JLY_MODEL==_5_WD_SD_WD_GZ200K_CO2TTL5000)||(JLY_MODEL==_7_WD_SD_WD_GZ200K_CO2TTL5000_2WD) \
    ||(JLY_MODEL==_8_NTC_HIH_CO2TTL5000_GZ200K_QY_NH3_H2S_CH4))
  {1004,7004,0,20000,_A_D,_T_GZ,_U_klx,_S_2,_R_AVCC},//2位小数
  
  #elif ((JLY_MODEL==_8_4NTC_4HIH5030)||(JLY_MODEL==_4_2NTC_2HIH5030)||(JLY_MODEL==_6_3NTC_3HIH5030)\
    ||(JLY_MODEL==_4_3NTC_1HIH)||(JLY_MODEL==_8_4WD_0_80_4SD_0_100)||(JLY_MODEL==_6_1PT_F40_100_1HIH_2NTC_2HIH)\
      ||(JLY_MODEL==_6_HIH5030)||(JLY_MODEL==_4_2PTH_2HIH)||(JLY_MODEL==_4_2PT_F50_100_2HIH)||(JLY_MODEL==_6_2NTC_2HIH_2GZ100K)\
        ||(JLY_MODEL==_8_4NTC_2HIH_2TRSF)||(JLY_MODEL==_6_3PT_0_300_3HIH)||(JLY_MODEL==_4_2PT_F50_250_2HIH)||(JLY_MODEL==_4_2PT_F50_200_2HIH)\
          ||(JLY_MODEL==_5_2NTC_2HIH_CO2_Z14_5000)||(JLY_MODEL==_7_3NTC_3HIH_CO2_Z14_5000)||(JLY_MODEL==_5_2NTC_2HIH_CO2_MISIR_5000)\
            ||(JLY_MODEL==_7_3NTC_3HIH_CO2_MISIR_5000)||(JLY_MODEL==_8_HIH5030)||(JLY_MODEL==_8_3NTC_3HIH_2NTC)||(JLY_MODEL==_4_2PT_F200_100_2HIH)\
              ||(JLY_MODEL==_4_1PT_F100_200_2NTC_1HIH)||(JLY_MODEL==_4_2PT_F40_100_2HIH)||(JLY_MODEL==_4_2PT_F100_200_2HIH)\
                ||(JLY_MODEL==_4RF_2F200_2HIH)||(JLY_MODEL==_4_HIH5030)||(JLY_MODEL==_5_2WD_2SD_GZ200K)||(JLY_MODEL==_8_3NTC_3HIH5030_1HIH6130))
  {0,1000,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_4_WD420mA_0_800)
  {104,704,0,8000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_WD420mA_0_400)
  {104,704,0,4000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_WD_SD_FS_FX)
  {104,704,0,360,_A_D,_T_FX,_U_x10o,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_7RF_1NTC_1HIH_5F200)
  {104,704,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_TRWD_TRSF_TYFS_ZF)
  {104,704,0,2400,_A_D,_T_ZF,_U_mm,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_6_2PT_2ROTYONIC_NTC_HIH)
  {104,704,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_2LS_2SS)
  {1004,2004,0,1000,_A_D,_T_SS,_U_m,_S_2,_R_AVCC},
  
  #elif ((JLY_MODEL==_4_WD_SD_CO2_5000_GZ200K)||(JLY_MODEL==_4_WD_SD_CO2TTL5000_GZ200K)||(JLY_MODEL==_6_WD_SD_CO2TTL5000_GZ200K_WD_TRSF))
  {104,704,0,2000,_A_D,_T_GZ,_U_klx,_S_1,_R_2V5},//基准2.5
  
  #elif ((JLY_MODEL==_4_PT_F50_250))
  {104,704,500+0x8000,2500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_PT_F50_200)
  {104,704,500+0x8000,2000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_4_PT_F200_100))
  {104,704,2000+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_PT_F100_100)
  {104,704,1000+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_PT_F50_150)
  {104,704,500+0x8000,1500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_4_PT_F40_100)||(JLY_MODEL==_8_4PT_F40_100_4HIH))
  {104,704,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  #elif ((JLY_MODEL==_4_PT_0_300)||(JLY_MODEL==_8_4PT_0_300_4HIH)||(JLY_MODEL==_5_4PT_0_300_1NTC)||(JLY_MODEL==_8_4PT_4ROTYONIC))
  {104,704,0,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  #elif  ((JLY_MODEL==_4_PT_F100_200)||(JLY_MODEL==_5_4PT_F100_200_1NTC)||(JLY_MODEL==_8_4PT_F100_200_4HIH))
  {104,704,1000+0x8000,2000,_A_D,_T_T,_U_OC,_S_1,_R_EX},
  
  #elif (JLY_MODEL==_8_4PT_F100_300_4HIH)
  {104,704,1000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_EX},
  
  #elif (JLY_MODEL==_4_PT_F150_150)
  {104,704,1500+0x8000,1500,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_4_RTD_F200_300)
  {104,204,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_5RF_F200)||(JLY_MODEL==_6RF_F200))
  {104,204,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_6_3NTC_3TRSF)||(JLY_MODEL==_6_1NTC_1HIH_2NTC_2TRSF)||(JLY_MODEL==_4_TRSF)||(JLY_MODEL==_8_4NTC_4TRSF)\
    ||(JLY_MODEL==_4_NTC_HIH_NTC_TRSF)||(JLY_MODEL==_4_2NTC_2TRSF)||(JLY_MODEL==_5_TRSF)||(JLY_MODEL==_6_TRSF)\
      ||(JLY_MODEL==_5_1W1TRSF_1W1TRSF_1W)||(JLY_MODEL==_6_1W1TRSF_1W1TRSF_2W)||(JLY_MODEL==_6_3NTC_3EC5)\
        ||(JLY_MODEL==_5_WD_GZ100K_TRWD_TRSF_SD)||(JLY_MODEL==_7_WD_GZ100K_TRWD_TRSF_SD_YL01_QY))
  {104,704,0,1000,_A_D,_T_TRSF,_U_bf,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_6_WD_GZ100K_SD_YL01_FS_FX)||(JLY_MODEL==_6_WD_GZ100K_SD_YL05_FS_FX)\
    ||(JLY_MODEL==_8_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)||(JLY_MODEL==_4_WD_GZ100K_SD_YL01)||(JLY_MODEL==_7_WD_GZ200K_SD_YL01_FS_FX_TRWD)\
      ||(JLY_MODEL==_8_WD_GZ200K_SD_YL01_FS_FX_TRWD_TRSF))
  {104,704,0,10000,_A_D,_T_YL,_U_mm,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_8B_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)\
    ||(JLY_MODEL==_8B_WD_GZV200K_SD_YL01_TRWD_TRSF_FS_FX)||(JLY_MODEL==_6B_WD_SD_QY_YL01_FS_FX)||(JLY_MODEL==_6_WD_SD_QY_YL01_FS_FX)\
      )
  {104,704,0,10000,_A_D,_T_YL,_U_mm,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_4_PT_F50_300)
  {104,704,500+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #else
  {104,704,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  #endif
  
  //ch5.................................................................................
  #if ((JLY_MODEL==_5_NTC)||(JLY_MODEL==_6_NTC)||(JLY_MODEL==_6_1NTC_1HIH_4NTC)||(JLY_MODEL==_8RF_6NTC_2F200)\
       ||(JLY_MODEL==_7_NTC)||(JLY_MODEL==_8_NTC)||(JLY_MODEL==_8_4NTC_4HIH5030)||(JLY_MODEL==_8_1PT_F100_200_7NTC)\
         ||(JLY_MODEL==_6_3NTC_3TRSF)||(JLY_MODEL==_8_4NTC_4TRSF)||(JLY_MODEL==_8_3NTC_3HIH_2NTC)||(JLY_MODEL==_6_3NTC_3EC5)\
           ||(JLY_MODEL==_6_3NTC_3HIH5030)||(JLY_MODEL==_8B_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)||(JLY_MODEL==_8_3NTC_3HIH5030_1HIH6130)\
             ||(JLY_MODEL==_8B_WD_GZV200K_SD_YL01_TRWD_TRSF_FS_FX)||(JLY_MODEL==_5_1W1TRSF_1W1TRSF_1W)||(JLY_MODEL==_6_WD_SD_CO2TTL5000_GZ200K_WD_TRSF)\
               ||(JLY_MODEL==_6_2PT_2ROTYONIC_NTC_HIH)||(JLY_MODEL==_6_1W1TRSF_1W1TRSF_2W)||(JLY_MODEL==_8_5NTC_HIH_NTC_HIH)\
                 ||(JLY_MODEL==_5_4PT_0_300_1NTC)||(JLY_MODEL==_5_4PT_F100_200_1NTC)||(JLY_MODEL==_8_6NTC_2HIH)\
                   ||(JLY_MODEL==_8_4NTC_2HIH_2TRSF)||(JLY_MODEL==_8_5NTC_3HIH)||(JLY_MODEL==_8_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)\
                     ||(JLY_MODEL==_6_1NTC_1HIH_2NTC_2TRSF)||(JLY_MODEL==_7_6NTC_1HIH)||(JLY_MODEL==_6_5NTC_1HIH)||(JLY_MODEL==_8_7NTC_1HIH)\
                       ||(JLY_MODEL==_7_3NTC_3HIH_CO2_Z14_5000)||(JLY_MODEL==_7_3NTC_3HIH_CO2_MISIR_5000)||(JLY_MODEL==_6_1PT_F40_100_1HIH_2NTC_2HIH)\
                         ||(JLY_MODEL==_7RF_5NTC_2F200)||(JLY_MODEL==_8_3PT_F100_100_5NTC)\
   )
  {20,300,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_6_HIH5030)||(JLY_MODEL==_5_WD_GZ100K_TRWD_TRSF_SD)||(JLY_MODEL==_7_WD_GZ100K_TRWD_TRSF_SD_YL01_QY)||(JLY_MODEL==_8_134678NTC_25HIH)\
    ||(JLY_MODEL==_6_3PT_0_300_3HIH)||(JLY_MODEL==_8_4PT_0_300_4HIH)||(JLY_MODEL==_8_HIH5030)||(JLY_MODEL==_6_4NTC_1HIH_1TRSF)\
      ||(JLY_MODEL==_8_4PT_F40_100_4HIH)||(JLY_MODEL==_5_WD_TRSF_GZ200K_WD_SD)||(JLY_MODEL==_8_4PT_F100_200_4HIH)||(JLY_MODEL==_8_4PT_F100_300_4HIH))
  {105,705,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_5_WD_SD_WD_GZ200K_CO2TTL5000)||(JLY_MODEL==_7_WD_SD_WD_GZ200K_CO2TTL5000_2WD))
  {105,705,0,5000,_A_D,_T_CO2,_U_x10ppm,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_8_NTC_HIH_CO2TTL5000_GZ200K_QY_NH3_H2S_CH4)
  {1005,7005,3000,12000,_A_D,_T_QY,_U_kpa,_S_2,_R_2V5},
  
  #elif (JLY_MODEL==_6RF_4NTC_2F200)
  {105,705,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_6_2NTC_2HIH_2GZ100K)
  {1005,7005,0,10000,_A_D,_T_GZ,_U_klx,_S_2,_R_AVCC},//2位小数
  
  #elif ((JLY_MODEL==_8_DS18B20_F55_125)||(JLY_MODEL==_6_DS18B20_F55_125))
  {105,705,550+0x8000,1250,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_8_4PT_4ROTYONIC)
  {105,705,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_5_2WD_2SD_GZ200K)
  {1005,7005,0,20000,_A_D,_T_GZ,_U_klx,_S_2,_R_AVCC},//2位小数
  
  #elif (JLY_MODEL==_8_4WD_0_80_4SD_0_100)
  {105,205,0,800,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_5RF_F200)||(JLY_MODEL==_6RF_F200))
  {105,205,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_7RF_1NTC_1HIH_5F200)
  {105,705,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},

  #elif ((JLY_MODEL==_6_4NTC_2HIH5030)||(JLY_MODEL==_5_4NTC_1HIH))
  {105,705,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_6_WD_GZ100K_SD_YL01_FS_FX)||(JLY_MODEL==_6_WD_GZ100K_SD_YL05_FS_FX)||(JLY_MODEL==_6B_WD_SD_QY_YL01_FS_FX)\
    ||(JLY_MODEL==_6_WD_SD_QY_YL01_FS_FX)||(JLY_MODEL==_7_WD_GZ200K_SD_YL01_FS_FX_TRWD)||(JLY_MODEL==_8_WD_GZ200K_SD_YL01_FS_FX_TRWD_TRSF))
  {105,705,0,600,_A_D,_T_FS,_U_m_s,_S_1,_R_AVCC},
  
  #elif  ((JLY_MODEL==_5_4NTC_TRSF)||(JLY_MODEL==_5_TRSF)||(JLY_MODEL==_6_TRSF)||(JLY_MODEL==_7_4NTC_2TRSF_1HIH))
  {105,705,0,1000,_A_D,_T_TRSF,_U_bf,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_5_2NTC_2HIH_CO2_Z14_5000)
  {105,705,0,5000,_A_D,_T_CO2,_U_x10ppm,_S_1,_R_2V5},//基准2.5
  
  #elif (JLY_MODEL==_5_2NTC_2HIH_CO2_MISIR_5000)
  {105,705,0,5000,_A_D,_T_CO2,_U_x10ppm,_S_1,_R_AVCC},//基准VCC
  
  #else
  {105,705,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  #endif
   
  //ch6...........................................................................
  #if ((JLY_MODEL==_6_NTC)||(JLY_MODEL==_7_NTC)||(JLY_MODEL==_8_NTC)||(JLY_MODEL==_6_1W1TRSF_1W1TRSF_2W)||(JLY_MODEL==_8_134678NTC_25HIH)\
    ||(JLY_MODEL==_8_6NTC_2HIH)||(JLY_MODEL==_7_6NTC_1HIH)||(JLY_MODEL==_6_1NTC_1HIH_4NTC)||(JLY_MODEL==_8RF_6NTC_2F200)\
      ||(JLY_MODEL==_7_WD_SD_WD_GZ200K_CO2TTL5000_2WD)||(JLY_MODEL==_8_1PT_F100_200_7NTC)||(JLY_MODEL==_8_7NTC_1HIH)||(JLY_MODEL==_8_3PT_F100_100_5NTC))
  {20,80,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_6_HIH5030)||(JLY_MODEL==_8_5NTC_3HIH)||(JLY_MODEL==_6_3PT_0_300_3HIH)||(JLY_MODEL==_6_5NTC_1HIH)\
    ||(JLY_MODEL==_7_3NTC_3HIH_CO2_Z14_5000)||(JLY_MODEL==_7_3NTC_3HIH_CO2_MISIR_5000)||(JLY_MODEL==_8_HIH5030)\
      ||(JLY_MODEL==_6_1PT_F40_100_1HIH_2NTC_2HIH)||(JLY_MODEL==_8_4NTC_4HIH5030)||(JLY_MODEL==_6_4NTC_2HIH5030)\
        ||(JLY_MODEL==_6_3NTC_3HIH5030)||(JLY_MODEL==_8_4WD_0_80_4SD_0_100)||(JLY_MODEL==_6_2PT_2ROTYONIC_NTC_HIH)\
          ||(JLY_MODEL==_8_3NTC_3HIH_2NTC)||(JLY_MODEL==_8_5NTC_HIH_NTC_HIH)||(JLY_MODEL==_8_4PT_0_300_4HIH)\
            ||(JLY_MODEL==_8_4PT_F40_100_4HIH)||(JLY_MODEL==_8_4PT_F100_200_4HIH)||(JLY_MODEL==_8_3NTC_3HIH5030_1HIH6130)||(JLY_MODEL==_8_4PT_F100_300_4HIH))
  {0,1000,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_6_2NTC_2HIH_2GZ100K)
  {1006,7006,0,10000,_A_D,_T_GZ,_U_klx,_S_2,_R_AVCC},//2位小数
  
  #elif (JLY_MODEL==_8_4PT_4ROTYONIC)
  {106,706,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_6RF_4NTC_2F200)||(JLY_MODEL==_7RF_5NTC_2F200))
  {106,706,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif ((JLY_MODEL==_8_DS18B20_F55_125)||(JLY_MODEL==_6_DS18B20_F55_125))
  {106,706,550+0x8000,1250,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_7RF_1NTC_1HIH_5F200)
  {106,706,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_6RF_F200)
  {106,206,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  
  #elif (JLY_MODEL==_8_NTC_HIH_CO2TTL5000_GZ200K_QY_NH3_H2S_CH4)
  {106,706,0,500,_A_D,_T_NH3,_U_ppm,_S_1,_R_AVCC},//NH3  0.6~3V   选_R_AVCC
  

  #elif ((JLY_MODEL==_6_3NTC_3TRSF)||(JLY_MODEL==_8_4NTC_4TRSF)||(JLY_MODEL==_6_TRSF)||(JLY_MODEL==_8_4NTC_2HIH_2TRSF)||(JLY_MODEL==_6_3NTC_3EC5)\
    ||(JLY_MODEL==_8_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)||(JLY_MODEL==_6_1NTC_1HIH_2NTC_2TRSF)||(JLY_MODEL==_7_4NTC_2TRSF_1HIH)||(JLY_MODEL==_6_WD_SD_CO2TTL5000_GZ200K_WD_TRSF)\
      ||(JLY_MODEL==_6_4NTC_1HIH_1TRSF)||(JLY_MODEL==_8B_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)||(JLY_MODEL==_8B_WD_GZV200K_SD_YL01_TRWD_TRSF_FS_FX))
  {106,706,0,1000,_A_D,_T_TRSF,_U_bf,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_7_WD_GZ100K_TRWD_TRSF_SD_YL01_QY)
  {106,706,0,10000,_A_D,_T_YL,_U_mm,_S_1,_R_AVCC},
  

  #elif ((JLY_MODEL==_6_WD_GZ100K_SD_YL01_FS_FX)||(JLY_MODEL==_6_WD_GZ100K_SD_YL05_FS_FX)||(JLY_MODEL==_6B_WD_SD_QY_YL01_FS_FX)\
    ||(JLY_MODEL==_6_WD_SD_QY_YL01_FS_FX)||(JLY_MODEL==_7_WD_GZ200K_SD_YL01_FS_FX_TRWD)||(JLY_MODEL==_8_WD_GZ200K_SD_YL01_FS_FX_TRWD_TRSF))
  {106,706,0,360,_A_D,_T_FX,_U_x10o,_S_1,_R_AVCC},
  
  #else
  {106,706,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  #endif
   
  //ch7..............................................................................
  #if ((JLY_MODEL==_7_NTC)||(JLY_MODEL==_8_NTC)||(JLY_MODEL==_8_4NTC_4HIH5030)||(JLY_MODEL==_7_WD_SD_WD_GZ200K_CO2TTL5000_2WD)\
    ||(JLY_MODEL==_8_4NTC_4TRSF)||(JLY_MODEL==_8_4NTC_2HIH_2TRSF)||(JLY_MODEL==_8_3NTC_3HIH_2NTC)||(JLY_MODEL==_8_5NTC_HIH_NTC_HIH)\
      ||(JLY_MODEL==_7_WD_GZ200K_SD_YL01_FS_FX_TRWD)||(JLY_MODEL==_8_1PT_F100_200_7NTC)||(JLY_MODEL==_8_WD_GZ200K_SD_YL01_FS_FX_TRWD_TRSF)\
        ||(JLY_MODEL==_8_3NTC_3HIH5030_1HIH6130)||(JLY_MODEL==_8_7NTC_1HIH)||(JLY_MODEL==_8_134678NTC_25HIH)||(JLY_MODEL==_8_3PT_F100_100_5NTC))
  {20,300,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_8_6NTC_2HIH)||(JLY_MODEL==_8_5NTC_3HIH)||(JLY_MODEL==_7_6NTC_1HIH)||(JLY_MODEL==_7_4NTC_2TRSF_1HIH)||(JLY_MODEL==_8_HIH5030)\
    ||(JLY_MODEL==_8_4PT_0_300_4HIH)||(JLY_MODEL==_8_4PT_F40_100_4HIH)||(JLY_MODEL==_8_4PT_F100_200_4HIH)||(JLY_MODEL==_8_4PT_F100_300_4HIH))
  {107,707,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_7RF_5NTC_2F200)
  {107,707,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_8_4PT_4ROTYONIC)
  {107,707,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_7_WD_GZ100K_TRWD_TRSF_SD_YL01_QY)
  {1007,7007,3000,12000,_A_D,_T_QY,_U_kpa,_S_2,_R_2V5},
  
  #elif ((JLY_MODEL==_7RF_1NTC_1HIH_5F200)||(JLY_MODEL==_8RF_6NTC_2F200))
  {107,707,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
 
  
  #elif (JLY_MODEL==_8_DS18B20_F55_125)
  {107,707,550+0x8000,1250,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_8_4WD_0_80_4SD_0_100)
  {107,207,0,800,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_8_NTC_HIH_CO2TTL5000_GZ200K_QY_NH3_H2S_CH4)
  {107,707,0,500,_A_D,_T_H2S,_U_ppm,_S_1,_R_AVCC},   //H2S  0.6~3V   选_R_AVCC
  
  #elif (JLY_MODEL==_8_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)
  {107,707,0,600,_A_D,_T_FS,_U_m_s,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_8B_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)\
    ||(JLY_MODEL==_8B_WD_GZV200K_SD_YL01_TRWD_TRSF_FS_FX))
  {107,707,0,600,_A_D,_T_FS,_U_m_s,_S_1,_R_AVCC},
  
  
  #elif (JLY_MODEL==_7_3NTC_3HIH_CO2_Z14_5000)
  {107,707,0,5000,_A_D,_T_CO2,_U_x10ppm,_S_1,_R_2V5},//基准2.5
  
  #elif (JLY_MODEL==_7_3NTC_3HIH_CO2_MISIR_5000)
  {107,707,0,5000,_A_D,_T_CO2,_U_x10ppm,_S_1,_R_AVCC},//基准VCC
  
  #else
  {107,707,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  #endif
  
  //ch8............................................................................
  #if ((JLY_MODEL==_8_NTC)||(JLY_MODEL==_8_3NTC_3HIH_2NTC)||(JLY_MODEL==_8_1PT_F100_200_7NTC)||(JLY_MODEL==_8_134678NTC_25HIH)||(JLY_MODEL==_8_3PT_F100_100_5NTC))
  {20,80,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_8_DS18B20_F55_125)
  {108,708,550+0x8000,1250,_A_D,_T_T,_U_OC,_S_1,_R_AVCC},
  
  #elif (JLY_MODEL==_8_4PT_4ROTYONIC)
  {108,708,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_2V5},
  
  #elif JLY_MODEL==_8RF_6NTC_2F200
  {108,708,2000+0x8000,3000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  
  #elif (JLY_MODEL==_8_NTC_HIH_CO2TTL5000_GZ200K_QY_NH3_H2S_CH4)//甲烷 5%  2位小数
  {108,408,0,500,_A_D,_T_CH4,_U_bf,_S_2,_R_2V5},
  
  #elif (JLY_MODEL==_8_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)
  {108,708,0,360,_A_D,_T_FX,_U_x10o,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_8B_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)\
    ||(JLY_MODEL==_8B_WD_GZV200K_SD_YL01_TRWD_TRSF_FS_FX))
  {108,708,0,360,_A_D,_T_FX,_U_x10o,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_8_4NTC_4HIH5030)||(JLY_MODEL==_8_4WD_0_80_4SD_0_100)||(JLY_MODEL==_8_4PT_F100_300_4HIH)||(JLY_MODEL==_8_7NTC_1HIH)\
    ||(JLY_MODEL==_8_6NTC_2HIH)||(JLY_MODEL==_8_5NTC_3HIH)||(JLY_MODEL==_8_HIH5030)||(JLY_MODEL==_8_5NTC_HIH_NTC_HIH)\
      ||(JLY_MODEL==_8_4PT_0_300_4HIH)||(JLY_MODEL==_8_4PT_F40_100_4HIH)||(JLY_MODEL==_8_4PT_F100_200_4HIH)||(JLY_MODEL==_8_3NTC_3HIH5030_1HIH6130))
  {0,1000,0,1000,_A_D,_T_H,_U_RH,_S_1,_R_AVCC},
  
  #elif ((JLY_MODEL==_8_4NTC_4TRSF)||(JLY_MODEL==_8_4NTC_2HIH_2TRSF)||(JLY_MODEL==_8_WD_GZ200K_SD_YL01_FS_FX_TRWD_TRSF))
  {108,708,0,1000,_A_D,_T_TRSF,_U_bf,_S_1,_R_2V5},

  #else
  {108,708,400+0x8000,1000,_A_D,_T_T,_U_OC,_S_1,_R_2V5},
  #endif
};

//默认曲线，未使用的曲线不会编译==================================================
//注意：曲线间距值(1个字节)不能大于255

//温度-------------------------------------------------------------------------
//(-40,100)
const StructCurve ntc_f40_100_first={//-40-100,10k-ntc, ref avcc
152,253,416,650,972,1374,1597,1820,2268,2672,3016,3284,3492,3640,3836,//15
10,10,10,10,10,5,5,10,10,10,10,10,10,20,//14
15,//1
};

//(-40-100),数字(保护15这个点)
const StructCurve sz_f40_100_first={
0,100,200,300,400,500,550,600,700,800,900,1000,1100,1200,1400,
10,10,10,10,10,5,5,10,10,10,10,10,10,20,
15,//1
};

//(-20,120)
const StructCurve ntc_f20_120_first={
416,650,972,1374,1820,2268,2672,3016,3284,3492,3640,3756,3836,3897,3942,//15
10,10,10,10,10,10,10,10,10,10,10,10,10,10,//14
15,//1
};

const StructCurve digit_f40_100_first={//-40-100
0,100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,//15
10,10,10,10,10,10,10,10,10,10,10,10,10,10,//14
15,//1
};

//DS18B20(-55,125)
const StructCurve digit_f55_125_first={
0, 250, 350,450,550,650,700,750,850,1800,3968,0,0,0,0,//11
25,10,10,10,10,5,5,10,95,0,0,0,0,0,//10
10,//1
};


//K热电偶(-200,1350)
const StructCurve digit_f200_1350_first={
0, 2000, 4000,6000,8000,10000,12000,14000,15500,1800,3968,0,0,0,0,//11
200,200,200,200,200,200,200,150,95,0,0,0,0,0,//10
9,//1
};

//RTD max31865 (-200,300)
const StructCurve digit_f200_300_first={
0, 1000, 2000,3000,4000,5000,6000,7000,7500,1800,3968,0,0,0,0,//11
100,100,100,100,100,0,0,0,0,0,0,0,0,0,//10
6,//1
};

  
//pt----------------------------------------------------------
const StructCurve pt_f20_120_first={
200, 704, 1088,1466,1839,2207,2400,2600,2800,3000,3200,3400,3600,3800,3900,//11
10,10,10,10,10,10,10,10,10,10,10,10,10,10,//10
15,//1
};


const StructCurve pt_f40_120_first={
200, 704, 1088,1466,1839,2207,2400,2600,2800,3000,3200,3400,3600,3800,3900,//11
20,20,10,10,10,10,10,10,10,10,10,10,10,10,//10
15,//1
};

//(-40,70)
const StructCurve pt_f40_70_first={
200, 704, 1088,1466,1839,2207,2400,2600,2800,3000,3200,3400,3600,3800,3900,//11
10,10,10,10,10,10,10,10,10,10,10,10,10,10,//10
12,//1
};

//(-40,100)
const StructCurve pt_f40_100_first={
200, 704, 1088,1466,1839,2207,2400,2600,2800,3000,3200,3400,3600,3800,3900,//11
10,10,10,10,10,10,10,10,10,10,10,10,10,10,//10
15,//1
};
//(-50,100)
const StructCurve pt_f50_100_first={
200, 704, 1088,1466,1839,2207,2400,2600,2800,3000,3200,3400,3600,3800,3900,//11
10,10,10,10,10,10,10,10,10,10,10,10,10,20,//10
15,//1
};

//(-40,250)
const StructCurve pt_f40_250_first={
200, 704, 1088,1466,1839,2207,2400,2600,2800,3000,3200,3400,3600,3800,3900,//11
20,20,30,30,30,30,30,30,30,40,10,10,10,10,//10
11,//1
};
//(-50,150)
const StructCurve pt_f50_150_first={
200, 704, 1088,1466,1839,2207,2400,2600,2800,3000,3200,3400,3600,3800,3900,//11
30,20,30,30,30,30,30,10,10,10,10,10,10,20,//10
8,//1
};
//(-50,200)
const StructCurve pt_f50_200_first={
200, 704, 1088,1466,1839,2207,2400,2600,2800,3000,3200,3400,3600,3800,3900,//11
30,20,30,30,30,30,30,30,20,40,10,10,10,10,//10
10,//1
};
//(-50,250)
const StructCurve pt_f50_250_first={
200, 704, 1088,1466,1839,2207,2400,2600,2800,3000,3200,3400,3600,3800,3900,//11
30,20,30,30,30,30,30,30,30,40,10,10,10,10,//10
11,//1
};
//(-50,300)
const StructCurve pt_f50_300_first={
200, 704, 1088,1466,1839,2207,2400,2600,2800,3000,3200,3400,3600,3800,3900,//11
30,20,30,30,30,30,30,30,30,30,30,30,10,10,//10
13,//1
};
//(0,60)
const StructCurve pt_0_60_first={
0, 685, 1360,2030,2692,3349,3398,0,0,0,0,0,0,0,0,//11
10,10,10,10,10,10,10,10,10,10,0,0,0,0,//10
7,//1
};

//(0,300)
const StructCurve pt_0_300_first={
315, 704, 1088,1466,1839,2207,2570,2927,3279,3626,3968,0,0,0,0,//11
30,30,30,30,30,30,30,30,30,30,0,0,0,0,//10
11,//1
};
//(0,200)
const StructCurve pt_0_200_first={
315, 704, 1088,1466,1839,2207,2570,2927,3279,3626,3968,0,0,0,0,//11
20,20,20,20,20,20,20,20,20,20,0,0,0,0,//10
11,//1
};

//(-100,200)
const StructCurve pt_f100_200_first={
300, 535, 990,1424,1843,2250,2640,3018,3379,3731,4071,0,0,0,0,//11
30,30,40,20,30,30,30,30,30,30,0,0,0,0,//10
11,//1
};

//(-40,150)
const StructCurve pt_f40_150_first={
300, 535, 990,1424,1843,2250,2640,3018,3379,3731,4071,0,0,0,0,//11
20,20,30,30,30,30,30,30,30,30,0,0,0,0,//10
8,//1
};


//(-100,300)
const StructCurve pt_f100_300_first={
300, 535, 990,1424,1843,2250,2640,3018,3379,3731,4071,0,0,0,0,//11
30,30,40,40,40,40,40,40,40,60,0,0,0,0,//10
11,//1
};


//(-100,100)
const StructCurve pt_f100_100_first={
300, 535, 990,1424,1843,2250,2640,3018,3379,3731,4071,0,0,0,0,//11
20,20,20,20,20,20,20,20,20,20,0,0,0,0,//10
11,//1
};

//(-150,150)
const StructCurve pt_f150_150_first={
300, 535, 990,1424,1843,2250,2640,3018,3379,3731,4071,0,0,0,0,//11
30,30,30,30,30,30,30,30,30,30,0,0,0,0,//10
11,//1
};
//(-200,200)
const StructCurve pt_f200_200_first={
300, 535, 990,1424,1843,2250,2640,3018,3379,3731,4071,0,0,0,0,//11
40,40,40,40,40,40,40,40,40,40,0,0,0,0,//10
11,//1
};
//(-200,100)
const StructCurve pt_f200_100_first={
300, 535, 990,1424,1843,2250,2640,3018,3379,3731,4071,0,0,0,0,//11
30,30,30,30,30,30,20,30,30,40,0,0,0,0,//10
11,//1
};
//(-50,350)
const StructCurve pt_f50_350_first={
356, 696, 895,1157,1412,1662,1909,2150,2386,2618,2844,0,0,0,0,//11
50,30,40,40,40,40,40,40,40,40,0,0,0,0,//10
11,//1
};

//(-10,60)   (4-20mA)
const StructCurve an_f10_60_first={
786,1235,1684,2133,2583,3033,3483,3932,3303,3618,3932,0,0,0,0,
10,10,10,10,10,10,10,8,8,8,0,0,0,0,
8,//1
};


//(0,100)   (4-20mA)
const StructCurve an_0_100_first={
786,1101,1416,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
10,10,10,10,10,10,10,10,10,10,0,0,0,0,
11,//1
};

//(0,200)   (4-20mA)
const StructCurve an_0_200_first={
786,1101,1416,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
20,20,20,20,20,20,20,20,20,20,0,0,0,0,
11,//1
};


//(0,80)   (4-20mA)
const StructCurve an_0_80_first={
786,1101,1416,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
8,8,8,8,8,8,8,8,8,8,0,0,0,0,
11,//1
};

//(0,800)   (4-20mA)
const StructCurve an_0_800_first={
786,1180,1572,1965,2359,2752,3145,3538,3932,0,0,0,0,0,0,
100,100,100,100,100,100,100,100,80,80,0,0,0,0,
9,//1
};

//(0,500)   (4-20mA)
const StructCurve an_0_500_first={
786,1101,1416,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
50,50,50,50,50,50,50,50,50,50,0,0,0,0,
11,//1
};

//(0,400)   (4-20mA)
const StructCurve an_0_400_first={
786,1180,1572,1965,2359,2752,3145,3538,3932,0,0,0,0,0,0,
50,50,50,50,50,50,50,50,80,80,0,0,0,0,
9,//1
};


//湿度--------------------------------------------------------------------------
//湿度（0，100）%RH  HIH5030
const StructCurve digit_0_100_first={
0,230,430,630,830,1030,0,0,0,0,0,0,0,0,0,
20,20,20,20,20,0,0,0,0,0,0,0,0,0,
6,//1
};

//(0,100)数字 湿度  HIH6130
const StructCurve sz_0_100_first={
0,200,400,600,800,1000,550,600,700,800,900,1000,1100,1200,1400,
20,20,20,20,20,5,5,10,10,10,10,10,10,20,
6,//1
};


//rotronic (0,100)(0,1v)
const StructCurve rotronic_0_100_first={
2,164,328,492,656,820,984,1148,1312,1476,1640,0,0,0,0,
10,10,10,10,10,10,10,10,10,10,0,0,0,0,
11,//1
};


//土壤水分----------------------------------------------------------------------
//(0,100)%
const StructCurve trsf_0_100_first={//0-100
100,3100,3150,3000,3200,4000,2472,2709,2872,3016,3144,3400,4051,0,0,//11
50,50,50,20,20,5,5,5,5,5,5,50,0,0,//10
3,
};

//o2----------------------------------------------------------------------------
//(0,30)%
const StructCurve o2_0_30_first={
0, 2740, 3915,0,0,0,0,0,0,0,0,0,0,0,0,
21,9,0,0,0,0,0,0,0,0,0,0,0,0,
3,
};

//co2---------------------------------------------------------------------------
//(0,100)%
const StructCurve co2_0_100_first={//4-20mA  0-100%
775, 1548, 2319,3093,3867,0,0,0,0,0,0,0,0,0,0,
25,25,25,25,0,0,0,0,0,0,0,0,0,0,
5,
};
//(0,5)5% 2位小数
const StructCurve digit_0_5_first={//0-5.00
0,100,200,300,400,500,0,0,0,0,0,0,0,0,0,//5.00
1,1,1,1,1,0,0,0,0,0,0,0,0,0,//10
6,
};
//(0,5)5% 2位小数
const StructCurve co2_04_20_first={//0-5.00  (0.4-2.0v/2.5)
656,3277,200,300,400,500,0,0,0,0,0,0,0,0,0,//5.00
10,1,1,1,1,0,0,0,0,0,0,0,0,0,//10
2,
};


//(0,10)%   COZIR_W_10V
const StructCurve co2_cozir_w10v_first={//0-3.3v  0-10%
10,2048, 4090, 0,0,0,0,0,0,0,0,0,0,0,0,
5,5,0,0,0,0,0,0,0,0,0,0,0,0,
3,
};


//(0,10.00)% , TTL  
const StructCurve co2_TTL_10BF_first={
0,200, 400, 600,800,1000,0,0,0,0,0,0,0,0,0,
2,2,2,2,2,0,0,0,0,0,0,0,0,0,
6,
};

//(0,20.00)% , TTL  
const StructCurve co2_TTL_20BF_first={
0,500, 1000, 1500,2000,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,0,0,0,0,0,0,0,0,0,0,
5,
};

//(0,500)10ppm
const StructCurve digit_0_500_first={//0-500
0,500,1000,1500,2000,2500,3000,3500,4000,4500,5000,0,0,0,0,//500.0
50,50,50,50,50,50,50,50,50,50,0,0,0,0,//10
11,
};
//(0,500)10ppm  0.4-2v
const StructCurve co2_z14_500_first={//0-500
656,1966,3277,1500,2000,2500,3000,3500,4000,4500,5000,0,0,0,0,//500.0
250,250,50,50,50,50,50,50,50,50,0,0,0,0,//10
3,
};

//(0,200)10ppm  0.4-4v  接10K-10K 分压后 得 0.2-2v
const StructCurve co2_mk400_200_first={//0-500
328,3277,3277,1500,2000,2500,3000,3500,4000,4500,5000,0,0,0,0,//500.0
200,100,50,50,50,50,50,50,50,50,0,0,0,0,//10
2,
};


//(0,500)10ppm  0-3V    
const StructCurve co2_MISIR_500_first={//0-500
0,349,1965,3670,2000,2500,3000,3500,4000,4500,5000,0,0,0,0,//500.0
40,210,250,50,50,50,50,50,50,50,0,0,0,0,//10
4,
};

//(0,200)10ppm
const StructCurve digit_0_200_first={//0-200
0,200,400,600,800,1000,1200,1400,1600,1800,2000,0,0,0,0,//200.0
20,20,20,20,20,20,20,20,20,20,0,0,0,0,//10
11,
};
//(0,300)10ppm
const StructCurve digit_0_300_first={//0-300
0,300,600,900,1200,1500,1800,2100,2400,2700,3000,0,0,0,0,//300.0
30,30,30,30,30,30,30,30,30,30,0,0,0,0,//10
11,//1
};

//(0,1000)10ppm 数字曲线  10000ppm
const StructCurve digit_sz_0_1000_first={
0,2000,4000,6000,8000,10000,0,0,0,0,0,0,0,0,0,
200,200,200,200,200,10,10,10,10,10,0,0,0,0,
6,//1
};

//(0,500)10ppm 数字曲线
const StructCurve digit_sz_0_500_first={
0,1000,2000,3000,4000,5000,0,0,0,0,0,0,0,0,0,
100,100,100,100,100,10,10,10,10,10,0,0,0,0,
6,//1
};

//(0,1000) 数字曲线   K值400
const StructCurve digit_sz_pm25_0_1000_first={
0,250,500,750,1000,1250,1500,1750,2000,2250,2500,0,0,0,0,
100,100,100,100,100,100,100,100,100,100,0,0,0,0,
11,//1
};


//电压----------------------------------------------------------------------------
//(0,500)10mv
const StructCurve v_0_500_first={
789,1577,2366,3155,3945,0,0,0,0,0,0,0,0,0,0,//11
125,125,125,125,0,0,0,0,0,0,0,0,0,0,//10
5,//1
};

//电压
//(0,150)v   4-20mA
const StructCurve v420_0_150_first={
786,1101,1416,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
15,15,15,15,15,15,15,15,15,15,0,0,0,0,
11,//1
};


//电流
//(0,10)A   4-20mA
const StructCurve a_0_10_first={
786,1101,1416,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
1,1,1,1,1,1,1,1,1,1,0,0,0,0,
11,//1
};

//深度--------------------------------------------------------------------------
//(0,200)10mm
const StructCurve sdu_0_200_first={
789,1577,2366,3155,3945,0,0,0,0,0,0,0,0,0,0,//11
50,50,50,50,0,0,0,0,0,0,0,0,0,0,//10
5,//1
};

//水位----------------------------------------------------------------------------
//(0,50)m   (4-20mA)
const StructCurve sw_0_50_first={
786,1101,1416,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,0,0,0,0,
11,//1
};

//(0,500)mm  10mm   (4-20mA)
const StructCurve sw_0_500_first={
786,1101,1416,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
50,50,50,50,50,50,50,50,50,50,0,0,0,0,
11,//1
};

//(0,200)mm  10mm   (4-20mA)
const StructCurve sw_0_200_first={
786,1101,1416,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
20,20,20,20,20,20,20,20,20,20,0,0,0,0,
11,//1
};

//(0,1000)mm   (4-20mA)
const StructCurve sw_0_1000_first={
786,1101,1416,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
100,100,100,100,100,100,100,100,100,100,0,0,0,0,
11,//1
};

//(0,3000)mm   (4-20mA)
const StructCurve sw_0_3000_first={
786,1048,1310,1572,1834,2096,2358,2620,2882,3144,3406,3668,3932,0,0,
250,250,250,250,250,250,250,250,250,250,250,250,0,0,
13,//1
};
//(0,2000)mm   (4-20mA)
const StructCurve sw_0_2000_first={
786,1101,1416,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
200,200,200,200,200,200,200,200,200,200,0,0,0,0,
11,//1
};


//(0.30)m 4-20mA
const StructCurve sw_0_30_first={
786,1101,1416,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,0,0,0,0,
11,//1
};


//(0,400)10umol  (4-20mA)
const StructCurve ghyxfs_0_400_first={
786,1101,1416,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
40,40,40,40,40,40,40,40,40,40,0,0,0,0,
11,//1
};


//x10w/m2
const StructCurve ssfs_sz0_200_first={
0,20,40,60,80,100,120,140,160,180,200,0,0,0,0,
200,200,200,200,200,200,200,200,200,200,0,0,0,0,
11,//1
};


//压强-----------------------------------------------------------------------------
//(0,160)10kpa  4-20mA
const StructCurve yq_0_160_first={
786,1101,1416,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
16,16,16,16,16,16,16,16,16,16,0,0,0,0,
11,//1
};
//(0,400)10kpa
const StructCurve yq_0_400_first={
775, 1548, 2319,3093,3867,0,0,0,0,0,0,0,0,0,0,
100,100,100,100,0,0,0,0,0,0,0,0,0,0,
5,//1
};
//(-100,100) 4-20mA
const StructCurve yq_F100_100_first={
786,1101,1416,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
20,20,20,20,20,20,20,20,20,20,0,0,0,0,
11,//1
};


//气压--------------------------------------------------------------------------

//(30,120)kpa  2位小数
const StructCurve digit_qy_30_120_first={
3000,4000,5000,6000,7000,8000,9000,10000,11000,12000,0,0,0,0,0,//100.00
10,10,10,10,10,10,10,10,10,10,10,10,0,0,//10
10,//1
};

//(30-120)kpa  1位小数
const StructCurve digit_qy_1bit_30_120_first={
300,400,500,600,700,800,900,1000,1100,1200,0,0,0,0,0,//100.00
10,10,10,10,10,10,10,10,10,10,10,10,0,0,//10
10,//1
};

//风速--------------------------------------------------------------------------
const StructCurve fs_0_60_first={
0,287,1360,2770,4100,5500,6900,8200,9700,11000,12400,13800,16200,16600,0,//15
1,4,5,5,5,5,5,5,5,5,5,5,5,0,
14,//1
};

//(0.0-1000.0)lx
const StructCurve digit_gz_0_1000lx_first={
0,1000,2000,3000,4000,5000,6000,7000,8000,9000,10000,0,0,0,0,
100,100,100,100,100,100,100,100,100,100,0,0,0,0,
11,//1
};
//(0.0-100.0)lx
const StructCurve digit_gz_0_100lx_first={
0,100,200,300,400,500,600,700,800,900,1000,0,0,0,0,
10,10,10,10,10,10,10,10,10,10,0,0,0,0,
11,//1
};
//2位小数------------------------------------------------------------------
//照度-----------------------------------------------------------------
//(0.00,65.00)klx
const StructCurve digit_gz_0_65k_first={
0,1000,2000,3000,4000,5000,6000,6500,0,0,0,0,0,0,0,//65.00
10,10,10,10,10,10,5,0,0,0,0,0,0,0,
8,//1
};
//(0.00,100.00)klx
const StructCurve digit_gz_0_100k_first={
0,1000,2000,3000,4000,5000,6000,7000,8000,9000,10000,0,0,0,0,//100.00
10,10,10,10,10,10,10,10,10,10,0,0,0,0,//10
11,//1
};
//(0.00,200.00)klx  数字量曲线
const StructCurve digit_gz_0_200k_first={
0,2000,4000,6000,8000,10000,12000,14000,16000,18000,20000,0,0,0,0,//200.00
20,20,20,20,20,20,20,20,20,20,0,0,0,0,//10
11,
};
//(0.00,200.00)klx   模拟量信号曲线
const StructCurve digit_gzv_0_200k_first={
30,328,655,983,1311,1639,1966,2294,2622,2949,3277,0,0,0,0,//200.00
20,20,20,20,20,20,20,20,20,20,0,0,0,0,//10
11,
};
//PH----------------------------------------------------------------------------------
//(0.00,14.00)ph
const StructCurve ph_0_14_first={
774,1658,3940,0,0,0,0,0,0,0,0,0,0,0,0,
4,10,0,0,0,0,0,0,0,0,0,0,0,0,
3,//1
};
//紫外辐射
const StructCurve zwfs_0_10_first={
0,1638,0,0,0,0,0,0,0,0,0,0,0,0,0,
10,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,//1
};

//醋液检测 通道电阻10K-滤波电阻10K-AD
const StructCurve cf_0_100_first={
5,2045,4080,300,400,500,600,700,800,900,1000,0,0,0,0,//11
50,50,10,10,10,10,10,10,10,10,0,0,0,0,//10
3,//1
};

//VOC (0-100) 4-20 mA
const StructCurve voc_0_100_first={
655,3277,1416,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
100,10,10,10,10,10,10,10,10,10,0,0,0,0,
2,//1
};

//PM (0-500) 4-20 mA
const StructCurve pm_500_first={
786,1101,1416,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
50,50,50,50,50,50,50,50,50,50,0,0,0,0,
11,//1
};

//PM (0-1000) PWM 数字
const StructCurve pm_pwm_1000_first={
0,100,200,300,400,500,600,700,800,900,1000,0,0,0,0,
100,100,100,100,100,100,100,100,100,100,0,0,0,0,
11,//1
};

//甲醛 2bit  (0,373)mg/m3 数字曲线
const StructCurve digit_sz_0_373_first={
0,100,200,300,400,5000,0,0,0,0,0,0,0,0,0,
1,1,1,1,0,0,0,0,0,0,0,0,0,0,
5,//1
};

//CH2O 2bit (0,3.73mg/m3)  0.4-2V   曲线没有小数，故取到4 -> 2.116v
const StructCurve ch2o_v_0_373_first={
655,3467,200,300,400,5000,0,0,0,0,0,0,0,0,0,
4,1,1,1,0,0,0,0,0,0,0,0,0,0,
2,//1
};


//MH-440D  实测 大气中显示0.26%
//CH4  0-5.00%    0.4~2V  基准2.5
/*
const StructCurve CH4_v_0_5_first={
655,1180,1705,2230,2755,3277,0,0,0,0,0,0,0,0,0,
1,1,1,1,1,0,0,0,0,0,0,0,0,0,
6,//1
};
*/

const StructCurve CH4_v_0_5_first={
700,1180,1705,2230,2755,3277,0,0,0,0,0,0,0,0,0,
1,1,1,1,1,0,0,0,0,0,0,0,0,0,
6,//1
};


//NH3  0-50ppm   0.6~3v  基准3.3
const StructCurve NH3_v_0_50_first={
745,1341,1937,2533,3128,3724,0,0,0,0,0,0,0,0,0,
10,10,10,10,10,0,0,0,0,0,0,0,0,0,
6,//1
};

//H2S  0-50ppm   0.6~3v  基准3.3
const StructCurve H2S_v_0_50_first={
745,1341,1937,2533,3128,3724,0,0,0,0,0,0,0,0,0,
10,10,10,10,10,0,0,0,0,0,0,0,0,0,
6,//1
};


//太阳辐射 (0-200)  x10 W/m2  DC5V 4-20mA
const StructCurve tyfs_200_first={
786,1101,1416,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
20,20,20,20,20,20,20,20,20,20,0,0,0,0,
11,//1
};

//蒸发(0-240) mm  DC5V 0-2V
const StructCurve zf_240_first={
0,1638,3277,1730,2045,2359,2674,2988,3303,3618,3932,0,0,0,0,
120,120,0,0,0,0,0,0,0,0,0,0,0,0,
3,//1
};


//流速 2位小数
const StructCurve LS_F1_5_first={
0,100,200,300,400,500,600,0,0,0,0,0,0,0,0,
1,1,1,1,1,1,0,0,0,0,0,0,0,0,
7,//1
};

//水深  2位小数
const StructCurve SS_0_10_first={
0,200,400,600,800,1000,600,0,0,0,0,0,0,0,0,
2,2,2,2,2,0,0,0,0,0,0,0,0,0,
6,//1
};


//===============================================================================

void LoggerLoop(void)
{
  if(Flag.Loop==1)
  {
    Flag.Loop=0;
    
    TimeDecDeel();//计数类，倒计时
    
    #if RF_REC_EN==1

       #if RF_U1_EN==0//不能是GPRS-RF
           #if U0U1_ENABLE==1
           if(Flag.U0U1ing==1)
           {
             LcdOFFX(OFF_RF_U0U1);
             return;
           }
           #endif
       #endif
    
        KeyXzAcc();
        
        #if RF_MULTI_EN==1//RF多机
       
            if(KeySetIsBusy()==0)//设置地址时不进入
            {
                if(Pt.RpOff==0)//开启时
                {
                  RfTimeoutDeel();//接收缓冲超时检测 ，超时后NULL
                }
            }
        
        #else//RF单机
            RfTimeoutDeel();//接收缓冲超时检测 ，超时后NULL
          
            #if RF_U1_EN==1
            if(Pt.U1toPC==0)//U1在RF状态
            {
              #if RECORD_ENABLE==1 //记录仪
                  LoggerRfRec();
                
              #else//GPRS变送器
                  
                  #if GPRS_6OFF==1
                  if(Sms.GsmKeyShut==0)
                  #endif  
                  {
                    RfDataToChDeel();//接收缓冲到通道缓冲
                    RfLcdChDeel();//通道数据轮显
                    LoggerAlarmAllSeek();//通道数据超标检测
                    LoggerAlarmDeel();//通道数据报警检测
                    LoggerSample();//这里有电池电压检测
                  }


              #endif
              
  
            }
              
            #else//RF_U1_EN==1
            
              #if RECORD_ENABLE==1
                LoggerRfRec();//记录仪
               
              #else//变送器模式
                if(KeySetIsBusy()==0)
                {
                  RfDataToChDeel();//接收缓冲到通道缓冲
                  RfLcdChDeel();//通道数据轮显
                  LoggerAlarmAllSeek();//通道数据超标检测
                  LoggerAlarmDeel();//通道数据报警检测
                  LoggerSample();//这里有电池电压检测
                }
              #endif

            #endif

        #endif
    #elif RF_RP_EN==1
        KeyXzAcc();        
        if(Pt.RpOff==0)//中继器功能开启时
        {
           Rf_N_Rp_deel();
        }
        //return;//zz
        
    #else//记录仪、变送器
        
        #if SEN_U1_EN==1
        if(Pt.U1toPC==0)//U1在传感器状态
        {
            LoggerWorkDeel();//采样记录处理
            PowPtDeel();//传感电源延时
        }
          
        #else
        LoggerWorkDeel();//采样记录处理
        PowPtDeel();//传感电源延时 
        #endif
    #endif
        

    #if LED_WORK_ENABLE==0
      #if RF_MULTI_EN==1
        //LcdRtcTime();//时钟显示
      #elif RF_RP_EN==1
      #else
        LcdRtcTime();//时钟显示
        LcdExtreDeel();//极值显示
        DisplayToLow();//关屏切换
      #endif
    #endif


    #if BSQ_ENABLE==1//变送器
          #if KEY_SET_ENABLE==1
            Loop1sDeel();
          #endif
            
          #if PCBSQ_RECORD_EN==1//变送器或GPRS记录缓冲区
            #if RF_MULTI_EN==1
              if(Pt.RpOff==0)//关机时不记录
              {
                 if(StateB.Address==1)//H1才有
                 {
                     PCBSQ_Record();//zz
                 }
              }
            #elif RF_RP_EN==1
            
            #else
              PCBSQ_Record();
            #endif
          #endif
            

          
          #if GPRS_ENABLE==1  
            if(Pt.GprsSleep==1)//省电模式
            {
                #if RTC_UTC_EN==1
                 if((Pt.GprsRstErrPt==0)&&(Sms.GsmKeyShut==0)&&(Sms.GsmOff==1)&&((Pt.GprsDueOut>0)||(Pt.GprsPowDueOut>0)||(Pt.UtcEn==1)||(Pt.SmsDueOut>0)||(Sms.PowDueOut>0)||(Sms.AlarmDueOut>0)))//模块关闭并且有数据发送时，开启模块
                #else
                  
                    
                    #if GPRS_UP_TIME_EN==1//zz
                    if((Pt.GprsRstErrPt==0)&&(Sms.GsmKeyShut==0)&&(Sms.GsmOff==1)\
                      &&((Pt.Gprsing==1)||(Pt.GprsDueOut>0)||(Pt.GprsPowDueOut>0)||(Pt.SmsDueOut>0)||(Sms.PowDueOut>0)||(Sms.AlarmDueOut>0)))//模块关闭并且有数据发送时，开启模块
                    #else
                     if((Pt.GprsRstErrPt==0)&&(Sms.GsmKeyShut==0)&&(Sms.GsmOff==1)&&((Pt.GprsDueOut>0)||(Pt.GprsPowDueOut>0)||(Pt.SmsDueOut>0)||(Sms.PowDueOut>0)||(Sms.AlarmDueOut>0)))//模块关闭并且有数据发送时，开启模块
                    #endif
                       
                #endif
                {
                
                     #if GPRS_UP_TIME_EN==1
                     if((Pt.Gprsing==1)||(Sms.AlarmDueOut>0))//上传时间到或报警短信时，才退出省电模式
                     #endif
                     { 
                           #if L206_SLP_EN==1
                           GsmWakeUp();
                           #else
                           GsmToPowOn();
                           #endif
                     }
                }
            }
           #endif
        
    #else//记录仪
      StateASaveDeel();//间隔时间存储参数计时
    #endif
      
    KeyTimeDe();//手动启动延时处理  
      
    
    #if LED_WORK_ENABLE==1
      LedDeel();
    #endif
    
    #if GSM_ENABLE==1
      GsmLoop();
    #endif
    
    #if ALARM_POINT_ENABLE==1
      AlarmPointDeel();
    #endif

    #if RY_GSM_ENABLE==1//短信继电器控制灯
      RyGsmDeel();
    #endif

    #if WIFI_ENABLE==1
      WifiLinkDeel();
    #endif
      
    //开关门检测  
    #if ((DOOR1_BJ_EN==1)||(DOOR2_BJ_EN==1))
      DoorDeel();
    #endif
      
    #if ((LCD_NO==20)&&(G_20_ENTER_EN==0))
      if(Pt.BGpt>0)
      {
        Pt.BGpt--;
        BG_LED_ON;
      }
      else
      {
        BG_LED_OFF;
      }

    #endif
      
      
    #if PRINT_FZ_EN==1
    Print_BG_Deel();
    #endif
    
    
    #if L_SYN_RTC_EN==1
    LogSynRtcDeel();
    #endif
      
      
    #if SEN_MODBUS_485_EN==1
    
      if(StateA2.WorkState==WORK_STATE_RECORDING)
      {
          if(StateC.PcLinkPt==0)
          {
              //每2秒发送一次读取指令
              if(++StateC.senct>1)
              {
                 StateC.senct=0;
                 
                 ComSendH();
                 
                 
                 #if (JLY_MODEL==_2_LS_SS)
                   StateC.sen_2=0;//始终读地址1
                 #elif (JLY_MODEL==_4_2LS_2SS)
                 #endif
                 
                 
                 if(StateC.sen_2==0)
                 {
                     StateC.sen_2=1;
                     
                     U1SendByte(0x01);
                     U1SendByte(0x03);
                     U1SendByte(0x00);
                     U1SendByte(0x00);
                     U1SendByte(0x00);
                     U1SendByte(0x0E);//读14个寄存器
                     U1SendByte(0xC4);//CRC16
                     U1SendByte(0x0E);
                 }
                 else
                 {
                     StateC.sen_2=0;
                     
                     U1SendByte(0x02);
                     U1SendByte(0x03);
                     U1SendByte(0x00);
                     U1SendByte(0x00);
                     U1SendByte(0x00);
                     U1SendByte(0x0E);//读14个寄存器
                     U1SendByte(0xC4);//CRC16
                     U1SendByte(0x3D);
                 }
                 
                 
                 ComSendL();
                 
  
              }
          }
      }
      
    #endif
      
    
    #if L_REALOUT_PRINT_EN==1
      
      if(StateA2.WorkState==WORK_STATE_RECORDING)
      {
          if((StateC.PcLinkPt==0)&&(StateC.sending==0))
          {
              //每2秒发送一次读取指令
              if(++StateC.senct>9)
              {
                 StateC.senct=0;
                 
                 ComSendH();
                 
                 U1SendByte(0xFF);//1
                 U1SendByte(0x00);//2-5
                 U1SendByte(0x00);
                 U1SendByte(0x00);
                 U1SendByte(0x00);
   
                  //通道数据  6-21
                  u16 j;
                  for(j=0;j<CH_NUM;j++)
                  {
                    if((StateC.Value[j]==SENIOR_NULL)||(StateC.Value[j]==HAND_STOP))
                    {
                      U1SendByte(0xff&(StateC.Value[j]>>8));
                      U1SendByte(0xff&StateC.Value[j]);
                    }
                    else
                    {
                        if(0x01&(StateC.FuhaoBit>>j))//负数
                        {
                          U1SendByte(0x80|(0xff&(StateC.Value[j]>>8)));
                        }
                        else
                        {
                          U1SendByte(0xff&(StateC.Value[j]>>8));
                        }
                        U1SendByte(0xff&StateC.Value[j]);
                    }
                  }
                  
                  for(j=0;j<128;j++)
                  {
                    U1SendByte(0x00);
                  }
                  
                  U1SendByte(0x0D);
                   
                   
                  ComSendL();
                 
  
              }
          }
      }
    
    #endif

    #if JD_LED_EN==1  
    JDledDeel();
    #endif  
    
    
    #if RF_KP_EN==1
    RfKp1Sec();
    #endif
    
    
    #if DAC_EN==1
    DacOutDeel();
    #endif

    
  }
}

//计数类,倒计时
void TimeDecDeel(void)
{
    #if ((RECORD_ENABLE==1)||(GPRS_TC_EN==1)||(BSQ_REC_AA_EN==1))
    DownTimeOver();//下载超时处理
    #endif
    
    #if ((GPS_MOUSE_EN==1))
    GpsTimeOutDeel();
    #endif
    
    #if ((LBS_LAC_EN==1)||(LBS_JWD_EN==1))//zz
    if(StateC.LBSpt>0)
    {
      StateC.LBSpt--;
      if(StateC.LBSpt==0)
      {
        //超时，LBS清0
        #if LBS_LAC_EN==1
          Sms.LAC=0;
          Sms.CID=0;
        #endif
          
        #if LBS_JWD_EN==1
          
         StateC.LBS_JdInt=0;
         StateC.LBS_JdDec=0;
         StateC.LBS_WdInt=0;
         StateC.LBS_WdDec=0;
          
          

        #endif
        
      }
    }
    #endif
    
    #if (GSM_ENABLE==1)
    if(Sms.IntervalPt>0)//短信报警间隔
      Sms.IntervalPt--;
    
    
                     #if ALARM_KEY_CONTINUE_EN==1
                     if(Sms.IntervalPt==SMS_INTERVAL_TIME-10)//短信报警开始后10秒置1，蜂鸣器不响
                       Pt.AlarmKC=1;//必须等按键消除
                     #endif
    
    #endif
    
    #if ((PRINT_REAL_EN==1)||(PRINT_RT_LIST_EN==1)||(SEN_MODBUS_485_EN==1)||(L_REALOUT_PRINT_EN==1)||(CMD_CTRL_EN==1))
    if(StateC.PcLinkPt>0)
      StateC.PcLinkPt--;
    #endif
    
    #if GPS_MOUSE_EN==1
    if(StateC.GpsRecWait>0)
    {
       StateC.GpsRecWait--;
       
       UC1IE &=~ UCA1RXIE;//U1中断关
    }
    else
    {
       UC1IE |= UCA1RXIE;
    }
    #endif
    
    #if SIM68_EN==1
    
    if(StateC.GpsBcWait>0)
      StateC.GpsBcWait--;
    
        #if SIM68_SLP_EN==1
        if(StateC.AwakeWait>0)
        {
                if(--StateC.AwakeWait==0)
                {
                  StateC.AwakeWait=60;//确保始终可以唤醒,当唤醒后，这个时间自动变为发送间隔时间，若始终无法唤醒，则一直40
                  
                  if(Pt.U1toPC==0)
                  {
                     SIM68_to_wake();
                  }
                }
        }
        #endif

    #endif

    
    #if LCD_X_ENABLE==1
    if(Pt.LcdxPt>0)
      Pt.LcdxPt--;
    #endif
    
    #if ((ALARM_TIME_ENABLE==1)||(ALARM_BELL_TIME_EN==1))
      AlarmTimeDeel();
    #endif
      
      
    #if ((RF_U1_EN==1)&&(RF_REC_EN==1))
    if(Pt.PCpt>0)
    {
      if(--Pt.PCpt==0)
      {
        U1_TO_PC;//打印前，先把U1切换到PC

        
        #if RF_PP_115200_EN==1
        RfU_Init(9600,1);
        #endif
        
      }
    }
    #endif
    
    
    #if ((RF_REC_EN==1)||(RF_RP_EN==1))
    if(Pt.KeyApt>0)
    {
      Pt.KeyApt--;
      if(Pt.KeyApt==0)
      {
          if(((KEY_PIN&KEY_3_BIT)==0)&&((KEY_PIN&KEY_4_BIT)))//第一键按住，第二键已经放掉
          {
                //进入设置频率状态
                #if ((RF_REC_EN==1)||(RF_RP_EN==1)||(RF_TXRX_470M_EN==1))
                    
                    #if RECORD_ENABLE==1
                        //记录仪，开始设置频率, 工作状态、不包括记录仪假停状态
                        if(StateA2.WorkState==WORK_STATE_RECORDING)
                        {
                            if(!((StateB.StartMode==START_MODE_HAND)&&(StateB.StopMode==STOP_MODE_HAND)&&(Flag.HandOff==1)))
                            {
                              Pt.Foo=0;
                              Pt.Xz=1;
                              LcdNN(Pt.Xz);
                              
                              TBCCR1+=TB1_DELAY;
                              
                            }
                        }
                    #else
                       Pt.Foo=0;
                       Pt.Xz=1;
                       LcdNN(Pt.Xz); 
                       
                       TBCCR1+=TB1_DELAY;
    
                    #endif
                       
                #endif
           }
      }
    }
    #endif
    
    
    #if ERR_RST_EN==1
        #if ((RECORD_ENABLE==0)&&(RF_REC_EN==0))  //变送器 GPRS等,要排除GW,FW等接收机
        if(StateA2.WorkState==WORK_STATE_RECORDING)//工作状态  zz
        {
            if(Download.Downloading==0)
            {
              if(++Pt.RealDog>REAL_DOG_TIME)
              {
                  Pt.RealDog=0;
                  WDTCTL=0;
              }
            }
        
        }
        #endif
    #endif
    
    
    
    #if WIRELESS_ENABLE==1
    if(StateA2.WorkState==WORK_STATE_RECORDING)//工作状态  zz
    {
          if(++Pt.Wdog>W_DOG_TIME)//异常时间到(超时未进入通讯状态)，模块重新上电
          {
              Pt.Wdog=0;
              
              WIRSLESS_POW_OFF;
              delay_ms(400);
              WDT_CLR;
              delay_ms(400);
              WDT_CLR;
              WirelessPowOn();

          }
    
    }
    #endif
}
    

#if (GPS_MOUSE_EN==1)
void GpsTimeOutDeel(void)
{
    //GPS掉线检测
    if(StateC.GpsOutPt>0)
    {
       if(--StateC.GpsOutPt==0)
       {
          StateC.LongiInt=0;//超时后，判断数据是空的
          StateC.LongiDec=0;
          StateC.LatiInt=0;
          StateC.LatiDec=0;
          
          StateC.SatelliteN=0;
       }
       else
       {
         #if ((SIM68_EN==1)&&(SIM68_SLP_EN==1))
         if(Pt.GprsSleep==1)//没有超时，说明有GPS数据
         {
              if((StateC.GpsOutPt%GPS_REC_JG_TIME)==0)//GPS_REC_JG_TIME秒闪一次
              {
                  Tshan();
              }
         }
         #endif

       }
         
    }
    
    #if GPS_STATIC_EN==1
    //GPS静态漂移判断
    if(StateC.StaticPt>0)
    {
        StateC.StaticPt--;
    }
    #endif
    
    
}
#endif

void LoggerWorkDeel(void)
{
    if(StateA2.WorkState==WORK_STATE_RECORDING)
    {
          Pt.RecordPt++;
          
          #if BSQ_ENABLE==1//变送器没有手动模式
          if(0)
          {
            NOP;
          }
          #else//记录仪
          //手动，假停状态.................................................
          if((StateB.StartMode==START_MODE_HAND)&&(StateB.StopMode==STOP_MODE_HAND)&&(Flag.HandOff==1))
          {
            #if ONLY_JS_ENABLE==1//单独计数
            CLR_YL1_INT;//雨量中断关闭
            for(u8 j=0;j<CH_NUM;j++)
            {
              StateC.Value[j]=HAND_STOP;
            }
            LcdValue();
            #endif
            
            LcdOFFX(OFF_HAND);
            POWER_CTL_ALL_OFF;
            if(Pt.RecordPt>=StateB.RecordTime)
            {
              Pt.RecordPt=0;
              
              for(u8 j=0;j<CH_NUM;j++)
              {
                StateC.Value[j]=HAND_STOP;
              }
              
              #if RECORD_ENABLE==1
              LoggerRecord();
              #endif
            }
          }
          #endif
          else//正常记录状态......................................................
          {
              //单独计数=============================================================
              #if ONLY_JS_ENABLE==1//单独计数
                if(Pt.RecordPt==1)
                {
                  SET_YL1_INT;
                  #if RECORD_ENABLE==1//变送器不在这里清0
                  StateC.Value[0]=Pt.RainPt=0;
                  #endif
  
                  Flag.RstFirstSample=1;//单一雨量时，一直置1
                  LcdValue();
                }
                if(Pt.RecordPt>=StateB.RecordTime)
                {
                   Pt.RecordPt=0;
                   
                   LoggerAlarmAllSeek();
                   #if RECORD_ENABLE==1
                   LoggerRecord();
                   #endif
                }
                
                 #if LCD08_SD_SHIFT_EN==1
                  if(Flag.LCD08_Sd_en==1)
                  {
                    LcdValue();
                  }
                #else
                  #if SD_ENABLE==1//关屏开启时，每秒更新显示雨量数据
                  LcdValue();
                  #endif
                #endif
                
              //非单独计数========================================================
              #else
              
                  #if (JLY_MODEL==_4_WD_GZ100K_SD_YL01)
                  //雨量
                  if(Pt.RecordPt==1)
                  {
                    #if RECORD_ENABLE==1//变送器不在这里清0
                    StateC.Value[3]=Pt.RainPt=0;//第4通道是雨量
                    #endif
                    SET_YL1_INT;
                  }
                  
                  #elif (JLY_MODEL==_2_NTC_01YL)
                  //雨量
                  if(Pt.RecordPt==1)
                  {
                    #if RECORD_ENABLE==1//变送器不在这里清0
                    StateC.Value[1]=Pt.RainPt=0;//第2通道是雨量
                    #endif
                    SET_YL1_INT;
                  }
                  
                  #elif (JLY_MODEL==_3_NTC_HIH5030_01YL)
                  //雨量
                  if(Pt.RecordPt==1)
                  {
                    #if RECORD_ENABLE==1//变送器不在这里清0
                    StateC.Value[2]=Pt.RainPt=0;//第3通道是雨量
                    #endif
                    SET_YL1_INT;
                  }
                  
                  #elif (JLY_MODEL==_7_WD_GZ100K_TRWD_TRSF_SD_YL01_QY)
                  //雨量
                  if(Pt.RecordPt==1)
                  {
                    #if RECORD_ENABLE==1//变送器不在这里清0
                    StateC.Value[5]=Pt.RainPt=0;//第6通道是雨量
                    #endif
                    SET_YL1_INT; 
                  }
                  
                  #elif (JLY_MODEL==_4_WD_SD_FS_FX)
                  //风速
                  if((Pt.RecordPt%2)==1)//2秒计算一次风速
                  {
                    Pt.FsPt=0;
                    FS_INIT_SET;
                  }
                  else
                  {
                    StateC.Adc[2]=Pt.FsPt*100;//频率值
                    AdcToValue(StateC.Adc[2],2);
                    NOP;
                  }
                  
                  
                  #elif ((JLY_MODEL==_6_WD_GZ100K_SD_YL01_FS_FX)||(JLY_MODEL==_6_WD_GZ100K_SD_YL05_FS_FX)\
                    ||(JLY_MODEL==_7_WD_GZ200K_SD_YL01_FS_FX_TRWD)||(JLY_MODEL==_8_WD_GZ200K_SD_YL01_FS_FX_TRWD_TRSF))
                  //雨量
                  if(Pt.RecordPt==1)
                  {
                    #if RECORD_ENABLE==1//变送器不在这里清0
                    StateC.Value[3]=Pt.RainPt=0;//第4通道是雨量
                    #endif
                    SET_YL1_INT; 
                  }
                  //风速
                  if((Pt.RecordPt%2)==1)//2秒计算一次风速
                  {
                    Pt.FsPt=0;
                    FS_INIT_SET;
                  }
                  else
                  {
                    StateC.Adc[4]=Pt.FsPt*100;//频率值
                    AdcToValue(StateC.Adc[4],4);
                    NOP;
                  }
                 #elif (JLY_MODEL==_8_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)
                  //雨量
                  if(Pt.RecordPt==1)
                  {
                    #if RECORD_ENABLE==1//变送器不在这里清0
                    StateC.Value[3]=Pt.RainPt=0;//第4通道是雨量
                    #endif
                    SET_YL1_INT; 
                  }
                  //风速
                  if((Pt.RecordPt%2)==1)//2秒计算一次风速
                  {
                    Pt.FsPt=0;
                    FS_INIT_SET;
                  }
                  else
                  {
                    StateC.Adc[6]=Pt.FsPt*100;//频率值
                    AdcToValue(StateC.Adc[6],6);
                    NOP;
                  }
                  
                 
                 #elif ((JLY_MODEL==_8B_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)||(JLY_MODEL==_8B_WD_GZV200K_SD_YL01_TRWD_TRSF_FS_FX))
                  //变送器雨量,//变送器雨量固定 1天清一次，在变送器记录时判断清0 
                  //风速
                  if((Pt.RecordPt%2)==1)//2秒计算一次风速
                  {
                    Pt.FsPt=0;
                    FS_INIT_SET;
                  }
                  else
                  {
                    StateC.Adc[6]=Pt.FsPt*100;//频率值
                    AdcToValue(StateC.Adc[6],6);
                    NOP;
                  }

                 #elif (JLY_MODEL==_6B_WD_SD_QY_YL01_FS_FX)
                  //变送器雨量固定 1天清一次，在变送器记录时判断清0 
                  //风速
                  if((Pt.RecordPt%2)==1)//2秒计算一次风速
                  {
                    Pt.FsPt=0;
                    FS_INIT_SET;
                  }
                  else
                  {
                    StateC.Adc[4]=Pt.FsPt*100;//频率值
                    AdcToValue(StateC.Adc[4],4);
                    NOP;
                  }
                  
                  
                 #elif (JLY_MODEL==_6_WD_SD_QY_YL01_FS_FX)
                  //雨量
                  if(Pt.RecordPt==1)
                  {
                    #if RECORD_ENABLE==1//变送器不在这里清0
                    StateC.Value[3]=Pt.RainPt=0;//第4通道是雨量
                    #endif
                    SET_YL1_INT; 
                  }
                  //风速
                  if((Pt.RecordPt%2)==1)//2秒计算一次风速
                  {
                    Pt.FsPt=0;
                    FS_INIT_SET;
                  }
                  else
                  {
                    StateC.Adc[4]=Pt.FsPt*100;//频率值
                    AdcToValue(StateC.Adc[4],4);
                    NOP;
                  }
  
                 #elif (JLY_MODEL==_3_FS_FX_01YL)
                  //雨量
                  if(Pt.RecordPt==1)
                  {
                    #if RECORD_ENABLE==1//变送器不在这里清0
                    StateC.Value[2]=Pt.RainPt=0;//雨量
                    #endif
                    SET_YL1_INT; 
                  }
                  //风速
                  if((Pt.RecordPt%2)==1)//2秒计算一次风速
                  {
                    Pt.FsPt=0;
                    FS_INIT_SET;
                  }
                  else
                  {
                    StateC.Adc[0]=Pt.FsPt*100;//频率值
                    AdcToValue(StateC.Adc[0],0);
                    NOP;
                  }
                  
                
                  #elif (JLY_MODEL==_2_FS_FX)
                  if((Pt.RecordPt%2)==1)
                  {
                    Pt.FsPt=0;
                    FS_INIT_SET;
                  }
                  else
                  {
                    StateC.Adc[0]=Pt.FsPt*100;
                    AdcToValue(StateC.Adc[0],0);
                    NOP;
                  }
                  #endif
                  
                  
                  #if (((LCD_NO==7)&&(CH_NUM>2))||((LCD_NO==20)&&(CH_NUM>=1)))
                  LoggerLcdDeel();//显示
                  #endif

                  SampleRecordDeel();//记录
                  
               #endif
              
              LoggerAlarmDeel();//报警
              
              
              #if RY_CONTROL_ENABLE==1
              RyControlDeel();//继电器控制
              #endif
              //..................................................................
          }
          
          #if BSQ_ENABLE==0
          if(StateB.StopMode==STOP_MODE_LATER)
          {
			
	    Rtc.SS=ReadRtcD10();
			
            StrcutRtc DTime;
            DTime.Year=StateB.LaterStopTime[0];
            DTime.Month=StateB.LaterStopTime[1];
            DTime.Day=StateB.LaterStopTime[2];
            DTime.Hour=StateB.LaterStopTime[3];
            DTime.Minute=StateB.LaterStopTime[4];
            DTime.Second=StateB.LaterStopTime[5];
            RtcBcdToD10(&DTime);
            DTime.SS=DateToSeconds(&DTime);
            if(Rtc.SS>=DTime.SS)
            {
              LoggerStop();
              StateA2.StopCause=OFF_LATER_TIME_STOP;
              StateA2ToEE();
            }
          }
          #endif
    }
    #if BSQ_ENABLE==0
    else//停机状态..............................................................
    {
          POWER_CTL_ALL_OFF;
          
          #if SHUXIAN_ENABLE==0
          
          if(Key.KeyTimePt==0)//zz
          {
            LcdOFFX(StateA2.StopCause);
          }
          
          if(StateA2.StopCause==OFF_LATER_TIME_START)
          {
                //定时时间小于重启时间时，立即启动
				
		Rtc.SS=ReadRtcD10();
				
                StrcutRtc DTime;
                DTime.Year=StateB.LaterStartTime[0];//定时时间
                DTime.Month=StateB.LaterStartTime[1];
                DTime.Day=StateB.LaterStartTime[2];
                DTime.Hour=StateB.LaterStartTime[3];
                DTime.Minute=StateB.LaterStartTime[4];
                DTime.Second=StateB.LaterStartTime[5];
                RtcBcdToD10(&DTime);
                DTime.SS=DateToSeconds(&DTime);
                if(Rtc.SS>=DTime.SS)
                {
                      Pt.RtcPt=0;
                      Pt.RecordPt=0;
                      Pt.RealSamplePt=0;
                      StateA2.WorkState=WORK_STATE_RECORDING;
                      
                      RestartClr();
                      
                      StateA2.StopCause=OFF_NOT;
                      
                      StrcutRtc STime;
                      STime.Year=StateA2.StartTime[0];//重启时间
                      STime.Month=StateA2.StartTime[1];
                      STime.Day=StateA2.StartTime[2];
                      STime.Hour=StateA2.StartTime[3];
                      STime.Minute=StateA2.StartTime[4];
                      STime.Second=StateA2.StartTime[5];
                      RtcBcdToD10(&STime);
                      STime.SS=DateToSeconds(&STime);
                      if(STime.SS<DTime.SS)
                      {
                        for(u8 j=0;j<6;j++)
                          StateA2.StartTime[j]=StateB.LaterStartTime[j];
                      }
                      StateA2ToEE();

                }
          }
          #endif
    }
    #endif
}
//记录仪停机，非变送器
void LoggerStop(void)
{
  #if BSQ_ENABLE==0
  StateA2.WorkState=WORK_STATE_STOP;
  #endif
}
void LcdAlarmEn(void)
{
  #if LCD_NO==7
  //通道报警使能指示
  if(HaveALEnable())
  {
    LcdAlarmOn(1);
  }
  else
  {
    LcdAlarmOn(0);
  }
  #endif
}
void LcdMode(void)
{
  //GPRS变送器，显示的是GPRS模块的省电或正常状态
  #if ((LCD_NO==7)&&((GPRS_ENABLE==1)&&(BAT_LCD_EN==1)))
    if(Pt.GprsSleep==1)
    {
      LcdLowMode(1);
    }
    else
    {
      LcdLowMode(0);
    }
  #elif ((LCD_NO==7)&&(POWER_TIME_ENABLE==1)&&(SD_ENABLE==1))
    //显示模式
    if(Pt.sd_pt==0)
    {
      LcdLowMode(1);
    }
    else
    {
      LcdLowMode(0);
    }

  #endif
  
  #if U0U1_ENABLE==1
  LcdSXCB(Flag.U0U1ing);
  #endif
}
void LcdExtreDeel(void)
{
                  
     #if LCD08_SD_SHIFT_EN==1
         if(Flag.LCD08_Sd_en==1)
         {
            if(Pt.sd_pt==0)
              return;//从关屏模式，不进行显示操作
         }
     #else
        #if ((SD_ENABLE==1)&&(LCD_NO==8))
        if(Pt.sd_pt==0)
          return;//从关屏模式，不进行显示操作
        #endif
     #endif

    if(Flag.SampPt==1)//采样忙
      return;
   
    #if MIN_MAX_AVG_ENABLE==1
       if(Pt.min_max_pt>0)//显示极值
       {
          Pt.min_max_pt--;
          
              if(Pt.min_max_pt==5)
              {
                //显示数值
                LcdExtremum(StateC.max,Pt.ChPt);
                
                //显示标志
                #if LCD_NO==8
                Lcd08_Max();
                BuToLcdRam(0,6);
                #else
                LcdMax();
                BuToLcdRam(0,17);
                #endif
                
              }
              else if(Pt.min_max_pt==3)
              {
                LcdExtremum(StateC.min,Pt.ChPt);
                //显示标志
                #if LCD_NO==8
                Lcd08_Min();
                BuToLcdRam(0,6);
                #else
                LcdMin();
                BuToLcdRam(0,17);
                #endif
              }
              else if(Pt.min_max_pt==1)
              {
                LcdExtremum(StateC.avg,Pt.ChPt);
                //显示标志
                #if LCD_NO==8
                Lcd08_Avg();
                BuToLcdRam(0,6);
                #else
                LcdAvg();
                BuToLcdRam(0,17);
                #endif
                
                
                Pt.ChPt++;
                #if LCD_NO==7
                if(2*Pt.ChPt<CH_NUM)//1,2,温湿度对子
                {
                  Pt.min_max_pt=7;
                }
                #else
                if(Pt.ChPt<CH_NUM)
                {
                  Pt.min_max_pt=7;
                }
                #endif
              }
              else if(Pt.min_max_pt==0)
              {
                #if POWER_TIME_ENABLE==1
                LcdValue();
                #endif
                
                KeyIntSet();//处理按键结束后重新开启所有按键中断
              }
       }
    #endif
}
void DisplayToLow(void)
{
    //正常模式省电模式自动切换,Pt.sd_pt>0时为正常模式
  
     #if LCD08_SD_SHIFT_EN==1
         if(Flag.LCD08_Sd_en==1)
         {
            if(Pt.sd_pt>0)
            {
               StateB.LcdRefreshMode=LCD_IMMEDIATE;//正常模式  
               
               #if POWER_TIME_ENABLE==1
               if(Pt.sd_pt==1)
               {
                 if(Pt.RecordPt+POWER_D_TIME+1<StateB.RecordTime)//只有Pt.RecordPt较小时才进入省电模式
                   Pt.sd_pt--;
               }
               else
               {
                 Pt.sd_pt--;
               }
               #else
               if(Pt.sd_pt==1)
               {
                 if(Pt.RecordPt+1<StateB.RecordTime)//打开采样的前一秒
                    Pt.sd_pt--;
               }
               else
               {
                 Pt.sd_pt--;
               }
               #endif
               
               
               if(Pt.sd_pt==0)//进入省电模式
               {
                 if(Pt.min_max_pt>1)
                 {
                   Pt.min_max_pt=1;
                 }
                 
                 LcdLowMode(1);
                 
                 StateB.LcdRefreshMode=LCD_SYNCHRONOUS;
                 #if POWER_TIME_ENABLE==1
                 if(PowShutReady())
                 {
                   PowTimeClr();//刚进入省电模式
                   #if LCD07_SHUT_EN==1
                   LcdShowOn(0);
                   #endif
                 }         
                 #else
                 LcdShowOn(0);
                 #endif
                 
                 Flag.StartSample=START_SAMPLE_TIME;
                 Key.Step=0;
                 KeyIntSet();//重新开启所有按键中断
               }
            }

         }
     #else
          #if SD_ENABLE==1
          if(Pt.sd_pt>0)
          {
               StateB.LcdRefreshMode=LCD_IMMEDIATE;//正常模式   

               #if POWER_TIME_ENABLE==1
               if(Pt.sd_pt==1)
               {
                 if(Pt.RecordPt+POWER_D_TIME+1<StateB.RecordTime)//只有Pt.RecordPt较小时才进入省电模式
                   Pt.sd_pt--;
               }
               else
               {
                 Pt.sd_pt--;
               }
               #else
               if(Pt.sd_pt==1)
               {
                 if(Pt.RecordPt+1<StateB.RecordTime)//打开采样的前一秒
                    Pt.sd_pt--;
               }
               else
               {
                 Pt.sd_pt--;
               }
               #endif
             
             if(Pt.sd_pt==0)//进入省电模式
             {
               if(Pt.min_max_pt>1)
               {
                 Pt.min_max_pt=1;
               }
               
               LcdLowMode(1);
               
               StateB.LcdRefreshMode=LCD_SYNCHRONOUS;
               #if POWER_TIME_ENABLE==1
               if(PowShutReady())
               {
                 PowTimeClr();//刚进入省电模式
                 #if LCD07_SHUT_EN==1
                 LcdShowOn(0);
                 #endif
               }         
               #else
               LcdShowOn(0);
               #endif
               
               Flag.StartSample=START_SAMPLE_TIME;
               Key.Step=0;
               KeyIntSet();//重新开启所有按键中断
             }
          }
          #endif
     #endif
}
void StateASaveDeel(void)
{
  if(Pt.A1Pt<A1_TIME)//间隔时间存储参数
  {
    Pt.A1Pt++;
  }
}
//下载超时处理
void DownTimeOver(void)
{
    if(Download.Downloading==1)
    {
      if(++Download.TimeOut>DOWNLOAD_TIMEOUT)//下载超时
      {
        Download.TimeOut=0;
        Download.LastBagPt=0;
        Download.Downloading=0;
        U1Init(BAUDRATE_SYSTEM,0);
      }
      else
      {
        if(Download.LastBagPt>0)
        {
          if(--Download.LastBagPt==0)//下载最后一包后，没有读数据包，下载完成
          {
            Download.TimeOut=0;
            Download.LastBagPt=0;
            Download.Downloading=0;
            U1Init(BAUDRATE_SYSTEM,0);
          }
        }
      }
    }  
}

void PowPtDeel(void)
{
   #if POWER_TIME_ENABLE==1
   if(Pt.PowPt>0)
   {
     if(Pt.PowPt<POWER_D_TIME)
     {
       Pt.PowPt++;
     }
   }
   #endif
}

u8 PowShutReady(void)//关电源条件
{
   #if POWER_TIME_ENABLE==1
     #if DIGITAL_FILTER_EN==1
     if(StateB.RecordTime>POWER_D_TIME+LCD_REFRESH_TIME*FILET_NUM)
     #else
     if(StateB.RecordTime>POWER_D_TIME)//记录间隔大于，才关闭电源，否则不关
     #endif
     {
       if(StateB.LcdRefreshMode==LCD_SYNCHRONOUS)//省电模式才关闭电源，否则不关
       {
         return 1;
       }
     }
     return 0;
   #else
     return 1;
   #endif
   
}

void PowTimeClr(void)
{
  #if POWER_TIME_ENABLE==1
  Pt.PowPt=0;
  #endif
}
void PowTimeStart(void)
{
  #if POWER_TIME_ENABLE==1
  if(Pt.PowPt==0)
  {
    Pt.PowPt=1;
  }
  #endif
}
//电源打开时间等待
u8 PowTimeReady(void)
{
  #if POWER_TIME_ENABLE==1
  if(Pt.PowPt==POWER_D_TIME)
    return 1;
  else
    return 0;
  #else
  return 1;
  #endif
}
//----------------------------------------------------------------------------------
void LoggerAlarmAllSeek(void)
{ 
  u8 j;
  NOP;
  NOP;
  NOP;
  for(j=0;j<CH_NUM;j++)
  {
    LoggerAlarmOneSeek(j);
  }
}
u8 ChALEnable(u8 ChNo)
{
  if(*((char *)CH1_A_EN_ADDR+ONE_CH_CONFIG_BYTES*ChNo)==1)
  {
    return 1;
  }
  else
  {
    return 0;
  }
}
//有通道报警使能则返回1
u8 HaveALEnable(void)
{
  u8 ChNo;
  u8 En;
  En=0;
  for(ChNo=0;ChNo<CH_NUM;ChNo++)
  {
    if(ChALEnable(ChNo))
    {
      En=1;
    }
  }
  return En;
}


//CC=1,报警上下限，CC=2,控制上下限
//数值dd（存储格式）与通道(上下限)比较是否超标,没有超标返回0，否则1上限超标，2下限超标
u8 AlarmXSeek(u16 dd,u8 ChNo,u8 CC)
{
   u16 ValueLow,ValueHigh;
   u8 FuhaoLow,FuhaoHigh,FuhaoD;
   u8 ChaoBiao=0;
  
    //dd数据转换
    if((dd==SENIOR_NULL)||(dd==HAND_STOP))//传感器出错
    {
      return ChaoBiao;
    }
    
    if(dd&0x8000)
    {
      FuhaoD=1;//负数
      dd=dd&0x7fff;
    }
    else
      FuhaoD=0;
    
    if(CC==1)
    {
      //报警上下限
      ValueLow=*((char *)CH1_A_L_ADDR+ONE_CH_CONFIG_BYTES*ChNo)+(u16)256*((*((char *)CH1_A_L_ADDR+1+ONE_CH_CONFIG_BYTES*ChNo))&0x7f);
      if(((*((char *)CH1_A_L_ADDR+1+ONE_CH_CONFIG_BYTES*ChNo))&0x80)==0x80)
        FuhaoLow=1;
      else 
        FuhaoLow=0;
      ValueHigh=*((char *)CH1_A_H_ADDR+ONE_CH_CONFIG_BYTES*ChNo)+(u16)256*((*((char *)CH1_A_H_ADDR+1+ONE_CH_CONFIG_BYTES*ChNo))&0x7f);
      if(((*((char *)CH1_A_H_ADDR+1+ONE_CH_CONFIG_BYTES*ChNo))&0x80)==0x80)
        FuhaoHigh=1;
      else
        FuhaoHigh=0;
    }
    else if(CC==2)
    {
      #if RY_CONTROL_ENABLE==1
      //控制上下限
      ValueLow=*((char *)CH1_K_L_ADDR+ONE_CH_CONFIG_BYTES*ChNo)+(u16)256*((*((char *)CH1_K_L_ADDR+1+ONE_CH_CONFIG_BYTES*ChNo))&0x7f);
      if(((*((char *)CH1_K_L_ADDR+1+ONE_CH_CONFIG_BYTES*ChNo))&0x80)==0x80)
        FuhaoLow=1;
      else 
        FuhaoLow=0;
      ValueHigh=*((char *)CH1_K_H_ADDR+ONE_CH_CONFIG_BYTES*ChNo)+(u16)256*((*((char *)CH1_K_H_ADDR+1+ONE_CH_CONFIG_BYTES*ChNo))&0x7f);
      if(((*((char *)CH1_K_H_ADDR+1+ONE_CH_CONFIG_BYTES*ChNo))&0x80)==0x80)
        FuhaoHigh=1;
      else
        FuhaoHigh=0;
      #endif
    }
    
    //比较
    if(FuhaoD)//负数
    {
      if(FuhaoLow==1&&FuhaoHigh==1)
      {
        if(dd<ValueHigh)//上限超标
        {
          ChaoBiao=1;
        }
        if(dd>ValueLow)//下限超标
        {
          ChaoBiao=2;
        }
      }
      else if(FuhaoLow==1&&FuhaoHigh==0)
      {
        if(dd>ValueLow)//下限超标
        {
          ChaoBiao=2;
        }
      }
      else if(FuhaoLow==0&&FuhaoHigh==0)//下限超标
      {
        ChaoBiao=2;
      }
    }
    else//0或正数
    {
      if(FuhaoLow==1&&FuhaoHigh==1)
      {
        ChaoBiao=1;//上限超标
      }
      else if(FuhaoLow==1&&FuhaoHigh==0)
      {
        if(dd>ValueHigh)
        {
          ChaoBiao=1;//上限超标
        }
      }
      else if(FuhaoLow==0&&FuhaoHigh==0)
      {
        if(dd>ValueHigh)//上限超标
        {
          ChaoBiao=1;
        }
        if(dd<ValueLow)//下限超标
        {
          ChaoBiao=2;
        }
      }
    }
    return ChaoBiao;
}

//实时值[StateC.Value，StateC.FuhaoBit]，是否超标，超标时，置位标志，不超标时，清标志
void LoggerAlarmOneSeek(u8 ChNo)
{
  u16 ValueLow,ValueHigh;
  vu8 FuhaoLow,FuhaoHigh;//zz 171129
  
  //if(*((char *)CH1_A_EN_ADDR+ONE_CH_CONFIG_BYTES*ChNo)==1)//使能标志
  //{
    if((StateC.Value[ChNo]==SENIOR_NULL)||(StateC.Value[ChNo]==HAND_STOP))//传感器出错
    {
      Flag.AlarmB&=~(1<<ChNo);
      Flag.AlarmR&=~(1<<ChNo);
      return;
    }
    
    ValueLow=*((char *)CH1_A_L_ADDR+ONE_CH_CONFIG_BYTES*ChNo)+(u16)256*((*((char *)CH1_A_L_ADDR+1+ONE_CH_CONFIG_BYTES*ChNo))&0x7f);
    if(((*((char *)CH1_A_L_ADDR+1+ONE_CH_CONFIG_BYTES*ChNo))&0x80)==0x80)
      FuhaoLow=1;
    else 
      FuhaoLow=0;
    ValueHigh=*((char *)CH1_A_H_ADDR+ONE_CH_CONFIG_BYTES*ChNo)+(u16)256*((*((char *)CH1_A_H_ADDR+1+ONE_CH_CONFIG_BYTES*ChNo))&0x7f);
    if(((*((char *)CH1_A_H_ADDR+1+ONE_CH_CONFIG_BYTES*ChNo))&0x80)==0x80)
      FuhaoHigh=1;
    else
      FuhaoHigh=0;
    
    Flag.AlarmB&=~(1<<ChNo);
    if(0x01&(StateC.FuhaoBit>>ChNo))
    {
          if(FuhaoLow==1&&FuhaoHigh==1)
          {
            if(StateC.Value[ChNo]>ValueLow||StateC.Value[ChNo]<ValueHigh)
            {
              Flag.AlarmB|=(1<<ChNo);
            }
          }
          else if(FuhaoLow==1&&FuhaoHigh==0)
          {
            if(StateC.Value[ChNo]>ValueLow)
            {
              Flag.AlarmB|=(1<<ChNo);
            }
          }
          else if(FuhaoLow==0&&FuhaoHigh==0)
          {
            Flag.AlarmB|=(1<<ChNo);
          }
    }
    else
    {
          if(FuhaoLow==1&&FuhaoHigh==1)
          {
            Flag.AlarmB|=(1<<ChNo);
          }
          else if(FuhaoLow==1&&FuhaoHigh==0)
          {
            if(StateC.Value[ChNo]>ValueHigh)
            {
              Flag.AlarmB|=(1<<ChNo);
            }
          }
          else if(FuhaoLow==0&&FuhaoHigh==0)
          {
            if(StateC.Value[ChNo]<ValueLow||StateC.Value[ChNo]>ValueHigh)
            {
             Flag.AlarmB|=(1<<ChNo);
            }
          }
    }
    
    //记录标志
    if(1&(Flag.AlarmB>>ChNo))
    {
        Flag.AlarmR|=(1<<ChNo);
    }
    else
    {
        Flag.AlarmR&=~(1<<ChNo);
    }
    
    
    if(*((char *)CH1_A_EN_ADDR+ONE_CH_CONFIG_BYTES*ChNo)==0)//使能标志关时，清标志，不报警
    {
        Flag.AlarmB&=~(1<<ChNo);
    }

}
/**********************************************************
补偿系数 x=1/(1.0546-0.00216*T)   ,  H2=x*H1
温度与补偿系数正比，即温度越高，x越大。
说明，没有补偿时，实际温度越高，湿度偏低，温度越低，湿度偏高
T=30.0   x=1.010
T=25.2   x=1.000
T=12.9   x=0.974
T=2.0    x=0.952
T=-20.0  X=0.911
计算湿度,根据湿度AD ,和 温度补偿通道, TchNo=99,不补偿
************************************************************/
u16 GetHumiValue(u16 humiAd,u8 TchNo)//
{
  u16 cc;
  float fh,ft;
  
  fh=humiAd;
  fh=((fh/4096)-0.1515)/0.00636;
  
  if(TchNo!=99)
  {
          if(StateC.Value[TchNo]!=SENIOR_NULL)//温度不等于NULL时，才进行温度补偿
          {
              ft=StateC.Value[TchNo];
              if(*((char*)CH1_S_ADDR+ONE_CH_CONFIG_BYTES*TchNo)==_S_1)//温度 1位小数
              {
                ft=ft*0.1;
              }
              #if OPT_EN==0
              else if(*((char*)CH1_S_ADDR+ONE_CH_CONFIG_BYTES*TchNo)==_S_2)//温度 2位小数
              {
                ft=ft*0.01;
              }
              #endif
              
              if(0x01&(StateC.FuhaoBit>>TchNo))//负数
              {
                ft=ft*(-1);
              }
              fh=fh/(1.0546-0.00216*ft);//温度补偿公式
          }
  }
  
  cc=(u16)(fh*10);//AD值位实际值扩大10倍，1000
  return cc;
}

//有通道报警，返回1，否则0(使能开启下会 声光报警或短信报警)
u8 ChAlarm(void)
{
  u8 j;
  for(j=0;j<CH_NUM;j++)
  {
    if(1&(Flag.AlarmB>>j))
      return 1;
  }
  return 0;
}
//超标记录标志(不管使能都会监测)
u8 RecAlarm(void)
{
  u8 j;
  for(j=0;j<CH_NUM;j++)
  {
    if(1&(Flag.AlarmR>>j))
      return 1;
  }
  return 0;
}
//查询通道Ch当前标志是否超标，针对 Flag.AlarmB
u8 SeeChAlarm(u8 Ch)
{
  #if ALARM_TIME_ENABLE==1
  if(Flag.AlarmedCh[Ch]==1)//曾经超标过，只能通过按钮清
  {
    if(ChALEnable(Ch))//使能开启
      return 1;
  }
  #endif
  
  if(Flag.AlarmB&(1<<Ch))
    return 1;
  else
    return 0;
}

//单个通道处理
void FilterChClr(u8 ChNo)
{
  #if DIGITAL_FILTER_EN==1
  StateC.FiletNt[ChNo]=0;
  StateC.FiletPt[ChNo]=0;
  #endif
}

//数字滤波，所有通道变量清0
void FilterClr(void)
{
  #if DIGITAL_FILTER_EN==1
  u16 j;
  for(j=0;j<CH_NUM;j++)
  {
    FilterChClr(j);
  }
  
     #if BAT_AD_ENABLE==1
         #if BAT_FIL_EN==1
         FilterChClr(7);//对应通道数字滤波变量清0
         #endif
     #endif
  
  
  
  #endif
}

//aa和bb 差值 大于cc  返回1
u8 CompABcc(u16 aa,u16 bb,u16 cc)
{
  u32 xa,xb;
  xa=aa;
  xb=bb;
  
  if((xa+cc<=xb)||(xb+cc<=xa))
  {
    return 1;
  }
  return 0;
}
//传感器信号为 null 时 不能进入
//取某通道FILET_NUM个数的均值
//数组里的数必须是有效数，先进先出，FIFO
//入口数据：StateC.Adc[]
void GetChFilterAd(u8 ChNo)
{
    #if DIGITAL_FILTER_EN==1
    u16 j;

      //先进先出移位
      if(StateC.FiletNt[ChNo]==FILET_NUM)
      {
        for(j=0;j<FILET_NUM-1;j++)
        {
          StateC.FilterAd[ChNo][j]=StateC.FilterAd[ChNo][j+1];
        }
        
        #if DIGITAL_CHANGE_EN==1
        if(CompABcc(StateC.FilterAd[ChNo][FILET_NUM-1],StateC.Adc[ChNo],CHANGE_AD_MAX))
        {
          FilterChClr(ChNo);//清空
          return;
        }
        #endif
        
        StateC.FilterAd[ChNo][FILET_NUM-1]=StateC.Adc[ChNo];//最新数据
      }
      else
      {
        #if DIGITAL_CHANGE_EN==1
        if(StateC.FiletPt[ChNo]>0)
        {
          if(CompABcc(StateC.FilterAd[ChNo][StateC.FiletPt[ChNo]-1],StateC.Adc[ChNo],CHANGE_AD_MAX))
          {
            FilterChClr(ChNo);//清空
            return;
          }
        }
        #endif
        StateC.FilterAd[ChNo][StateC.FiletPt[ChNo]]=StateC.Adc[ChNo];//最新数据
      }
      
      if(++StateC.FiletPt[ChNo]>=FILET_NUM)
      {
        StateC.FiletPt[ChNo]=0;
      }
      
      if(StateC.FiletNt[ChNo]<FILET_NUM)//最多+至FILET_NUM后不变
      {
        StateC.FiletNt[ChNo]++;
      }
      else
      {
        StateC.FiletNt[ChNo]=FILET_NUM;
      }

      u16 BufB[FILET_NUM];//注意，排序在这个数组进行，原始数值的值不变 
      for(j=0;j<FILET_NUM;j++)
      {
        BufB[j]=StateC.FilterAd[ChNo][j];
      }
      
     
      //Nt值在（1，FILET_NUM）间均可
      StateC.Adc[ChNo]=get_mid_value(BufB,StateC.FiletNt[ChNo]);
      NOP;
  #endif
}



void LoggerSample(void)
{        
   NOP;
   NOP;
   NOP;
   
   
   if(KeyDoing())
     return;

   if(Flag.SampPt==0)
   {
     Flag.SampPt=1;//开始AD采样标志
   }
   else
   {
     Flag.SampPt=0;
     return;
   }
   
   #if POWER_TIME_ENABLE==1
   PowTimeStart();
   #endif
   
   VT_CTL_ON;
   
   #if BAT_AD_ENABLE==1
   VPP_CTL_ON;
   #endif
   ADC_REF_ON;
   ADC_ON;
   
   #if GZ_ENABLE==1
   LxStart();
   
     #if SENCOND_GZ_EN==1 
       LxBHStart();//第2个照度
     #endif
   
   
   #endif
   
   #if ((JLY_MODEL==_20_SHT)||(JLY_MODEL==_20_NTC_SHT))
   StateC.ShtT=0;
   StateC.ShtH=0;
   Pt.ShtPt=0;
   ShtStart(0);
   #endif
   
   #if ((JLY_MODEL==_6_DS18B20_F55_125)||(JLY_MODEL==_8_DS18B20_F55_125)||(JLY_MODEL==_1_DS18B20_F55_125)||(JLY_MODEL==_2_DS18B20_F55_125)\
     ||(JLY_MODEL==_2_DS18B20_HIH)||(JLY_MODEL==_4_DS18B20_F55_125)||(JLY_MODEL==_3_DS18B20_F55_125))
   for(u8 j=0;j<CH_NUM;j++)
     OneChTstart(j);
   #elif (JLY_MODEL==_2_K_F200_1350_DS_F55_125)
   OneChTstart(1);
   #endif
   
   
   #if ((SEN_UART_EN==1)||(SEN_U0_PM25_EN==1))
   if(StateC.sen_Pt<SEN_REC_TIME)
   {
     StateC.sen_Pt++;//开始计数，如果一直没有正确数据回来，会超时，判断传感器未接
   }
   #endif
   
   #if SEN_MODBUS_485_EN==1
   
   if(StateC.sen_spt[0]<SEN_REC_TIME)
   {
     StateC.sen_spt[0]++;//开始计数，如果一直没有正确数据回来，会超时，判断传感器未接
   }
   if(StateC.sen_spt[1]<SEN_REC_TIME)
   {
     StateC.sen_spt[1]++;//开始计数，如果一直没有正确数据回来，会超时，判断传感器未接
   }
   
   #endif
   
   
   #if PT_MAX31865_EN==1
      for(u8 j=0;j<CH_NUM;j++)
         Pt.t_temp[j]=SENIOR_NULL;
      NTC_ON;//电源开
      rtd_io_ini();//IO口 INI
      //电源开后，等待10ms后，开始转换温度
   #endif 
      
      
   #if K_MAX31855_EN==1
      for(u8 j=0;j<CH_NUM;j++)
         Pt.t_temp[j]=SENIOR_NULL;
      NTC_ON;//电源开
      k_io_ini();//IO口 INI
      //电源开后，等待10ms后，开始
   #endif 
      
      
      
   #if SHR1000_ENABLE==1
     shr1000Write();//气压传感器初始化设置
   #endif
     
   //AD采样开始前，Asum和置0
   for(u8 j=0;j<8;j++)
     StateC.Asum[j]=0;
   
   Pt.AdcPt=0;
   TB0_START;

    NOP;
    NOP;
    NOP;
}
//返回0，错误，重新采样, 返回1 ，正确
u8 LoggerCalculateValue(void)
{
  u16 j;
  
  #if HTU_ENABLE==1
    int TH[2];
    u16 CC;
  #endif
  
  if(KeyDoing())
    return 1;
  if(!(Flag.SampPt==2))//上一步如果不是AD采样结束，退出
    return 1;
  

  #if POWER_TIME_ENABLE==1
  if(PowTimeReady()==0)//传感电源没准备好
  {
      if(!(StateB.RecordTime>POWER_D_TIME))//记录间隔小于时，显示NULL,否则，沿用上个值
      {
          for(j=0;j<CH_NUM;j++)
          {
            StateC.Value[j]=SENIOR_NULL;
            #if DIGITAL_FILTER_EN==1
            FilterChClr(j);//对应通道数字滤波变量清0
            #endif
          }
          
          #if (JLY_MODEL==_8B_WD_GZV200K_SD_YL01_TRWD_TRSF_FS_FX)
          StateC.Value[3]=0;//雨量
          #endif
      }
      
      #if ((SEN_UART_EN==1)||(SEN_U0_PM25_EN==1))
        StateC.sen_vv=SENIOR_NULL;
        #if DIGITAL_FILTER_EN==1
        FilterChClr(0);//对应通道数字滤波变量清0
        #endif
      #endif
      
      return 1;
  }
  #endif
  
  #if ALARM_POINT_ENABLE==1
  if(Flag.RstFirstSample==1)
  {
    AlarmPointBc();//保存上次数据
  }
  #endif
    
//数字信号部分...............................................................
#if ((JLY_MODEL==_20_NTC_SHT)||(JLY_MODEL==_20_SHT))
  if(Pt.ShtPt==2)
  {
    WDT_CLR;
    StateC.Temp=-39.63+0.01*StateC.ShtT;
    StateC.Humi=-4.0+0.0405*StateC.ShtH-0.0000028*StateC.ShtH*StateC.ShtH;
    StateC.Humi=StateC.Humi+(StateC.Temp-25.0)*(0.01+0.00008*StateC.ShtH);
    
    StateC.Adc[1]=(u16)(StateC.Humi*10.0);
    AdcToValue(StateC.Adc[1],1);
    
    #if (JLY_MODEL==_20_SHT)
    StateC.Adc[0]=(u16)((StateC.Temp+40)*10.0);
    AdcToValue(StateC.Adc[0],0);
    if((StateC.Value[0]>390)&&(StateC.FuhaoBit&BIT0))
    {
       StateC.Value[0]=SENIOR_NULL;
       StateC.Value[1]=SENIOR_NULL;
    }
    #endif
  }
  else
  {
    #if (JLY_MODEL==_20_SHT)
    StateC.Value[0]=SENIOR_NULL;
    #endif
    StateC.Value[1]=SENIOR_NULL;
    
  }
  


#else
  
  for(j=0;j<CH_NUM;j++)
  {

    //测试zz-----------------------------------------------------
      //StateC.Adc[j]=2000;
         //StateC.FuhaoBit=0x00;
         //StateC.Value[j]=PcBsq.RecPt+1;//1-MAX-1
         //StateC.Value[j]=248;//1-MAX-1
         //continue;
    
         //StateC.Value[j]=StateA1.RecordNum+j*100;
         //StateC.FuhaoBit|=BIT0;
         //continue;
/*
    u32 rdm;
    u16 rdz;
    rdm=TAR;
    rdm+=TBR;
    rdm+=StateC.Adc[5];
    rdm+=StateC.Adc[6];

    #define XXTT  ((u16)1200*12)
    #define OOTT   ((u16)1200)
    
    if((Rtc.SS%XXTT)<OOTT)
    {
        rdz=rdm%16;
        StateC.Adc[j]=1286+rdz;//7.8-8.2
    }
    else  if((Rtc.SS%XXTT)<OOTT*2)
    {
        rdz=rdm%8;
        StateC.Adc[j]=1286+rdz;//7.8~8.0
    }
    else if((Rtc.SS%XXTT)<OOTT*3)
    {
        rdz=rdm%16;
        StateC.Adc[j]=1286+rdz;//7.8-8.2
    }
    else  if((Rtc.SS%XXTT)<OOTT*4)
    {
        rdz=rdm%16;
        StateC.Adc[j]=1044+rdz;//1.8~2.2
    }
    else if((Rtc.SS%XXTT)<OOTT*5)
    {
        rdz=rdm%8;
        StateC.Adc[j]=1052+rdz;//2.0~2.2
    }
    
    else  if((Rtc.SS%XXTT)<OOTT*6)
    {
        rdz=rdm%16;
        StateC.Adc[j]=1044+rdz;//1.8~2.2
    }
    
    else if((Rtc.SS%XXTT)<OOTT*7)
    {
        rdz=rdm%21;
        StateC.Adc[j]=953+rdz;//-0.6 
    }
    else  if((Rtc.SS%XXTT)<OOTT*8)
    {
        rdz=rdm%16;
        StateC.Adc[j]=1044+rdz;//1.8~2.2
    }
    else if((Rtc.SS%XXTT)<OOTT*9)
    {
        rdz=rdm%8;
        StateC.Adc[j]=1052+rdz;//2.0~2.2
    }
    else  if((Rtc.SS%XXTT)<OOTT*10)
    {
        rdz=rdm%16;
        StateC.Adc[j]=1044+rdz;//1.8~2.2
    }
    
    else if((Rtc.SS%XXTT)<OOTT*11)
    {
        rdz=rdm%16;
        StateC.Adc[j]=1286+rdz;//7.8-8.2
    }
    else  
    {
        rdz=rdm%8;
        StateC.Adc[j]=1286+rdz;//7.8~8.0
    }
*/

    //----------------------------------------------

    #if PT_L_ERR_ENABLE==1//PT采用3线制，null临界判定
    if(StateC.Adc[j]<ADC_PT_ERR_L)
      
    #elif ((JLY_MODEL==_4_2PT_F40_100_2HIH)||(JLY_MODEL==_4_2PT_F100_200_2HIH)||(JLY_MODEL==_4_2PT_F200_100_2HIH))
    if((((j%2)==0)&&(StateC.Adc[j]<ADC_PT_ERR_L))||(((j%2)==1)&&(StateC.Adc[j]<ADC_ERR_L)))
      
      
    #elif (JLY_MODEL==_6_1PT_F40_100_1HIH_2NTC_2HIH)
    if(((j==0)&&(StateC.Adc[j]<ADC_PT_ERR_L))||((j>0)&&(StateC.Adc[j]<ADC_ERR_L)))
    
    #elif (JLY_MODEL==_3_1NTC_1HIH_1PT_F40_100)
    if(((j==2)&&(StateC.Adc[j]<ADC_PT_ERR_L))||((j<2)&&(StateC.Adc[j]<ADC_ERR_L)))
      
    #elif (JLY_MODEL==_4_1PT_F100_200_2NTC_1HIH)
    if(((j==0)&&(StateC.Adc[j]<ADC_PT_ERR_L))||((j>0)&&(StateC.Adc[j]<ADC_ERR_L)))
      
    #elif ((JLY_MODEL==_8_4PT_F100_200_4HIH)||(JLY_MODEL==_8_4PT_F100_300_4HIH))
    if(((j<4)&&(StateC.Adc[j]<ADC_PT_ERR_L))||((j>3)&&(StateC.Adc[j]<ADC_ERR_L)))
      
      
    #elif ((JLY_MODEL==_5_4PT_0_300_1NTC)||(JLY_MODEL==_5_4PT_F100_200_1NTC))
    if(((j<4)&&(StateC.Adc[j]<ADC_PT_ERR_L))||((j==4)&&(StateC.Adc[j]<ADC_ERR_L)))
      
    #elif (JLY_MODEL==_8_3PT_F100_100_5NTC)
    if(((j<=2)&&(StateC.Adc[j]<ADC_PT_ERR_L))||((j>2)&&(StateC.Adc[j]<ADC_ERR_L)))
      
    #elif ((JLY_MODEL==_8_1PT_F100_200_7NTC)||(JLY_MODEL==_2_1PT_F100_200_1NTC)||(JLY_MODEL==_3_PT_F100_100_2NTC)||(JLY_MODEL==_4_PT_F100_100_3NTC))
    if(((j==0)&&(StateC.Adc[j]<ADC_PT_ERR_L))||((j>0)&&(StateC.Adc[j]<ADC_ERR_L)))
      
    #elif ((JLY_MODEL==_6_2PT_2ROTYONIC_NTC_HIH)||(JLY_MODEL==_2_1PT_1ROTYONIC))//罗卓尼克 没有NULL,0~1v
    if((((j==0)||(j==2))&&(StateC.Adc[j]<ADC_PT_ERR_L))||(((j==4)||(j==5))&&(StateC.Adc[j]<ADC_ERR_L)))
      
    #elif (JLY_MODEL==_8_4PT_4ROTYONIC)
    if((j<4)&&(StateC.Adc[j]<ADC_PT_ERR_L))

    #elif ((JLY_MODEL==_2_1PT_0_300_1HIH)||(JLY_MODEL==_2_1PT_F40_150_1HIH)||(JLY_MODEL==_2_1PT_F100_200_1HIH)||(JLY_MODEL==_2_1PT_F50_250_1HIH)\
      ||(JLY_MODEL==_2_1PT_F200_100_1HIH)||(JLY_MODEL==_2_1PT_F50_200_1HIH)||(JLY_MODEL==_2_1PT_F100_100_1HIH))
    if(((j==0)&&(StateC.Adc[j]<ADC_PT_ERR_L))||((j==1)&&(StateC.Adc[j]<ADC_ERR_L)))
      
    #elif (JLY_MODEL==_3_2PT_0_300_1HIH)
    if((((j==0)||(j==1))&&(StateC.Adc[j]<ADC_PT_ERR_L))||((j==2)&&(StateC.Adc[j]<ADC_ERR_L)))
      
    #elif (JLY_MODEL==_4_2PT_F50_250_2HIH)
    if(((j<2)&&(StateC.Adc[j]<ADC_PT_ERR_L))||((j>1)&&(StateC.Adc[j]<ADC_ERR_L)))
    
    #elif ((JLY_MODEL==_4_2PTH_2HIH)||(JLY_MODEL==_4_2PT_F50_100_2HIH)||(JLY_MODEL==_4_2PT_F50_200_2HIH))
    if((((j==0)||(j==2))&&(StateC.Adc[j]<ADC_PT_ERR_L))||(((j==1)||(j==3))&&(StateC.Adc[j]<ADC_ERR_L))) 
      
    #elif (JLY_MODEL==_2_DS18B20_HIH)
    if((j==1)&&(StateC.Adc[j]<ADC_ERR_L))
    
    //数字信号，直接进数据处理  
    #elif ((JLY_MODEL==_1_GZ_100K)||(JLY_MODEL==_1_GZ_200K)||(JLY_MODEL==_2_FS_FX)||(JLY_MODEL==_3_DS18B20_F55_125)\
      ||(JLY_MODEL==_3_FS_FX_01YL)||(JLY_MODEL==_1_SHR_30_120_kpa)||(JLY_MODEL==_4_DS18B20_F55_125)\
        ||(JLY_MODEL==_1_GZ_65K)||(JLY_MODEL==_1_GZ_100LX)||(JLY_MODEL==_1_GZ_1000LX)||(JLY_MODEL==_2_DS18B20_F55_125)\
          ||(JLY_MODEL==_8_DS18B20_F55_125)||(JLY_MODEL==_6_DS18B20_F55_125)||(JLY_MODEL==_1_DS18B20_F55_125)||(JLY_MODEL==_2_WDHTU_SDHTU)\
        ||(JLY_MODEL==_1_CO2_TTL_5000)||(JLY_MODEL==_2_WDHIH6130_SDHIH6130)||(JLY_MODEL==_1_K_F200_1350)||(JLY_MODEL==_2_K_F200_1350_COLD)\
          ||(JLY_MODEL==_2_K_F200_1350_DS_F55_125)||(JLY_MODEL==_1_PM25_TTL_1000)||(JLY_MODEL==_2_PM25_TTL1000_PM25V_1000)||(JLY_MODEL==_2_PM25_TTL1000_CO2_MISIR_5000)\
            ||(JLY_MODEL==_1_CO2_MISIR_5000)||(JLY_MODEL==_3_K_F200_1350)||(JLY_MODEL==_1_HCH2O_TTL_0_373)||(JLY_MODEL==_1_RTD_F200_300)||(JLY_MODEL==_1_PM25_PWM_1000)\
              ||(JLY_MODEL==_4_RTD_F200_300)||(JLY_MODEL==_1_CO2_TTL_20BF)||(JLY_MODEL==_1_ROTYONIC)||(JLY_MODEL==_2_LS_SS)\
                ||(JLY_MODEL==_4_2LS_2SS)||(JLY_MODEL==_2_O2_CO2_TTL_5000)||(JLY_MODEL==_2_wdSHT30_sdSHT30))
    if(0)
    
    //电压模拟信号，不取null，取0, 0为重要参数 
    #elif ((JLY_MODEL==_1_CO2_COZIR_W10V)||(JLY_MODEL==_1_GZV_200K)||(JLY_MODEL==_1_CO2_0_5)||(JLY_MODEL==_1_PM25_V_1000)\
       ||(JLY_MODEL==_1_O2)||(JLY_MODEL==_1_SSFS_0_2000))
    if(0)
      
    #elif (JLY_MODEL==_2_NTC_ZWFS)  
    if((j==0)&&(StateC.Adc[j]<ADC_ERR_L))
      
    #elif ((JLY_MODEL==_3_CF)||(JLY_MODEL==_1_DOOR)||(JLY_MODEL==_1_SMOKE))//醋漏油检测
    if(0)
      
    #elif ((JLY_MODEL==_2_WD_GZ100K)||(JLY_MODEL==_2_WD_GZ200K))
    if((j==0)&&(StateC.Adc[j]<ADC_ERR_L))
      
    #elif ((JLY_MODEL==_3_WD_SD_GZ100K)||(JLY_MODEL==_3_WD_SD_GZ200K))
    if(((j==0)||(j==1))&&(StateC.Adc[j]<ADC_ERR_L))//数字信号，直接进数据处理
    
    #elif ((JLY_MODEL==_4_WD_GZ100K_SD_YL01)||(JLY_MODEL==_6_WD_GZ100K_SD_YL01_FS_FX)||(JLY_MODEL==_6_WD_GZ100K_SD_YL05_FS_FX))
    if(((j==0)||(j==2))&&(StateC.Adc[j]<ADC_ERR_L))
      
    #elif (JLY_MODEL==_4_WD_SD_FS_FX)
    if(((j==0)||(j==1))&&(StateC.Adc[j]<ADC_ERR_L))
      
    #elif ((JLY_MODEL==_7_WD_GZ200K_SD_YL01_FS_FX_TRWD)||(JLY_MODEL==_8_WD_GZ200K_SD_YL01_FS_FX_TRWD_TRSF))
    if(((j==0)||(j==2)||(j==6))&&(StateC.Adc[j]<ADC_ERR_L))
      
    #elif (JLY_MODEL==_3_NTC_HIH5030_01YL)
    if(((j==0)||(j==1))&&(StateC.Adc[j]<ADC_ERR_L))
    
    #elif (JLY_MODEL==_2_NTC_01YL)
    if((j==0)&&(StateC.Adc[j]<ADC_ERR_L))

    #elif ((JLY_MODEL==_8_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)||(JLY_MODEL==_8B_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX))
    if(((j==0)||(j==2)||(j==4))&&(StateC.Adc[j]<ADC_ERR_L))
    
    #elif ((JLY_MODEL==_6B_WD_SD_QY_YL01_FS_FX)||(JLY_MODEL==_3_WD_SD_QY)||(JLY_MODEL==_6_WD_SD_QY_YL01_FS_FX))
    if(((j==0)||(j==1))&&(StateC.Adc[j]<ADC_ERR_L)) 
      
    #elif ((JLY_MODEL==_5_WD_GZ100K_TRWD_TRSF_SD)||(JLY_MODEL==_7_WD_GZ100K_TRWD_TRSF_SD_YL01_QY))
    if(((j==0)||(j==2)||(j==4))&&(StateC.Adc[j]<ADC_ERR_L))
      
    #elif (JLY_MODEL==_8B_WD_GZV200K_SD_YL01_TRWD_TRSF_FS_FX)
    if(((j==0)||(j==2)||(j==4))&&(StateC.Adc[j]<ADC_ERR_L))
      
    #elif (JLY_MODEL==_4_WD_SD_CO2_5000_GZ200K)
    if(((j==0)||(j==1)||(j==2))&&(StateC.Adc[j]<ADC_ERR_L))
      
    #elif ((JLY_MODEL==_4_WD_SD_CO2TTL5000_GZ200K)||(JLY_MODEL==_3_WD_SD_CO2TTL10000))
    if(((j==0)||(j==1))&&(StateC.Adc[j]<ADC_ERR_L))
      
    #elif (JLY_MODEL==_6_WD_SD_CO2TTL5000_GZ200K_WD_TRSF)   
    if(((j==0)||(j==1)||(j==4)||(j==5))&&(StateC.Adc[j]<ADC_ERR_L))  
      
    #elif ((JLY_MODEL==_6_2NTC_2HIH_2GZ100K)||(JLY_MODEL==_5_2WD_2SD_GZ200K))
    if((j<4)&&(StateC.Adc[j]<ADC_ERR_L))
      
    #elif ((JLY_MODEL==_4_WD_SD_WD_GZ200K)||(JLY_MODEL==_5_WD_SD_WD_GZ200K_CO2TTL5000))
    if(((j==0)||(j==1)||(j==2))&&(StateC.Adc[j]<ADC_ERR_L))  
      
    #elif (JLY_MODEL==_8_NTC_HIH_CO2TTL5000_GZ200K_QY_NH3_H2S_CH4)// NH3.H2S 0.6~3V   CH4 0.4~2V
    if(((j==0)||(j==1)||(j==5)||(j==6)||(j==7))&&(StateC.Adc[j]<ADC_ERR_L))
      
    #elif (JLY_MODEL==_8_3NTC_3HIH5030_1HIH6130)
    if((j<=5)&&(StateC.Adc[j]<ADC_ERR_L))
      
    #elif ((JLY_MODEL==_2_NTC_HIH6130)||(JLY_MODEL==_2_wdNTC_sdSHT30))
    if((j<1)&&(StateC.Adc[j]<ADC_ERR_L))

      
    #elif (JLY_MODEL==_3_WD_TRSF_GZ200K)  
    if(((j==0)||(j==1))&&(StateC.Adc[j]<ADC_ERR_L)) 
      
    #elif (JLY_MODEL==_5_WD_TRSF_GZ200K_WD_SD)   
    if(((j==0)||(j==1)||(j==3)||(j==4))&&(StateC.Adc[j]<ADC_ERR_L)) 
      
    #elif (JLY_MODEL==_7_WD_SD_WD_GZ200K_CO2TTL5000_2WD)
    if(((j==0)||(j==1)||(j==2)||(j==5)||(j==6))&&(StateC.Adc[j]<ADC_ERR_L))  
      
    #elif ((JLY_MODEL==_3_NTC_HIH_CO2TTL20BF)||(JLY_MODEL==_3_NTC_HIH_CO2TTL10BF))   
    if(((j==0)||(j==1))&&(StateC.Adc[j]<ADC_ERR_L))  
      
    //土壤水分，没有NULL,用0
    #elif (JLY_MODEL==_3B_WD_GZ100K_TRSF)
    if((j==0)&&(StateC.Adc[j]<ADC_ERR_L))
      
    //土壤水分1、蒸发3 0-2v 没有NULL ，用0
    #elif (JLY_MODEL==_4_TRWD_TRSF_TYFS_ZF)
    if(((j==0)||(j==2))&&(StateC.Adc[j]<ADC_ERR_L))
      
    //通道2跟随通道1，如果通道1是NULL,通道2 也是NULL
    #elif (JLY_MODEL==_2_SW_30m_SHD_20m)
    if(((j==0)&&(StateC.Adc[j]<ADC_ERR_L))||((j==1)&&(StateC.Value[0]==SENIOR_NULL)))
      
      
    #else  //其他
        #if OPT_EN==1
          if(StateC.Adc[j]<ADC_ERR_L)
        #else
          if((!(_T_TRSF==*((char*)CH1_T_ADDR+j*ONE_CH_CONFIG_BYTES)))&&(StateC.Adc[j]<ADC_ERR_L))//土壤水分，没有NULL,用0代替
        #endif
    #endif
      
    {
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
        
        StateC.Value[j]=SENIOR_NULL;
        StateC.FuhaoBit&=~(1<<j);
        
        #if DIGITAL_FILTER_EN==1
        FilterChClr(j);//对应通道数字滤波变量清0
        #endif
    }
    else
    {
      //TTL UART 数字信号，获取ADC, 可再滤波-----------------------------------------------------------------
      #if (JLY_MODEL==_1_CO2_TTL_5000)//数字信号，充当ADC
      if(j==0)
      {
          if(StateC.sen_Pt>=SEN_REC_TIME)//超时，说明传感器未接
          {
              StateC.Value[j]=SENIOR_NULL;
              StateC.FuhaoBit&=~(1<<j);
              
              #if DIGITAL_FILTER_EN==1
              FilterChClr(j);//对应通道数字滤波变量清0
              #endif
              
              continue;
          }
          else
          {
            StateC.Adc[j]=StateC.sen_vv;
          }
      }
      
      #elif (JLY_MODEL==_2_O2_CO2_TTL_5000)
      if(j==1)
      {
          if(StateC.sen_Pt>=SEN_REC_TIME)//超时，说明传感器未接
          {
              StateC.Value[j]=SENIOR_NULL;
              StateC.FuhaoBit&=~(1<<j);
              
              #if DIGITAL_FILTER_EN==1
              FilterChClr(j);//对应通道数字滤波变量清0
              #endif
              
              continue;
          }
          else
          {
            StateC.Adc[j]=StateC.sen_vv;
          }
      }
      
      
      #elif ((JLY_MODEL==_2_LS_SS)||(JLY_MODEL==_4_2LS_2SS))


          if(StateC.sen_spt[j/2]>=SEN_REC_TIME)//超时，说明传感器未接
          {
              StateC.Value[j]=SENIOR_NULL;
              StateC.FuhaoBit&=~(1<<j);
              
              #if DIGITAL_FILTER_EN==1
              FilterChClr(j);//对应通道数字滤波变量清0
              #endif
              
              continue;
          }
          else
          {
              StateC.Adc[j]=StateC.sen_vbuf[j];
          }
      
      
      #elif ((JLY_MODEL==_4_WD_SD_CO2TTL5000_GZ200K)||(JLY_MODEL==_6_WD_SD_CO2TTL5000_GZ200K_WD_TRSF)||(JLY_MODEL==_3_WD_SD_CO2TTL10000))
        if(j==2)
        {
          if(StateC.sen_Pt>=SEN_REC_TIME)//超时，说明传感器未接
          {
              StateC.Value[j]=SENIOR_NULL;
              StateC.FuhaoBit&=~(1<<j);
              
              #if DIGITAL_FILTER_EN==1
              FilterChClr(j);//对应通道数字滤波变量清0
              #endif
              
              continue;
          }
          else
          {
            StateC.Adc[j]=StateC.sen_vv;
          }
        }
      
      
      #elif  (JLY_MODEL==_8_NTC_HIH_CO2TTL5000_GZ200K_QY_NH3_H2S_CH4)
        if(j==2)
        {
          if(StateC.sen_Pt>=SEN_REC_TIME)//超时，说明传感器未接
          {
              StateC.Value[j]=SENIOR_NULL;
              StateC.FuhaoBit&=~(1<<j);
              
              #if DIGITAL_FILTER_EN==1
              FilterChClr(j);//对应通道数字滤波变量清0
              #endif
              
              continue;
          }
          else
          {
            StateC.Adc[j]=StateC.sen_vv;
          }
        }

        else if(j==4)//大气压   最新  zz
        {
                
              u8 vvok=0;
              
              u16 CC;
              CC=shr1000ReadPressure();
                
              if((CC<=3000)||(CC>=12000)||(CC==SENIOR_NULL))
              {
                   if(Pt.QYpt<SEN_NULL_CT)//多次连续出错才判断为 NULL
                     Pt.QYpt++;
                   else
                   {
                      StateC.Value[j]=SENIOR_NULL;
                      #if DIGITAL_FILTER_EN==1
                      FilterChClr(j);//对应通道数字滤波变量清0
                      #endif
                   }
    
              }
              else
              {
                  StateC.Adc[j]=CC;
                  Pt.QYpt=0;
                  vvok=1;
              }
              
              if(vvok==0)//后面不进入
                 continue ;
          
        }

      
      #elif ((JLY_MODEL==_5_WD_SD_WD_GZ200K_CO2TTL5000)||(JLY_MODEL==_7_WD_SD_WD_GZ200K_CO2TTL5000_2WD))
        if(j==4)
        {
              if(StateC.sen_Pt>=SEN_REC_TIME)//超时，说明传感器未接
              {
                  StateC.Value[j]=SENIOR_NULL;
                  StateC.FuhaoBit&=~(1<<j);
                  
                  #if DIGITAL_FILTER_EN==1
                  FilterChClr(j);//对应通道数字滤波变量清0
                  #endif
                  
                  continue;
              }
              else
              {
                  StateC.Adc[j]=StateC.sen_vv;
              }
        }
      
      #elif ((JLY_MODEL==_3_NTC_HIH_CO2TTL20BF)||(JLY_MODEL==_3_NTC_HIH_CO2TTL10BF))
      if(j==2)
      {
          if(StateC.sen_Pt>=SEN_REC_TIME)//超时，说明传感器未接
          {
              StateC.Value[j]=SENIOR_NULL;
              StateC.FuhaoBit&=~(1<<j);
              
              #if DIGITAL_FILTER_EN==1
              FilterChClr(j);//对应通道数字滤波变量清0
              #endif
              
              continue;
          }
          else
          {
            StateC.Adc[j]=StateC.sen_vv/10;// 60 ->0.01% ,故 除10即 转为单位0.01%
          }
      }
      #elif (JLY_MODEL==_1_CO2_TTL_20BF)
      if(j==0)
      {
          if(StateC.sen_Pt>=SEN_REC_TIME)//超时，说明传感器未接
          {
              StateC.Value[j]=SENIOR_NULL;
              StateC.FuhaoBit&=~(1<<j);
              
              #if DIGITAL_FILTER_EN==1
              FilterChClr(j);//对应通道数字滤波变量清0
              #endif
              
              continue;
          }
          else
          {
            StateC.Adc[j]=StateC.sen_vv/10;// 60 ->0.01% ,故 除10即 转为单位0.01%
          }
      }
      
      //甲醛TTL
      #elif (JLY_MODEL==_1_HCH2O_TTL_0_373)
      if(j==0)
      {
          if(StateC.sen_Pt>=SEN_REC_TIME)//超时，说明传感器未接
          {
              StateC.Value[j]=SENIOR_NULL;
              StateC.FuhaoBit&=~(1<<j);
              
              #if DIGITAL_FILTER_EN==1
              FilterChClr(j);//对应通道数字滤波变量清0
              #endif
              
              continue;
          }
          else
          {
            StateC.Adc[j]=StateC.sen_vv;// 传感器正常
          }
      }
      

      
      //PM2.5 TTL
      #elif ((JLY_MODEL==_1_PM25_TTL_1000)||(JLY_MODEL==_2_PM25_TTL1000_CO2_MISIR_5000))
      if(j==0)
      {
          if(StateC.sen_Pt>=SEN_REC_TIME)//超时，说明传感器未接
          {
              StateC.Value[j]=SENIOR_NULL;
              StateC.FuhaoBit&=~(1<<j);
              
              #if DIGITAL_FILTER_EN==1
              FilterChClr(j);//对应通道数字滤波变量清0
              #endif
              
              continue;
          }
          else
          {
            StateC.Adc[j]=StateC.sen_vv;// 传感器正常
          }
      }
      
      #elif (JLY_MODEL==_1_PM25_PWM_1000)
      if(j==0)
      {
          if(Pt.pwm_V==0)
          {
            continue;
          }
          else
          {
            if(++Pt.pwm_pt>3)//6s一个，1分钟10个，6分钟达到60个；而传感器36s一次新数据，6分钟刚好10个值
            {
               Pt.pwm_pt=0;
               if(Pt.pwm_V>1000)//没有外电时，会一直最大值
               {
                 StateC.Value[j]=SENIOR_NULL;
                 continue;
               }
               else
               {
                 StateC.Adc[j]=Pt.pwm_V;
               }
               
            }
            else
            {
              continue;
            }
          }
          
          

      }
      
      //散射辐射 mV= (2500*ADC/4096)/100=0.006103516*ADC  ;  VALUE= mV*1000/9.045=0.67479447*ADC   //9.045为传感器检验结果中的灵敏度
      #elif (JLY_MODEL==_1_SSFS_0_2000)
      if(j==0)
      {
         // 计算Vout
         float ft;
         ft=0.67479447*StateC.Adc[j];
         StateC.Adc[j]=(u16)ft;// 传感器正常
         NOP;
      }
      
      //pm2.5  v
      #elif (JLY_MODEL==_1_PM25_V_1000)
      if(j==0)
      {
         // 计算Vout
         float ft;
         ft=0.61035156*StateC.Adc[j];
         StateC.Adc[j]=(u16)ft;// 传感器正常
         NOP;
      }
      
      #elif (JLY_MODEL==_2_PM25_TTL1000_PM25V_1000)
      if(j==0)
      {
          if(StateC.sen_Pt>=SEN_REC_TIME)//超时，说明传感器未接
          {
              StateC.Value[j]=SENIOR_NULL;
              StateC.FuhaoBit&=~(1<<j);
              
              #if DIGITAL_FILTER_EN==1
              FilterChClr(j);//对应通道数字滤波变量清0
              #endif
              
              continue;
          }
          else
          {
            StateC.Adc[j]=StateC.sen_vv;// 传感器正常
          }
      }
      else if(j==1)
      {
         // 计算Vout
         float ft;
         ft=0.61035156*StateC.Adc[j];
         StateC.Adc[j]=(u16)ft;// 传感器正常
      }
      
      #elif (JLY_MODEL==_2_NTC_HIH6130)
      u8 vvok=0;
      if(j==1)//HIH6130只取湿度
      {
            CC=GetHIH613X(TH);
            if(CC==SENIOR_NULL)
            {
                if(Pt.wd_pt<SEN_NULL_CT)
                  Pt.wd_pt++;
                else//连续次数据出错，才判断传感器故障 NULL
                {
                  StateC.Value[j]=SENIOR_NULL;//湿度
                }
            }
            else
            {
                if((TH[1]>=0)&&(TH[1]<=1000)&&(CC!=SENIOR_NULL))
                {
                  vvok=1;
                  StateC.Adc[j]=TH[1];
                  Pt.wd_pt=0;
                }
                
            }
      }

      
      if((j==1))
      {
        if(vvok==0)//后面不进入
          continue ;
      }
      
      

      
      
      
      #elif (JLY_MODEL==_2_wdNTC_sdSHT30)
      u8 vvok=0;
      if(j==1)//SHT30只取湿度
      {
            CC=GetSHT30(TH);
            if(CC==SENIOR_NULL)
            {
                if(Pt.wd_pt<SEN_NULL_CT)
                  Pt.wd_pt++;
                else//连续次数据出错，才判断传感器故障 NULL
                {
                  StateC.Value[j]=SENIOR_NULL;//湿度
                }
            }
            else
            {
                if((TH[1]>=0)&&(TH[1]<=1000)&&(CC!=SENIOR_NULL))
                {
                  vvok=1;
                  StateC.Adc[j]=TH[1];
                  Pt.wd_pt=0;
                }
                
            }
      }

      
      if((j==1))
      {
        if(vvok==0)//后面不进入
          continue ;
      }
      
      #elif (JLY_MODEL==_8_3NTC_3HIH5030_1HIH6130)
      u8 vvok=0;
      if(j==6)
      {
        CC=GetHIH613X(TH);
        if(CC==SENIOR_NULL)
        {
              if(Pt.wd_pt<SEN_NULL_CT)
                Pt.wd_pt++;
              else//连续次数据出错，才判断传感器故障 NULL
              {
                StateC.Value[j]=SENIOR_NULL;//温度
              }
            }
            else
            {
                if((TH[0]>=-400)&&(TH[0]<=1000))
                {
                    vvok=1;
                    StateC.Adc[j]=TH[0]+400;
                    Pt.wd_pt=0;
                }
            }
      }
      else if(j==7)
      {

            //温湿度同时测量的，所以湿度跟随温度,NULL
            if(StateC.Value[j-1]==SENIOR_NULL)
            {
              StateC.Value[j]=SENIOR_NULL;
            }
            else
            {
              
                if((TH[1]>=0)&&(TH[1]<=1000)&&(CC!=SENIOR_NULL))
                {
                  vvok=1;
                  StateC.Adc[j]=TH[1];
                }
            }

      }
      
      if((j==6)||(j==7))
      {
        if(vvok==0)//后面不进入
          continue ;
      }
      
      
      #elif ((JLY_MODEL==_2_WDHIH6130_SDHIH6130)||(JLY_MODEL==_2_wdSHT30_sdSHT30))
      u8 vvok=0;
      if(j==0)
      {

          #if (JLY_MODEL==_2_wdSHT30_sdSHT30)
            CC=GetSHT30(TH);
          #elif (JLY_MODEL==_2_WDHIH6130_SDHIH6130)
            CC=GetHIH613X(TH);
          #endif
            
          if(CC==SENIOR_NULL)
          {
            if(Pt.wd_pt<SEN_NULL_CT)
              Pt.wd_pt++;
            else//连续次数据出错，才判断传感器故障 NULL
              StateC.Value[j]=SENIOR_NULL;//温度
          }
          else
          {
                  if((TH[0]>=-400)&&(TH[0]<=1000))
                  {
                      vvok=1;
                      StateC.Adc[j]=TH[0]+400;
                      Pt.wd_pt=0;
                  }
            
          }
      }
      else if(j==1)
      {
        //温湿度同时测量的，所以湿度跟随温度,NULL
        if(StateC.Value[j-1]==SENIOR_NULL)
        {
          StateC.Value[j]=SENIOR_NULL;
        }
        else
        {
                if((TH[1]>=0)&&(TH[1]<=1000)&&(CC!=SENIOR_NULL))
                {
                  vvok=1;
                  StateC.Adc[j]=TH[1];
                }
          
        }
      }
      
      if(vvok==0)//后面不进入
        continue ;
      
      
      //温湿度数字信号，可以滤波
      #elif (JLY_MODEL==_2_WDHTU_SDHTU)
      u8 vvok=0;
      u8 FuhaoHigh=0;
      if(j==0)
      {
        //温度
        u16 wdvv;
        wdvv=HtuMeasure(0,FuhaoHigh);
        if(wdvv==SENIOR_NULL)
        {
          if(Pt.wd_pt<SEN_NULL_CT)
            Pt.wd_pt++;
          else//连续次数据出错，才判断传感器故障 NULL
            StateC.Value[j]=SENIOR_NULL;//温度
        }
        else
        {
          Pt.wd_pt=0;
          vvok=1;
          
          if(FuhaoHigh==1)
          {
            StateC.Adc[j]=400-wdvv;//温度
          }
          else
          {
            StateC.Adc[j]=400+wdvv;//温度
          }
        }
      }
      else if(j==1)
      {
        //湿度
        u16 sdvv;
        sdvv=HtuMeasure(1,FuhaoHigh);
        if(sdvv==SENIOR_NULL)
        {
          if(Pt.sht_pt<SEN_NULL_CT)
            Pt.sht_pt++;
          else
            StateC.Value[j]=SENIOR_NULL;

        }
        else
        {
          Pt.sht_pt=0;
          vvok=1;
          StateC.Adc[j]=sdvv;
        }
      }
      
      if(vvok==0)//后面不进入
        continue ;
      

      #elif  ((PT_MAX31865_EN==1)&&((JLY_MODEL==_1_RTD_F200_300)||(JLY_MODEL==_4_RTD_F200_300)))
       
            //从 Pt.t_temp[] ,读取最新数据
            u8 vvok=0;
            if(Pt.t_temp[j]==SENIOR_NULL)
            {
                if(Pt.t_pt[j]<SEN_NULL_CT)
                  Pt.t_pt[j]++;
                else
                  StateC.Value[j]=SENIOR_NULL;
            }
            else
            {
                vvok=1;
                Pt.t_pt[j]=0;
                StateC.real_adc[j]=StateC.Adc[j]=2000+Pt.t_temp[j];//真实AD
            }
            
            if(vvok==0)//后面不进入
              continue ;
        
      #elif ((JLY_MODEL==_1_K_F200_1350)||(JLY_MODEL==_3_K_F200_1350))
        if((j==0)||(j==1)||(j==2))
        {
            u8 vvok=0;
            int out[2];
            Get_K_Temp(out,j);
            
            if(Pt.t_temp[j]==SENIOR_NULL)
            {
                if(Pt.k_pt[j]<SEN_NULL_CT)
                  Pt.k_pt[j]++;
                else
                  StateC.Value[j]=SENIOR_NULL;
            }
            else
            {
                vvok=1;
                Pt.k_pt[j]=0;
                StateC.real_adc[j]=StateC.Adc[j]=2000+Pt.t_temp[j];//真实AD
            }
            
            if(vvok==0)//后面不进入
              continue ;

        }
      
      #elif (JLY_MODEL==_2_K_F200_1350_COLD)//max31855 热电偶 热端温度+ 内置冷端温度
        if(j==0)
        {
            u8 vvok=0;
            int out[2];
            Get_K_Temp(out,j);
            if(out[0]==SENIOR_NULL)
            {
                if(Pt.k_pt[j]<SEN_NULL_CT)
                  Pt.k_pt[j]++;
                else
                  StateC.Value[j]=SENIOR_NULL;
            }
            else
            {
                vvok=1;
                Pt.k_pt[j]=0;
                StateC.real_adc[j]=StateC.Adc[j]=2000+out[0];//真实AD
            }
            
            if(vvok==0)//后面不进入
              continue ;

        }
        else
        {
          //通道2，退出
          break;
        }
      #elif (JLY_MODEL==_2_DS18B20_HIH)  
          if(j==0)
          {
              Flag.SampPt=2;//采样结束，开始计算物理值
            
            
              u8 vvok=0;
              int vv;
              vv=OneChData(j);
              if(vv==20000)//传感器错误
              {
                if(Pt.ow_pt[j]<SEN_NULL_CT)
                  Pt.ow_pt[j]++;
                else
                  StateC.Value[j]=SENIOR_NULL;
              }
              else
              {
                vvok=1;
                Pt.ow_pt[j]=0;
                StateC.real_adc[j]=StateC.Adc[j]=550+vv;//真实AD
              }
              
              if(vvok==0)//后面不进入
                continue ;
          }
          else if(j==1)//湿度
          {
              StateC.Adc[j]=GetHumiValue(StateC.Adc[j],j-1);
              
              if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
              {
                if(Pt.ErrCt<ERR_NUM)
                  continue;
                Pt.ErrCt=0;
              }
              
              StateC.real_adc[j]=StateC.Adc[j];//真实AD
          }
        
      //数字温度18B20
      #elif ((JLY_MODEL==_6_DS18B20_F55_125)||(JLY_MODEL==_8_DS18B20_F55_125)||(JLY_MODEL==_1_DS18B20_F55_125)||(JLY_MODEL==_2_DS18B20_F55_125)\
        ||(JLY_MODEL==_4_DS18B20_F55_125)||(JLY_MODEL==_3_DS18B20_F55_125))
        
          if(j==(CH_NUM-1))
          {
            Flag.SampPt=2;//采样结束，开始计算物理值
          }
          
          u8 vvok=0;
          int vv;
          vv=OneChData(j);
          if(vv==20000)//传感器错误
          {
            if(Pt.ow_pt[j]<SEN_NULL_CT)
              Pt.ow_pt[j]++;
            else
              StateC.Value[j]=SENIOR_NULL;
          }
          else
          {
            vvok=1;
            Pt.ow_pt[j]=0;
            StateC.real_adc[j]=StateC.Adc[j]=550+vv;//真实AD
          }
          
          if(vvok==0)//后面不进入
            continue ;
          
      #elif (JLY_MODEL==_2_K_F200_1350_DS_F55_125)     
        if(j==0)
        {
            u8 vvok=0;
            int out[2];
            Get_K_Temp(out,j);
            if(out[0]==SENIOR_NULL)
            {
                if(Pt.k_pt[j]<SEN_NULL_CT)
                  Pt.k_pt[j]++;
                else
                  StateC.Value[j]=SENIOR_NULL;
            }
            else
            {
                vvok=1;
                Pt.k_pt[j]=0;
                StateC.real_adc[j]=StateC.Adc[j]=2000+out[0];//真实AD
            }
            
            if(vvok==0)//后面不进入
              continue ;
        }
        else if(j==1)
        {
            if(j==(CH_NUM-1))
            {
              Flag.SampPt=2;//采样结束，开始计算物理值
            }
            
            u8 vvok=0;
            int vv;
            vv=OneChData(j);
            if(vv==20000)//传感器错误
            {
              if(Pt.ow_pt[j]<SEN_NULL_CT)
                Pt.ow_pt[j]++;
              else
                StateC.Value[j]=SENIOR_NULL;
            }
            else
            {
              vvok=1;
              Pt.ow_pt[j]=0;
              StateC.real_adc[j]=StateC.Adc[j]=550+vv;//真实AD
            }
            
            if(vvok==0)//后面不进入
              continue ;
        }
          
      #endif
      
      //滤波-滤波-滤波-滤波-滤波-滤波-滤波-滤波-滤波-滤波-滤波-滤波-滤波-滤波-滤波-滤波-------------------

        
      #if DIGITAL_FILTER_EN==1//滤波
      GetChFilterAd(j);
      #endif

      StateC.real_adc[j]=StateC.Adc[j];
         
      NOP;
      //开始转换ADC--------------------------------------------------------------------------------------

      //湿度
      #if ((JLY_MODEL==_2_NTC_HIH5030)||(JLY_MODEL==_4_2NTC_2HIH5030)||(JLY_MODEL==_6_1PT_F40_100_1HIH_2NTC_2HIH)\
           ||(JLY_MODEL==_6_3NTC_3HIH5030)||(JLY_MODEL==_8_4NTC_4HIH5030)||(JLY_MODEL==_3_1NTC_1HIH_1PT_F40_100)\
             ||(JLY_MODEL==_5_2NTC_2HIH_CO2_Z14_5000)||(JLY_MODEL==_7_3NTC_3HIH_CO2_Z14_5000)\
               ||(JLY_MODEL==_5_2NTC_2HIH_CO2_MISIR_5000)||(JLY_MODEL==_7_3NTC_3HIH_CO2_MISIR_5000))
      if(j==1||j==3||j==5||j==7)//通道2：湿度
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],j-1);
        
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      

      
      #elif (JLY_MODEL==_8_3NTC_3HIH5030_1HIH6130)
      if(j==1||j==3||j==5)//通道2：湿度
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],j-1);
        
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }

      
      
      #elif (JLY_MODEL==_8_3NTC_3HIH_2NTC)
      if(j==1||j==3||j==5)//通道2：湿度
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],j-1);
        
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      
      #elif ((JLY_MODEL==_4_1NTC_1HIH_2NTC)||(JLY_MODEL==_6_1NTC_1HIH_4NTC))
      if(j==1)//通道2：湿度
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],j-1);
        
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
        
      #elif (JLY_MODEL==_4_2PT_F50_250_2HIH)
      if(j>1)//湿度
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
        
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      
      #elif (JLY_MODEL==_3_2PT_0_300_1HIH)
      if(j==2)//湿度
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
        
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      
      #elif (JLY_MODEL==_4_1PT_F100_200_2NTC_1HIH)
      if(j==3)
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
        
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      
      #elif ((JLY_MODEL==_2_1PT_F100_200_1HIH)||(JLY_MODEL==_2_1PT_F100_100_1HIH)||(JLY_MODEL==_4_2PTH_2HIH)||(JLY_MODEL==_2_1PT_F50_250_1HIH)\
               ||(JLY_MODEL==_4_2PT_F50_100_2HIH)||(JLY_MODEL==_2_1PT_0_300_1HIH)||(JLY_MODEL==_4_2PT_F50_200_2HIH)\
                 ||(JLY_MODEL==_2_1PT_F50_200_1HIH)||(JLY_MODEL==_2_1PT_F40_150_1HIH)||(JLY_MODEL==_2_1PT_F200_100_1HIH))
      if(j==1||j==3||j==5||j==7)//通道2：湿度
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
        
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误  zz  湿度最低1
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      #elif (JLY_MODEL==_3_WD_SD_GH400_10umol)
      if(j==1)//通道2：湿度
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);//注意：不用温度补偿
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      #elif (JLY_MODEL==_7_4NTC_2TRSF_1HIH)
      if(j==6)//湿度
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);//注意：不用温度补偿
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      #elif (JLY_MODEL==_6_4NTC_1HIH_1TRSF)
      if(j==4)//湿度
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);//注意：不用温度补偿
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      
      #elif (JLY_MODEL==_8_4NTC_2HIH_2TRSF)
      if(j==1||j==3)//通道2：湿度
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);//注意：不用温度补偿
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      #elif (JLY_MODEL==_6_1NTC_1HIH_2NTC_2TRSF)
      if(j==1)//通道2：湿度
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);//注意：不用温度补偿
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      #elif (JLY_MODEL==_6_4NTC_2HIH5030)
      if(j==4||j==5)//通道2：湿度
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);//注意：不用温度补偿
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      #elif ((JLY_MODEL==_4_NTC_HIH_NTC_TRSF)||(JLY_MODEL==_3_NTC_HIH_TRSF))
      if(j==1)//通道2：湿度
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      

      
      #elif (JLY_MODEL==_8_6NTC_2HIH)
      if((j==6)||(j==7))
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      #elif (JLY_MODEL==_8_5NTC_3HIH)
      if((j==5)||(j==6)||(j==7))
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      
      #elif (JLY_MODEL==_8_5NTC_HIH_NTC_HIH)
      if((j==5)||(j==7))
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      
      
      #elif (JLY_MODEL==_4_3NTC_1HIH)
      if(j==3)
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      
      #elif (JLY_MODEL==_3_2_NTC_1HIH)
      if(j==2)
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      #elif (JLY_MODEL==_3_2NTC_1HIH)
      if(j==1)
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      #elif (JLY_MODEL==_6_5NTC_1HIH)
      if(j==5)
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      #elif (JLY_MODEL==_8_134678NTC_25HIH)
      if((j==1)||(j==4))
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      
      
      #elif (JLY_MODEL==_8_7NTC_1HIH)
      if(j==7)
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      #elif (JLY_MODEL==_7_6NTC_1HIH)
      if(j==6)
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      
      #elif (JLY_MODEL==_5_4NTC_1HIH)
      if(j==4)
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      #elif ((JLY_MODEL==_1_HIH5030)||(JLY_MODEL==_2_HIH5030)||(JLY_MODEL==_4_HIH5030)||(JLY_MODEL==_6_HIH5030)||(JLY_MODEL==_8_HIH5030))

        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD

     #elif (JLY_MODEL==_6_3PT_0_300_3HIH)  
      if(j>2)
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      
      #elif ((JLY_MODEL==_4_2PT_F40_100_2HIH)||(JLY_MODEL==_4_2PT_F100_200_2HIH)||(JLY_MODEL==_4_2PT_F200_100_2HIH))
      if((j%2)==1)
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      
      
      #elif ((JLY_MODEL==_8_4PT_0_300_4HIH)||(JLY_MODEL==_8_4PT_F40_100_4HIH)||(JLY_MODEL==_8_4PT_F100_200_4HIH)||(JLY_MODEL==_8_4PT_F100_300_4HIH))
      if(j>3)
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      #elif (JLY_MODEL==_6_2PT_2ROTYONIC_NTC_HIH)
      if(j==5)
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
         
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      
      //EC5
      #elif (JLY_MODEL==_6_3NTC_3EC5)
      if(j==1||j==3||j==5)//通道2：EC5
      {
        float ft;
        ft=StateC.Adc[j];
        ft=(ft*2.5)/4096;//电压值
        
        ft=ft*115.5-51.2;//电压值转换成土壤水分
        ft=ft*10;
        StateC.Adc[j]=(u16)ft;
        
        
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      
      
      //库门开关
      #elif (JLY_MODEL==_1_DOOR)
      P5DIR&=~BIT0;
      if(j==0)
      {
        if(P5IN&BIT0)//关
        {
          StateC.Value[j]=0;
        }
        else//开， 报警
        {
          StateC.Value[j]=1000;
        }
        continue;
      }
      
     
      #elif (JLY_MODEL==_1_SMOKE)

      if(j==0)
      {
              P5DIR&=~BIT0;
              if(P5IN&BIT0)//开路
              { 
                  StateC.Value[j]=0;
              }
              else//闭路，有报警
              {
                  StateC.Value[j]=1000;
  
              }
              continue;
      }

      

     
      //co2------------------------------------------------------------
      #elif ((JLY_MODEL==_1_CO2_5000PPM)||(JLY_MODEL==_2_CO2_5000PPM)) //co2=(ad/4096)*500;  
        float ft;
        ft=StateC.Adc[j];
        ft=(ft/4096)*500;
        StateC.Adc[j]=(u16)(ft*10);
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      #elif (JLY_MODEL==_1_CO2_2000PPM) //co2=(ad/4096)*200;  
        float ft;
        ft=StateC.Adc[j];
        ft=(ft/4096)*200;
        StateC.Adc[j]=(u16)(ft*10);
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      #elif (JLY_MODEL==_2_CO2_5000PPM_O2)  
        if(j==0)
        {
          float ft;
          ft=StateC.Adc[j];
          ft=(ft/4096)*500;
          StateC.Adc[j]=(u16)(ft*10);
          StateC.real_adc[j]=StateC.Adc[j];//真实AD          
        }  
      #elif (JLY_MODEL==_3_NTC_HIH_CO2_5000PPM)
        if(j==2)
        {
          float ft;
          ft=StateC.Adc[j];
          ft=(ft/4096)*500;
          StateC.Adc[j]=(u16)(ft*10);
          StateC.real_adc[j]=StateC.Adc[j];//真实AD          
        }
        else if(j==1)
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        
      #elif (JLY_MODEL==_2_CO2_5000PPM_SD) 
        if(j==0)
        {
          float ft;
          ft=StateC.Adc[j];
          ft=(ft/4096)*500;
          StateC.Adc[j]=(u16)(ft*10);
          StateC.real_adc[j]=StateC.Adc[j];//真实AD          
        }
        else if(j==1)
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],99);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
      #elif (JLY_MODEL==_2_CO2_2000_NTC)    
        if(j==0)
        {
          float ft;
          ft=StateC.Adc[j];
          ft=(ft/4096)*200;
          StateC.Adc[j]=(u16)(ft*10);
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
      #elif (JLY_MODEL==_1_CO2_0_5) //co2=(ad/4096)*500;  
        float ft;
        ft=StateC.Adc[j];
        ft=(ft/4096)*5;
        StateC.Adc[j]=(u16)(ft*100);
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
        
       //数字绝压---------------------------------------------------------------
       #elif (JLY_MODEL==_1_SHR_30_120_kpa)
        
        StateC.Adc[j]=shr1000ReadPressure();
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
        if(StateC.Adc[j]<3000)//错误不稳定时，取平均数
        {
          StateC.Value[j]=StateC.avg[j];
          continue;
        }
        else if(StateC.Adc[j]==SENIOR_NULL)//错误
        {
          StateC.Value[j]=SENIOR_NULL;
          continue;
        }
        

        
        
        //雨量-------------------------------------------------------------------------------
      #elif (JLY_MODEL==_2_NTC_01YL)  
      if(j==1)
      {
        continue;
      }
        
      #elif (JLY_MODEL==_3_NTC_HIH5030_01YL)
      if(j==1)//通道2：湿度
      {
        StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
        
        if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
        {
          if(Pt.ErrCt<ERR_NUM)
            continue;
          Pt.ErrCt=0;
        }
        
        StateC.real_adc[j]=StateC.Adc[j];//真实AD
      }
      else if(j==2)
      {
        continue;
      }
        
        //光照------------------------------------------------------------------
       #elif ((JLY_MODEL==_1_GZ_65K)||(JLY_MODEL==_1_GZ_100K)||(JLY_MODEL==_1_GZ_200K))
           u16 j=0;
           
           if(Pt.GzNoRe==1)//传感器无响应
           {
             StateC.Value[j]=SENIOR_NULL;
             continue;
           }
           else
           {
               StateC.Adc[j]=LxRead();//实际光照强度值
               if(Pt.GzNoRe==1)//传感器无响应
               {
                 StateC.Value[j]=SENIOR_NULL;
                 continue;
               }
               StateC.Adc[j]=GzEnlarge(StateC.Adc[j]);
               StateC.real_adc[j]=StateC.Adc[j];//真实AD
           }

        #elif ((JLY_MODEL==_1_GZ_100LX)||(JLY_MODEL==_1_GZ_1000LX))
           u16 j=0;
           
           if(Pt.GzNoRe==1)//传感器无响应
           {
             StateC.Value[j]=SENIOR_NULL;
             continue;
           }
           else
           {
               StateC.Adc[j]=LxRead();//实际光照强度值，10倍，1位小数
               if(Pt.GzNoRe==1)//传感器无响应
               {
                 StateC.Value[j]=SENIOR_NULL;
                 continue;
               }
               StateC.real_adc[j]=StateC.Adc[j];
           }
           
           
        #elif ((JLY_MODEL==_2_WD_GZ100K)||(JLY_MODEL==_2_WD_GZ200K))
        if(j==1)//光照
        {
           if(Pt.GzNoRe==1)//传感器无响应
           {
             StateC.Value[j]=SENIOR_NULL;
             continue;
           }
           else
           {
               StateC.Adc[j]=LxRead();//实际光照强度值
               if(Pt.GzNoRe==1)//传感器无响应
               {
                 StateC.Value[j]=SENIOR_NULL;
                 continue;
               }
               StateC.Adc[j]=GzEnlarge(StateC.Adc[j]);
               StateC.real_adc[j]=StateC.Adc[j];//真实AD
           }
        }
           
        #elif ((JLY_MODEL==_3_WD_SD_GZ100K)||(JLY_MODEL==_3_WD_SD_GZ200K))
        if(j==1)//湿度
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        else if(j==2)//光照
        {
           if(Pt.GzNoRe==1)//传感器无响应
           {
             StateC.Value[j]=SENIOR_NULL;
             continue;
           }
           else
           {
               StateC.Adc[j]=LxRead();//实际光照强度值
               if(Pt.GzNoRe==1)//传感器无响应
               {
                 StateC.Value[j]=SENIOR_NULL;
                 continue;
               }
               StateC.Adc[j]=GzEnlarge(StateC.Adc[j]);
               StateC.real_adc[j]=StateC.Adc[j];//真实AD
           }
        }
        
        #elif (JLY_MODEL==_2_FS_FX)
        if(j==0)//风速
        {
          continue;//风速在外面处理，这里直接跳过
        }
        else if(j==1)//风向
        {
          StateC.Value[j]=GetFxValue();
          continue;
        }
        
        #elif (JLY_MODEL==_3_FS_FX_01YL)
        if(j==0)//风速
        {
          continue;//风速在外面处理，这里直接跳过
        }
        else if(j==1)//风向
        {
          StateC.Value[j]=GetFxValue();
          continue;
        }
        else if(j==2)//雨量
        {
          continue;
        }
        #elif (JLY_MODEL==_4_WD_SD_CO2_5000_GZ200K) 
        if(j==1)//湿度
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        else if(j==2)//co2
        {
          float ft;
          ft=StateC.Adc[j];
          ft=(ft/4096)*500;
          StateC.Adc[j]=(u16)(ft*10);
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        else if(j==3)
        {
           if(Pt.GzNoRe==1)//传感器无响应
           {
             StateC.Value[j]=SENIOR_NULL;
             continue;
           }
           else
           {
               StateC.Adc[j]=LxRead();//实际光照强度值
               if(Pt.GzNoRe==1)//传感器无响应
               {
                 StateC.Value[j]=SENIOR_NULL;
                 continue;
               }
               StateC.Adc[j]=GzEnlarge(StateC.Adc[j]);
               StateC.real_adc[j]=StateC.Adc[j];//真实AD
           }
        }
        #elif (JLY_MODEL==_5_2WD_2SD_GZ200K)
        if((j==1)||(j==3))//湿度
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        else if(j==4)
        {
           if(Pt.GzNoRe==1)//传感器无响应
           {
             StateC.Value[j]=SENIOR_NULL;
             continue;
           }
           else
           {
               StateC.Adc[j]=LxRead();//实际光照强度值
               if(Pt.GzNoRe==1)//传感器无响应
               {
                 StateC.Value[j]=SENIOR_NULL;
                 continue;
               }
               StateC.Adc[j]=GzEnlarge(StateC.Adc[j]);
               StateC.real_adc[j]=StateC.Adc[j];//真实AD
           }
        }

        #elif ((JLY_MODEL==_6_2NTC_2HIH_2GZ100K))
        if((j==2)||(j==3))//湿度
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        else if(j==4)
        {
           if(Pt.GzNoRe==1)//传感器无响应
           {
             StateC.Value[j]=SENIOR_NULL;
             continue;
           }
           else
           {
               StateC.Adc[j]=LxRead();//实际光照强度值
               if(Pt.GzNoRe==1)//传感器无响应
               {
                 StateC.Value[j]=SENIOR_NULL;
                 continue;
               }
               StateC.Adc[j]=GzEnlarge(StateC.Adc[j]);
               StateC.real_adc[j]=StateC.Adc[j];//真实AD
           }
        }
        else if(j==5)//第2个照度
        {
           if(Pt.GzBHNoRe==1)//传感器无响应
           {
             StateC.Value[j]=SENIOR_NULL;
             continue;
           }
           else
           {
               StateC.Adc[j]=LxBHRead();//实际光照强度值
               if(Pt.GzBHNoRe==1)//传感器无响应
               {
                 StateC.Value[j]=SENIOR_NULL;
                 continue;
               }
               StateC.Adc[j]=GzEnlarge(StateC.Adc[j]);
               StateC.real_adc[j]=StateC.Adc[j];//真实AD
           }
        }
        
        #elif ((JLY_MODEL==_3_NTC_HIH_CO2TTL20BF)||(JLY_MODEL==_3_NTC_HIH_CO2TTL10BF))
        if(j==1)//湿度
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        
        #elif (JLY_MODEL==_5_WD_TRSF_GZ200K_WD_SD)
        if(j==2)
        {
           if(Pt.GzNoRe==1)//传感器无响应
           {
             StateC.Value[j]=SENIOR_NULL;
             continue;
           }
           else
           {
               StateC.Adc[j]=LxRead();//实际光照强度值
               if(Pt.GzNoRe==1)//传感器无响应
               {
                 StateC.Value[j]=SENIOR_NULL;
                 continue;
               }
               StateC.Adc[j]=GzEnlarge(StateC.Adc[j]);
               StateC.real_adc[j]=StateC.Adc[j];//真实AD
           }
        }
        else if(j==4)
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        #elif (JLY_MODEL==_3_WD_TRSF_GZ200K)
        if(j==2)
        {
           if(Pt.GzNoRe==1)//传感器无响应
           {
             StateC.Value[j]=SENIOR_NULL;
             continue;
           }
           else
           {
               StateC.Adc[j]=LxRead();//实际光照强度值
               if(Pt.GzNoRe==1)//传感器无响应
               {
                 StateC.Value[j]=SENIOR_NULL;
                 continue;
               }
               StateC.Adc[j]=GzEnlarge(StateC.Adc[j]);
               StateC.real_adc[j]=StateC.Adc[j];//真实AD
           }
        }
        #elif (JLY_MODEL==_3_WD_SD_CO2TTL10000)
        if(j==1)//湿度
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        
        
        #elif ((JLY_MODEL==_4_WD_SD_CO2TTL5000_GZ200K)||(JLY_MODEL==_4_WD_SD_WD_GZ200K)||(JLY_MODEL==_5_WD_SD_WD_GZ200K_CO2TTL5000)\
          ||(JLY_MODEL==_7_WD_SD_WD_GZ200K_CO2TTL5000_2WD)||(JLY_MODEL==_6_WD_SD_CO2TTL5000_GZ200K_WD_TRSF))
        if(j==1)//湿度
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        else if(j==3)
        {
           if(Pt.GzNoRe==1)//传感器无响应
           {
             StateC.Value[j]=SENIOR_NULL;
             continue;
           }
           else
           {
               StateC.Adc[j]=LxRead();//实际光照强度值
               if(Pt.GzNoRe==1)//传感器无响应
               {
                 StateC.Value[j]=SENIOR_NULL;
                 continue;
               }
               StateC.Adc[j]=GzEnlarge(StateC.Adc[j]);
               StateC.real_adc[j]=StateC.Adc[j];//真实AD
           }
        }
        
        //---------------------------------------------------
        #elif (JLY_MODEL==_8B_WD_GZV200K_SD_YL01_TRWD_TRSF_FS_FX)
        if(j==0||j==1||j==4||j==5)//温度，土壤水分，光照
        {
          NOP;//直接进入曲线调整
        }
        else if(j==2)//湿度
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        else if(j==3)//雨量，雨量和风向没有曲线
        {
          continue;
        }
        else if(j==6)//风速
        {
          continue;
        }
        else if(j==7)//风向
        {
          StateC.Value[j]=GetFxValue();
          continue;
        }
        
        #elif (JLY_MODEL==_8_NTC_HIH_CO2TTL5000_GZ200K_QY_NH3_H2S_CH4)
        if(j==1)//湿度
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        else if(j==3)//光照
        {
           //Pt.GzNoRe=0;
          
           if(Pt.GzNoRe==1)//传感器无响应
           {
             StateC.Value[j]=SENIOR_NULL;
             continue;
           }
           else
           {
               //Pt.GzNoRe=0;
               //StateC.Adc[j]=1243;
               StateC.Adc[j]=LxRead();//实际光照强度值
               
               if(Pt.GzNoRe==1)//传感器无响应
               {
                 StateC.Value[j]=SENIOR_NULL;
                 continue;
               }
               StateC.Adc[j]=GzEnlarge(StateC.Adc[j]);
               StateC.real_adc[j]=StateC.Adc[j];//真实AD
           }
        }
        

        
        
        
        #elif ((JLY_MODEL==_5_WD_GZ100K_TRWD_TRSF_SD)||(JLY_MODEL==_7_WD_GZ100K_TRWD_TRSF_SD_YL01_QY))
        if(j==1)//光照
        {
           //Pt.GzNoRe=0;
          
           if(Pt.GzNoRe==1)//传感器无响应
           {
             StateC.Value[j]=SENIOR_NULL;
             continue;
           }
           else
           {
               //Pt.GzNoRe=0;
               //StateC.Adc[j]=1243;
               StateC.Adc[j]=LxRead();//实际光照强度值 
               
               if(Pt.GzNoRe==1)//传感器无响应
               {
                 StateC.Value[j]=SENIOR_NULL;
                 continue;
               }
               StateC.Adc[j]=GzEnlarge(StateC.Adc[j]);
               StateC.real_adc[j]=StateC.Adc[j];//真实AD
           }
        }
        else if(j==4)//湿度
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        else if(j==6)//大气压
        {
          StateC.Adc[j]=shr1000ReadPressure();
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
          if(StateC.Adc[j]<3000)//错误不稳定时，取平均数
          {
            StateC.Value[j]=StateC.avg[j];
            continue;
          }
          else if(StateC.Adc[j]==SENIOR_NULL)//错误
          {
            StateC.Value[j]=SENIOR_NULL;
            continue;
          }
        }
        
        #elif (JLY_MODEL==_3B_WD_GZ100K_TRSF)
        if(j==0||j==2)//温度，土壤水分
        {
          NOP;//直接进入曲线调整
        }
        else if(j==1)//光照
        {
           //Pt.GzNoRe=0;//
          
           if(Pt.GzNoRe==1)//传感器无响应
           {
             StateC.Value[j]=SENIOR_NULL;
             continue;
           }
           else
           {
               StateC.Adc[j]=LxRead();//实际光照强度值 
               
               //Pt.GzNoRe=0;
               //StateC.Adc[j]=1243;//
               
               if(Pt.GzNoRe==1)//传感器无响应
               {
                 StateC.Value[j]=SENIOR_NULL;
                 continue;
               }
               StateC.Adc[j]=GzEnlarge(StateC.Adc[j]);
               StateC.real_adc[j]=StateC.Adc[j];//真实AD
           }
        }
        #elif ((JLY_MODEL==_8_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)\
          ||(JLY_MODEL==_8B_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX))
        if(j==0||j==4||j==5)//温度，土壤水分
        {
          NOP;//直接进入曲线调整
        }
        else if(j==1)//光照
        {
           //Pt.GzNoRe=0;
          
           if(Pt.GzNoRe==1)//传感器无响应
           {
             StateC.Value[j]=SENIOR_NULL;
             continue;
           }
           else
           {
               //Pt.GzNoRe=0;
               //StateC.Adc[j]=1243;
               StateC.Adc[j]=LxRead();//实际光照强度值 
               
               if(Pt.GzNoRe==1)//传感器无响应
               {
                 StateC.Value[j]=SENIOR_NULL;
                 continue;
               }
               StateC.Adc[j]=GzEnlarge(StateC.Adc[j]);
               StateC.real_adc[j]=StateC.Adc[j];//真实AD
           }
        }
        else if(j==2)//湿度
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        else if(j==3)//雨量，雨量和风向没有曲线
        {
          continue;
        }
        else if(j==6)//风速
        {
          continue;
        }
        else if(j==7)//风向
        {
          StateC.Value[j]=GetFxValue();
          continue;
        }

        
        #elif ((JLY_MODEL==_3_WD_SD_QY))
        if(j==0)//温度
        {
          NOP;//直接进入曲线调整
        }
        else if(j==1)//湿度
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        else if(j==2)//大气压, 2bit
        {
          StateC.Adc[j]=shr1000ReadPressure();
          
          if(StateC.Adc[j]<3000)//错误不稳定时，取平均数
          {
            StateC.Value[j]=StateC.avg[j];
            continue;
          }
          else if(StateC.Adc[j]==SENIOR_NULL)//错误
          {
            StateC.Value[j]=SENIOR_NULL;
            continue;
          }
          else
          {
            StateC.real_adc[j]=StateC.Adc[j];//真实AD
            //StateC.Adc[j]=StateC.Adc[j]/10;//1bit 小数
          }
        }
      #elif (JLY_MODEL==_6_WD_SD_QY_YL01_FS_FX)  
        if(j==0)//温度
        {
          NOP;//直接进入曲线调整
        }
        else if(j==1)//湿度
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        else if(j==2)//大气压, 2bit
        {
          StateC.Adc[j]=shr1000ReadPressure();
          
          if(StateC.Adc[j]<3000)//错误不稳定时，取平均数
          {
            //StateC.Value[j]=StateC.avg[j];//
            continue;
          }
          else if(StateC.Adc[j]==SENIOR_NULL)//错误
          {
            StateC.Value[j]=SENIOR_NULL;
            continue;
          }
          else
          {
            StateC.real_adc[j]=StateC.Adc[j];//真实AD
            //StateC.Adc[j]=StateC.Adc[j]/10;//1bit 小数
          }
        }
        else if(j==3)//雨量，雨量和风向没有曲线
        {
          continue;
        }
        else if(j==4)//风速，在外计算
        {
          continue;
        }
        else if(j==5)//风向
        {
          StateC.Value[j]=GetFxValue();
          continue;
        }
        
      #elif ((JLY_MODEL==_6B_WD_SD_QY_YL01_FS_FX))
        if(j==0)//温度
        {
          NOP;//直接进入曲线调整
        }
        else if(j==1)//湿度
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        else if(j==2)//大气压, 1bit
        {
          StateC.Adc[j]=shr1000ReadPressure();
          
          if(StateC.Adc[j]<3000)//错误不稳定时，取平均数
          {
            //StateC.Value[j]=StateC.avg[j];//
            continue;
          }
          else if(StateC.Adc[j]==SENIOR_NULL)//错误
          {
            StateC.Value[j]=SENIOR_NULL;
            continue;
          }
          else
          {
            StateC.real_adc[j]=StateC.Adc[j];//真实AD
            StateC.Adc[j]=StateC.Adc[j]/10;//1bit 小数
          }
        }
        else if(j==3)//雨量，雨量和风向没有曲线
        {
          continue;
        }
        else if(j==4)//风速，在外计算
        {
          continue;
        }
        else if(j==5)//风向
        {
          StateC.Value[j]=GetFxValue();
          continue;
        }
        
        #elif (JLY_MODEL==_4_WD_SD_FS_FX)
        if(j==1)//湿度
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        else if(j==2)//风速
        {
          continue;
        }
        else if(j==3)//风向
        {
          StateC.Value[j]=GetFxValue();
          continue;
        }
        
        #elif ((JLY_MODEL==_4_WD_GZ100K_SD_YL01)||(JLY_MODEL==_6_WD_GZ100K_SD_YL01_FS_FX)||(JLY_MODEL==_6_WD_GZ100K_SD_YL05_FS_FX)\
          ||(JLY_MODEL==_7_WD_GZ200K_SD_YL01_FS_FX_TRWD)||(JLY_MODEL==_8_WD_GZ200K_SD_YL01_FS_FX_TRWD_TRSF))
        if(j==1)//光照
        {
           if(Pt.GzNoRe==1)//传感器无响应
           {
             StateC.Value[j]=SENIOR_NULL;
             continue;
           }
           else
           {
               StateC.Adc[j]=LxRead();//实际光照强度值
               if(Pt.GzNoRe==1)//传感器无响应
               {
                 StateC.Value[j]=SENIOR_NULL;
                 continue;
               }
               StateC.Adc[j]=GzEnlarge(StateC.Adc[j]);
               StateC.real_adc[j]=StateC.Adc[j];//真实AD
           }
        }
        else if(j==2)//湿度
        {
          StateC.Adc[j]=GetHumiValue(StateC.Adc[j],0);
           
          if(StateC.Adc[j]<HIH5030_ERR)//传感器错误
          {
            if(Pt.ErrCt<ERR_NUM)
              continue;
            Pt.ErrCt=0;
          }
          StateC.real_adc[j]=StateC.Adc[j];//真实AD
        }
        else if(j==3)//雨量，雨量和风向没有曲线
        {
          continue;
        }
        else if(j==4)//风速
        {
          continue;
        }
        else if(j==5)//风向
        {
          StateC.Value[j]=GetFxValue();
          continue;
        }
        
       //通道2由通道1决定
      #elif (JLY_MODEL==_2_SW_30m_SHD_20m)
      if(j==0)
      {
        //安照AD曲线，自动计算
      }
      else if(j==1)
      {
        //井口至水面的深度计算 20米-SW
        if(StateC.Value[0]<=2000)
        {
          StateC.Value[1]=2000-StateC.Value[0];
        }
        else
        {
          StateC.Value[1]=0;
        }
        continue;
        
      }

      #endif

       AdcToValue(StateC.Adc[j],j);//取得各个通道StateC.Value[]的值    
       


       
      //----------------------------------------------------------------
       
      NOP;
    }
    
    

                  #if L_REC_AVG_EN==1//取最小，最大，平均值
                  u16 fc;
                  
                 //StateC.Value[j]=Pt.RecordPt+j*100;
                 //StateC.FuhaoBit|=BIT0;
                  
                  if(0x01&(StateC.FuhaoBit>>j))//负数HSB8
                    fc=0x8000;
                  else
                    fc=0;
                  fc=fc|StateC.Value[j];//添加符号
                  
                  if(StateC.LRYouxiaoNum[j]==0)
                  {
                      if((StateC.Value[j]==SENIOR_NULL)||(StateC.Value[j]==HAND_STOP))
                      {
                        StateC.LRavg[j]=SENIOR_NULL;
                        StateC.LRmum[j]=0;
                        StateC.LRYouxiaoNum[j]=0;
                      }
                      else
                      {
                        StateC.LRavg[j]=fc;//取第一个记录点值
                        StateC.LRmum[j]=u16_to_long(fc);
                        StateC.LRYouxiaoNum[j]=1;
                      }

                  }
                  else
                  {
                        //第二个点开始
                        if((StateC.Value[j]==SENIOR_NULL)||(StateC.Value[j]==HAND_STOP))
                        {
                          continue;
                        }
                        //avg
                        StateC.LRmum[j]=get_mum(StateC.LRmum[j],fc);
                        StateC.LRYouxiaoNum[j]++;
                        StateC.LRavg[j]=get_avg(StateC.LRmum[j],StateC.LRYouxiaoNum[j]);
                        
                        NOP;
                  }
                  #endif
    
    
    
    
  }
#endif
  
  
  #if SHUXIAN_ENABLE==1
  LoggerRecord();
  StateA1.RecordNum++;
  if(StateA1.RecordNum>43200)//1天
  {
    StateA1.RecordNum=0;
  }
  #endif
  

  Flag.RstFirstSample=1;
  Flag.SampPt=0;//采样一个周期结束
  NOP;
  
  Pt.RealDog=0;//实时数据采集时，清0  zz
  
  
  #if G_20_GZ_EN==1
           //光照检测，开箱，关箱  StateC.Value[6]

           if(Pt.GzNoRe==1)//传感器无响应
           {
             StateC.Value[6]=SENIOR_NULL;
           }
           else
           {
               StateC.Value[6]=LxRead();//实际光照强度值
               if(Pt.GzNoRe==1)//传感器无响应
               {
                 StateC.Value[6]=SENIOR_NULL;
               }
               //StateC.Value[6]=GzEnlarge(StateC.Value[6]);
               

           }
           if(1==Flag.SeeComing)
           {
               ComSendH();
               U1SendByte('G');U1SendByte('Z');U1SendByte(':');
               U1SendValue(StateC.Value[6]);
               U1SendByte(0X0D);U1SendByte(0X0A);
               ComSendL();
           
           }
           
  #endif
  
  
  
  NOP;
  NOP;
  

  
  return 1;
}

//有外电返回1
u8 HavePow(void)
{
  if((POW_PIN&POW_BIT)==POW_BIT)
    return 0;
  else
    return 1;
}


void LoggerLcdDeel(void)
{
   #if LED_WORK_ENABLE==0//非指示灯模式，LCD模式
   if((Pt.LcdShowPt>=LCD_SHOW_TIME)||(Pt.LcdShowPt==0))
   {
      Pt.LcdShowPt=0;

      #if LCD_NO==8
      if(CH_NUM>1)
      {
        Lcd08_Deel();
      }
      #elif LCD_NO==20
      if(CH_NUM>=1)
      {
        Lcd20_Deel();
      }
      #else
      if(CH_NUM>2)
      {
        LcdChNoDeel();
      }
      #endif
   }
   Pt.LcdShowPt++;
   #endif
}
void Bell_Shan(void)
{
   if(Flag.BellShan==1)
   {
      Flag.BellShan=0;
      #if PHONE_ALARM_ENABLE==1//电话报警是持续触发
      PHONE_ALARM_ON;
      #endif

      BELL_ON;
      SG_ON;
    }
    else
    {
      Flag.BellShan=1;
      BELL_OFF;
      SG_OFF;
    }
}
void Bell_Off(void)
{
   #if PHONE_ALARM_ENABLE==1
   PHONE_ALARM_OFF;
   #endif
   BELL_OFF;
   SG_OFF;
}
void LoggerAlarmDeel(void)//1秒
{
   #if SMS_SEND_8H_EN==1
   //每8小时发送一次短信
        
        if(Sms.WaitPt>0)
          Sms.WaitPt--;
  
  
        if(StateA2.WorkState==WORK_STATE_RECORDING)
        {
              Rtc.SS=ReadRtcD10();
              
              u16 TT;
              
              #if SMS_SEND_6H_EN==1
                TT=Rtc.SS%(3600*6);
              #elif SMS_SEND_6H2_EN==1
                TT=(Rtc.SS-(3600*2))%(3600*6);
              #elif SMS_SEND_4H_EN==1
                TT=Rtc.SS%(3600*4);
              #elif SMS_SEND_A_EN==1  
                TT=(Rtc.SS-(3600*7))%(3600*3);
              #else
                TT=(Rtc.SS-(3600*6))%(3600*8);
              #endif
              
      
              if(TT<6)
              {
                
                  #if SMS_SEND_A_EN==1
                  if((Rtc.Hour==7)||(Rtc.Hour==10)||(Rtc.Hour==13)||(Rtc.Hour==16)||(Rtc.Hour==19)||(Rtc.Hour==22))
                  {
                  #else
                  {
                  #endif
                
                
                
                      if(Sms.WaitPt==0)
                      {
                         Sms.WaitPt=10;
                         
                         Sms.IntervalPt=0;
                         SmsAlarmStart();
                      }
                  
                  }
              }
        }
  
  
   #endif
  
  
  
  
   //通道报警使能指示
   if(HaveALEnable())
   {

       #if POW_NONE_ALARM_EN==1
       if(ChAlarm()||(HavePow()==0))//报警使能时，才可以
       #else
       if(ChAlarm())
       #endif
       {
           //蜂鸣器--------------------------------------------------------
           #if ALARM_TIME_ENABLE==1
           AlarmedSet();
           #elif ALARM_BELL_TIME_EN==1
           AlarmBellTimeDo();//间隔30分钟报警15秒，正常后，停止
           #elif SG_IN_AL_EN==1//持续超标才声光报警
           NOP;
           
           #else
             Bell_Shan();
           #endif
           
           #if RY_ALARM_EN==1
           RY1_ON;
           #endif
           
           //短信报警触发----------------------------------------------------
           
           #if ((GSM_ENABLE==1)&&(SMS_SEND_8H_EN==0))
           
                 #if SMS_IN_AL_EN==1
                   if(Sms.SmsInALPt<SMS_IN_AL_TIME)
                     Sms.SmsInALPt++;
                   if(Sms.SmsInALPt>=SMS_IN_AL_TIME)//持续超标，才触发短信
                   {
                        SmsAlarmStart();
                         
                        #if SG_IN_AL_EN==1
                         
                           #if ALARM_KEY_CONTINUE_EN==1
                           if(Pt.AlarmKC==0)
                           {
                             Bell_Shan();
                           }
                           else
                           {
                             Bell_Off();
                           }
                           
                           #else
                           
                           Bell_Shan();
                           #endif
                           
                       #endif
                         
                         
                   }
                   
                 #else
                   SmsAlarmStart();
                 #endif

           #endif
       }
       else
       {
          #if ALARM_BELL_TIME_EN==1
          Pt.AlarmTimePt=0;//没有超标，则一直为0
          #endif
          
           #if RY_ALARM_EN==1
           RY1_OFF;
           #endif

          Bell_Off();

          #if ((GSM_ENABLE==1)&&(SMS_SEND_8H_EN==0))
             #if SMS_IN_AL_EN==1
             Sms.SmsInALPt=0;
             #endif
             
             //SmsAlarmEnd();
          #endif
       }
       
       
       #if RY_CH2_AL_EN==1
       if(SeeChAlarm(1))
       {
           RY1_ON;
       }
       else
       {
           RY1_OFF;
       }
       #endif
       
       
       
       //曾经超标过，一直报警，直到按钮取消
       #if ALARM_TIME_ENABLE==1
       AlarmTimeDo();
       #endif
   }
   else
   {
       Bell_Off();
       
       #if RY_ALARM_EN==1
       RY1_OFF;
       #endif
       
       #if RY_CH2_AL_EN==1
       RY1_OFF;
       #endif
             
       #if ((GSM_ENABLE==1)&&(SMS_SEND_8H_EN==0))
       
         #if SMS_IN_AL_EN==1
         Sms.SmsInALPt=0;
         #endif
       
         SmsAlarmEnd();
       #endif
   }
}
#if BSQ_ENABLE==1
//清空记录数据
void PCBSQ_RecClr(void)
{
  PcBsq.Rec16Num=0;//清空
  PcBsq.RecPt=0;
  PCBSQ_RecNumPt_ToEE();
  
  #if ((ZX_EN==1)||(GPRS_UP_REAL_EN==1))
  Pt.UpCmd=0;
  #endif
  
  #if (PRINT_52_42_EN==1)
  //Pt.bcSS=0;//开机后，清0，立即开始记录  
  //Pt.bcAL=0;
  //SaveBcToEE();
  
           if(Pt.bcSS>0)//上一条记录有时
           {
               Rtc.SS=ReadRtcD10();
               
               if(Rtc.SS>=Pt.bcSS+120)
               {
               
                   Pt.bcSS=0;//开机后，清0，立即开始记录
                   Pt.bcAL=0;
                   SaveBcToEE();
               
               }
           
           }
  
  #endif
  
}
void PCBSQ_RecTime_ToEE(void)
{
      u8 buf[8];
      
      buf[0]=0xff&(PcBsq.RecTime>>24);
      buf[1]=0xff&(PcBsq.RecTime>>16);
      buf[2]=0xff&(PcBsq.RecTime>>8);
      buf[3]=0xff&(PcBsq.RecTime>>0);
      I2C_EE_BufferWrite(buf,PCBSQ_REC_TIME_ADDR,4,0);
      
      //PcBsq.RecTime同步
      #if GPRS_ENABLE==1//低字节在前
            buf[4]=buf[3];
            buf[5]=buf[2];
            buf[6]=buf[1];
            buf[7]=buf[0];
            I2C_EE_BufferWrite(&buf[4],GPRS_TIME_ADDR,4,0);
      #endif
}

void PCBSQ_RecNumPt_ToEE(void)
{
  u8 buf[2];

  
  buf[0]=0xff&(PcBsq.Rec16Num>>8);
  buf[1]=0xff&(PcBsq.Rec16Num>>0);
  I2C_EE_BufferWrite(buf,PCBSQ_REC_NUM_ADDR,2,0);
  
  
  buf[0]=0xff&(PcBsq.RecPt>>8);
  buf[1]=0xff&(PcBsq.RecPt>>0);
  I2C_EE_BufferWrite(buf,PCBSQ_REC_PT_ADDR,2,0);
  

}
void PCBSQ_CapToEE(void)
{
  u8 buf[4];
  

  #if ((GPRS_ENABLE==1)||(BSQ_REC_AA_EN==1))
  
    /*
    if(PcBsq.RecCap>PCBSQ_REC_CAP_FIRST)//不能大于最大存储容量
      PcBsq.RecCap=PCBSQ_REC_CAP_FIRST;
    */
    if(PcBsq.RecCap>StateC.RecordMaxNum)//不能大于最大存储容量
      PcBsq.RecCap=StateC.RecordMaxNum;
  
  
  #else
    if(PcBsq.RecCap>StateC.RecordMaxNum)//不能大于最大存储容量
      PcBsq.RecCap=StateC.RecordMaxNum;
    
    #if BSQ_RTC4_EN==1
      PcBsq.RecCap=StateC.RecordMaxNum;
    #endif
    
    
  #endif

  
  buf[0]=0xff&(PcBsq.RecCap>>24);
  buf[1]=0xff&(PcBsq.RecCap>>16);
  buf[2]=0xff&(PcBsq.RecCap>>8);
  buf[3]=0xff&(PcBsq.RecCap>>0);
  I2C_EE_BufferWrite(buf,PCBSQ_REC_CAP_ADDR,4,0);
}
void PCBSQ_CapFromEE(void)
{
  u8 buf[4];
  I2C_EE_BufferRead(buf,PCBSQ_REC_CAP_ADDR,4,0);
  PcBsq.RecCap=U8_TO_U32(buf[0],buf[1],buf[2],buf[3]);

  
  #if ((GPRS_ENABLE==1)||(BSQ_REC_AA_EN==1))
    /*
    if(PcBsq.RecCap>PCBSQ_REC_CAP_FIRST)//不能大于最大存储容量
      PcBsq.RecCap=PCBSQ_REC_CAP_FIRST;
    */
  
    if(PcBsq.RecCap>StateC.RecordMaxNum)//不能大于最大存储容量
      PcBsq.RecCap=StateC.RecordMaxNum;
    
  #else
    if(PcBsq.RecCap>StateC.RecordMaxNum)//不能大于最大存储容量
      PcBsq.RecCap=StateC.RecordMaxNum;
  #endif
}
void PCBSQ_FromEE(void)
{
  u8 buf[8];
  I2C_EE_BufferRead(buf,PCBSQ_REC_TIME_ADDR,8,0);
  PcBsq.RecTime=U8_TO_U32(buf[0],buf[1],buf[2],buf[3]);
  PcBsq.Rec16Num=U8_TO_U16(buf[4],buf[5]);
  PcBsq.RecPt=U8_TO_U16(buf[6],buf[7]);
}

//变送器，记录一条数据,记录点时间Rtc.SB
////cc=0x01 温湿度， 开机FA 或 关机标记FB , 
//顺丰协议有开关机标记
//LG31协议，暂时不做开关机标记
void PCBSQ_RecOne(u8 cc)
{
            u16 i,j;
			
            #if ((GPRS_TC_EN==1)||(BSQ_REC_AA_EN==1))
            
                   //记录必要数据：发送时解析成协议的格式发送
            
                   //定位和不定位的，记录要做区分：
                   //定位SIZE= 4+9+2*CH_NUM
                   //温湿度  ：RTC(4)+BAT(1)+GPS(8)+2*CH_NUM  
                   //开机标记：RTC(4)+后面全部0A
                   //关机标记：RTC(4)+后面全部0B
                   
                   //不带定位 SIZE= 4+1+2*CH_NUM
                   //温湿度  ：RTC(4)+BAT(1)+2*CH_NUM  

            
                    u8 buf[29];
                    u16 vv;
                   
                    i=0;
                    
                    buf[i++]=0xff&(Rtc.SB>>24);
                    buf[i++]=0xff&(Rtc.SB>>16);
                    buf[i++]=0xff&(Rtc.SB>>8);
                    buf[i++]=0xff&(Rtc.SB);
                    
                    if(cc==0x01)//温湿度数据 01
                    {
                          #if ((GPRS_LG31_3000_EN==1)||(ZX_EN==1))//多了个外部电源
                      
                            #if BAT_TO_XH_EN==1
                              buf[i]=Gsm.GsmXh;//zz  上传信号强度
                            #else
                              buf[i]=GetBatt();//电量
                            #endif
                            
                            #if NO_EXPOW_EN==0
                            if(HavePow())//有外电
                              buf[i]|=0x80;
                            #endif
                            
                            i++;
                          #else
                            buf[i++]=GetBatt();//电量
                          #endif

                         #if LBS_LAC_EN==1     
                              
                              buf[i++]=0xff&(Sms.LAC>>8);
                              buf[i++]=Sms.LAC;
                              
                              buf[i++]=0xff&(Sms.CID>>8);
                              buf[i++]=Sms.CID;
                                                      

                              buf[i++]=0x00;
                              buf[i++]=0x00;
                              buf[i++]=0x00;
                              buf[i++]=0x00;           
                              
                          #elif ((GPS_MOUSE_EN==1)&&(LBS_JWD_EN==1))// 带定位    
                              
                              if(StateC.GpsOutPt>0)
                              {
                                    buf[i++]=StateC.LongiInt;//经度整数
                                    buf[i++]=0xff&(StateC.LongiDec>>16);//经度小数
                                    buf[i++]=0xff&(StateC.LongiDec>>8);
                                    buf[i++]=0xff&(StateC.LongiDec);
                                                            
                                    buf[i++]=StateC.LatiInt;//纬度整数
                                    buf[i++]=0xff&(StateC.LatiDec>>16);//纬度小数
                                    buf[i++]=0xff&(StateC.LatiDec>>8);
                                    buf[i++]=0xff&(StateC.LatiDec);
                              }
                              else
                              {
                                    buf[i++]=StateC.LBS_JdInt;//经度整数
                                    buf[i++]=0xff&(StateC.LBS_JdDec>>16);//经度小数
                                    buf[i++]=0xff&(StateC.LBS_JdDec>>8);
                                    buf[i++]=0xff&(StateC.LBS_JdDec);
                                                            
                                    buf[i++]=StateC.LBS_WdInt;//纬度整数
                                    buf[i++]=0xff&(StateC.LBS_WdDec>>16);//纬度小数
                                    buf[i++]=0xff&(StateC.LBS_WdDec>>8);
                                    buf[i++]=0xff&(StateC.LBS_WdDec);
                              }
                              
                              
                              
                              
                          #elif ((GPS_MOUSE_EN==1)&&(LBS_JWD_EN==0))// 带定位
                             
                              buf[i++]=StateC.LongiInt;//经度整数
                              buf[i++]=0xff&(StateC.LongiDec>>16);//经度小数
                              buf[i++]=0xff&(StateC.LongiDec>>8);
                              buf[i++]=0xff&(StateC.LongiDec);
                                                      
                              buf[i++]=StateC.LatiInt;//纬度整数
                              buf[i++]=0xff&(StateC.LatiDec>>16);//纬度小数
                              buf[i++]=0xff&(StateC.LatiDec>>8);
                              buf[i++]=0xff&(StateC.LatiDec);
                              

                          #elif ((GPS_MOUSE_EN==0)&&(LBS_JWD_EN==1))
      
                              buf[i++]=StateC.LBS_JdInt;//经度整数
                              buf[i++]=0xff&(StateC.LBS_JdDec>>16);//经度小数
                              buf[i++]=0xff&(StateC.LBS_JdDec>>8);
                              buf[i++]=0xff&(StateC.LBS_JdDec);
                                                      
                              buf[i++]=StateC.LBS_WdInt;//纬度整数
                              buf[i++]=0xff&(StateC.LBS_WdDec>>16);//纬度小数
                              buf[i++]=0xff&(StateC.LBS_WdDec>>8);
                              buf[i++]=0xff&(StateC.LBS_WdDec);
                              
                                                      
                         #endif
                          
      
                          //取当前记录的数据，包括符号
                          for(j=0;j<CH_NUM;j++)
                          {
                              vv=StateC.Value[j];
                              if(0x01&(StateC.FuhaoBit>>j))//负数
                              {
                                vv=StateC.Value[j]|0x8000;
                              }
                              
                              buf[i++]=0xff&(vv>>8);
                              buf[i++]=0xff&(vv);
                          }
                          
                          
                          #if (PRINT_52_42_EN==1)
                          Pt.bcSS=Rtc.SB;
                          
                          LoggerAlarmAllSeek();
                          Pt.bcAL=RecAlarm();
                          
                          SaveBcToEE();
                          
                          #endif
                          
                          
                    
                    }
                    
                    //开机FA 或 关机标记FB
                    else
                    {
                       #if ((GPS_MOUSE_EN==1)||(LBS_LAC_EN==1)||(LBS_JWD_EN==1))//带定位
                       for(j=0;j<(9+2*CH_NUM);j++)
                       #else
                       for(j=0;j<(1+2*CH_NUM);j++)
                       #endif
                       {
                         buf[i++]=cc;
                       }
                    }
                    
            #else
		    //包括了变送器和GPRS记录，路格协议A
                    //变送器数据点格式：RTC(6)+n*通道数值(2), 字节=6+2CH_NUM
                    //BSQ_RTC4_EN==1时 RTC(4)+n*通道数值(2), 字节=4+2CH_NUM
                    //GPRS数据点格式：RTC(6)+电量(1)+电源(1)+预留(9)+n*通道数值(2),字节=17+2*CH_NUM
                    
                    
                    #if RF_MULTI_EN==1 
                    u8 buf[406];//Pt.KpN*4+6 ,最大100个卡片
                    #else
                    u8 buf[36];
                    #endif
                    
		    StrcutRtc time_bcd;
		    time_bcd=SS_To_BCD(Rtc.SB);

                    i=0;
                    
                  #if BSQ_RTC4_EN==1//储存的是RTC4
                      buf[i++]=0xff&(Rtc.SB>>24);
                      buf[i++]=0xff&(Rtc.SB>>16);
                      buf[i++]=0xff&(Rtc.SB>>8);
                      buf[i++]=0xff&(Rtc.SB);            
                  #else
                      buf[i++]=time_bcd.Year;
                      buf[i++]=time_bcd.Month;
                      buf[i++]=time_bcd.Day;
                      buf[i++]=time_bcd.Hour;
                      buf[i++]=time_bcd.Minute;
                      buf[i++]=time_bcd.Second;
                   #endif


                    #if GPRS_ENABLE==1
                            #if BAT_TO_XH_EN==1
                              buf[i++]=Gsm.GsmXh;//zz  上传信号强度
                            #else
                              buf[i++]=GetBatt();//电量
                            #endif
                    
                    
                          
                          
                          #if NO_EXPOW_EN==1
                            buf[i++]=0x00;//09保温箱GPRS默认无外电
                          #else
                            if(Flag.PowIn==1)//有外电
                              buf[i++]=0x01;
                            else//无外电
                              buf[i++]=0x00;
                          #endif
        
                          #if GPS_MOUSE_EN==1//OLD
                              //经度
                              buf[i++]=0xff&StateC.LongiInt;
                              buf[i++]=0xff&(StateC.LongiDec>>16);
                              buf[i++]=0xff&(StateC.LongiDec>>8);
                              buf[i++]=0xff&(StateC.LongiDec);
                          
                              //纬度
                              buf[i++]=0xff&StateC.LatiInt;
                              buf[i++]=0xff&(StateC.LatiDec>>16);
                              buf[i++]=0xff&(StateC.LatiDec>>8);
                              buf[i++]=0xff&(StateC.LatiDec);
                              
                              //预留
                              buf[i++]=0x00;
                          
                          #else
        
                                //预留
                                for(j=0;j<9;j++)
                                  buf[i++]=0x00;                 
        
                          #endif
                      
                    #endif
                    
                    
                    
                    #if RF_MULTI_EN==1 
                    //记录所有卡片数据，一个卡片占2个通道       
                    for(j=0;j<Pt.KpN;j++)
                    {
                         
                         //通道1
                         buf[i++]=0xff&(Pt.RfData[j][0].value>>8);
                         buf[i++]=0xff&(Pt.RfData[j][0].value);
                         
                         //通道2
                         buf[i++]=0xff&(Pt.RfData[j][1].value>>8);
                         buf[i++]=0xff&(Pt.RfData[j][1].value);
                    }
                                
                    #else
                    //通道数据
                    for(j=0;j<CH_NUM;j++)
                    {
                      
                        if((StateC.Value[j]==SENIOR_NULL)||(StateC.Value[j]==HAND_STOP))//3.4
                        {
				 buf[i++]=0xff&(StateC.Value[j]>>8);//HSB8
				 buf[i++]=0xff&StateC.Value[j];//LSB8
                        }
                        else
                        {
				 //HSB8
				 if(0x01&(StateC.FuhaoBit>>j))
                                 {
				     buf[i++]=0x80|(0xff&(StateC.Value[j]>>8));
                                 }
				 else
                                 {
				     buf[i++]=0x7f&(StateC.Value[j]>>8);
                                 }
                                 
				 //LSB8
				 buf[i++]=0xff&StateC.Value[j];
                        }
                    }
                    #endif
                
            
            #endif
            
            
                    
            //最大记录条数，地址从0x0000开始
                    
            #if GPRS_MEMS_EN==1        //zz
               u32 EE_32Pt;    
               u8 QuHao;
               
               EE_32Pt=PcBsq.RecPt;
               EE_32Pt=EE_32Pt*i;
               
               if(StateC.EE_n==1)
               {
                  QuHao=0;
               }
               else
               {
                  if(EE_32Pt+i<=StateC.E1_MaxMem)
                  {
                      QuHao=0;
                  }
                  else
                  {
                      QuHao=1+(EE_32Pt-StateC.E1_MaxMem)/StateC.E2_MaxMem;
                      EE_32Pt=(EE_32Pt-StateC.E1_MaxMem)%StateC.E2_MaxMem;
                  }
                  
               }
               
               I2C_EE_BufferWrite(buf,EE_32Pt,i,QuHao);
               
                  
            #else
                        
                u16 EE_16Pt;
                EE_16Pt=PcBsq.RecPt*i;
                
                //记录一条
                I2C_EE_BufferWrite(buf,EE_16Pt,i,0);
            #endif
            
            
            //记录缓冲
            PcBsq.RecPt++;
            if(PcBsq.RecPt>=PcBsq.RecCap)//缓冲溢出
              PcBsq.RecPt=0;
			  
            //记录条数
            if(PcBsq.Rec16Num<PcBsq.RecCap)//PC数据条数
              PcBsq.Rec16Num++;
            else
              PcBsq.Rec16Num=PcBsq.RecCap;
            
            //保存参数到EE
            PCBSQ_RecNumPt_ToEE();
            
            //------------------------------------------------------------------------------------------------
            #if ((GPRS_ENABLE==1)||(WIFI_ENABLE==1))
              if(Pt.GprsDueOut<PcBsq.RecCap)
                Pt.GprsDueOut++;//GPRS、WIFI上传的数据条数
                    
              GprsDueOutToEE();
              
              #if WIFI_ENABLE==0
                Pt.GprsRstErrPt=0;
              #endif
            
            
            #endif
            
            
            #if GPRS_TC_EN==1
                 #if GPRS_PRT_CAP_EN==1
                    if(Pt.PrintDueout<Pt.PrtCap)//打印数据条数    
                 #else
                    if(Pt.PrintDueout<PcBsq.RecCap)//打印数据条数               
                 #endif
                    {
                        Pt.PrintDueout++;
                    }
                              
                 PrintDueOutToEE();
            #endif

}

#if PRINT_52_42_EN==1
u8 Bp52noSave(void)
{
                          u8 TT=99;
  
  
                          if(Pt.bcSS==0)
                          {
                              TT=0;//上一条没时间值，立即记录
                          }
                          else
                          {
                              if(Pt.bcAL)//上一条超标
                              {
                                     if(Rtc.SB>=Pt.bcSS+120)//2分钟后记录
                                     {
                                         TT=0;//立即记录
                                     }
                              }
                              else//上一条没超标
                              {
                                    if(Rtc.SB>=Pt.bcSS+60)//1分钟后记录
                                    {
                                         LoggerAlarmAllSeek();
                                         if(RecAlarm())//超标后立即记录
                                         {
                                             TT=0;//立即记录
                                         }
                                         else
                                         {
                                            if(Rtc.SB>=Pt.bcSS+300)//5分钟后记录
                                            {
                                              TT=0;
                                            }
                                         }
                                    }

                              }
                              
                              
                              if(Rtc.SB+600<Pt.bcSS)//上次存储的时间比当前时间大了10分钟以上,说明时钟有误，立即开启新一轮记录
                              {
                                TT=0;
                              }
                              
                              
                          }
                          
                          return TT;
}
#endif

void PCBSQ_Record(void)
{
        #if WIFI_ENABLE==1
        if(Pt.Fg60FF==1)//关机模式
          return;
        #endif
        
        #if GSM_KEY_SHUT_EN==1

              if(Sms.GsmKeyShut==1)//按钮关闭
              {
                  #if GPRS_6OFF==1
                  StateA2.WorkState=WORK_STATE_STOP;
                  POWER_CTL_ALL_OFF;
                  LcdOFFX(OFF_BSQ_GPRS_HAND_STOP);//60FF
                  #endif
                  return;
              }
            

        #endif
        
        #if RTC_UTC_EN==1
        if(Pt.UtcEn==1)//开机对时的时候，不记录
          return;
        #endif
		
        #if RF_MULTI_EN==0
        if(Flag.RstFirstSample==0)
          return;
        #endif

        if(PcBsq.RecTime==0)
          return;
		
		
        vu16 TT=99;
        Rtc.SS=ReadRtcD10();
        
        if(Rtc.SS==0)//时钟错误，不记录
          return;
        
		
        //打印缓存记录时间到，固定5分钟一次-----------------------------------------------------
#if GPRS_TC_EN==0
         
     #if (((PRINT_NEW_EN==1)||(PRINT_RT_LIST_EN==1))&&(PRINT_BSQ_DATA==0))
        
         if(PcBsq.PrintTT>0)
           PcBsq.PrintTT--;
        
         #if PRINT_BP_2MIN_EN==1
        
            LoggerAlarmAllSeek();
	    if(RecAlarm())//有数据超标，将打印间隔变频
	       TT=Rtc.SS%PRINT_BP_JIANGE;
	    else
	       TT=Rtc.SS%PRINT_JIANGE;

         #else
           
              TT=Rtc.SS%PRINT_JIANGE;
         
         #endif

         if(TT<=7)
         {
           if(PcBsq.PrintTT==0)//至少间隔
           {
              PcBsq.PrintTT=8;
              
              Rtc.SB=Rtc.SS-TT;//记录点的时间,剔除秒为0
			  
              #if PRINT_RT_LIST_EN==1//记录一个点打印一个数据列表----------------------------------
                if(StateC.PcLinkPt==0)//没有与PC通讯时才打印
                  PrintOneList();
              #endif
             
              
              #if PRINT_NEW_EN==1
                PrintDataSave();//打印缓冲区，存储需打印的数据
              #endif
                
           }
         }
     #endif
#endif

        
        //变送器记录时间到---------------------------------------------------------------------------
        if(PcBsq.PCwaitTT>0)
          PcBsq.PCwaitTT--;
         
        #if (BP_ALARM_EN==1)
         
            #if PRINT_52_42_EN==1
         
              if(PcBsq.RecTime==300)//记录间隔5分钟
              {
                  if(PcBsq.PCwaitTT==0)
                  {
                      if((Rtc.SS%60)<=7)
                      {
                          Rtc.SB=Rtc.SS-Rtc.SS%60;//时间，秒清0  zz
                          
                          TT=Bp52noSave();
                        
                      }
                  }
              }
              else
              {

                   LoggerAlarmAllSeek();
                   if(RecAlarm()&&(PcBsq.RecTime>GSP_BP_JIANGE))//有数据超标，并且记录间隔大于2分钟时，才将GPRS间隔变为2分钟
                      TT=Rtc.SS%GSP_BP_JIANGE;
                   else
                      TT=Rtc.SS%PcBsq.RecTime;
                   
                   Rtc.SB=Rtc.SS-Rtc.SS%60;//时间，秒清0  zz
                 
              }
              
         
            #else
           
                 LoggerAlarmAllSeek();
                 if(RecAlarm()&&(PcBsq.RecTime>GSP_BP_JIANGE))//有数据超标，并且记录间隔大于2分钟时，才将GPRS间隔变为2分钟
                    TT=Rtc.SS%GSP_BP_JIANGE;
                 else
                    TT=Rtc.SS%PcBsq.RecTime;
                 
            #endif
         
        #else
            TT=Rtc.SS%PcBsq.RecTime;
        #endif
         
   
        if(TT<=7)
        {
          if(PcBsq.PCwaitTT==0)
          {
              PcBsq.PCwaitTT=9;//至少间隔
            
              #if PRINT_52_42_EN==1
              
                  if(PcBsq.RecTime==300)//5分钟
                  {
                      if(Bp52noSave()==0)
                      {
                         PCBSQ_RecOne(0x01);//记录温湿度数据
                      }
                      else
                      {
                         U1SendStrPC("ErrREC\r\n");//zz
                      }
                  }
                  else
                  {
                      PCBSQ_RecOne(0x01);//记录温湿度数据
                  }
                  
              #else
                  
                  Rtc.SB=Rtc.SS-Rtc.SS%60;//时间，秒清0  zz   
                  
                  PCBSQ_RecOne(0x01);//记录温湿度数据
              
              #endif
                
	      
              
              
              #if ((BSQ_YL_ENABLE==1)||(PRINT_RT_LIST_EN==1))
            
                  if((Rtc.SB%86400)<=TT)//每天0点打印一次用户名和标题   或每天0点清一次雨量
                  {
                        //变送器雨量固定 1天清一次， 必须在记录后，才清0，否则GPRS整点时会少该点数据----------------------------------------
                        #if BSQ_YL_ENABLE==1

                           StateC.Value[YL_CH]=Pt.RainPt=0;//第4通道是雨量
                           SET_YL1_INT;
                           
                            #if ONLY_JS_ENABLE==1//单独计数，清0时，显示
                               Flag.RstFirstSample=1;//单一雨量时，一直置1
                               LcdValue();
                            #endif
                               
                        #elif PRINT_RT_LIST_EN==1//记录一个点打印一个数据列表

                    
                              #if PRINT_BSQ_DATA==1//W95打印
                              U0_RecErr();//无线变送器，U1打印数据
                              #endif
                              
                              PrintStart();//打印准备------------------------------------------------------
                              SetIni();
                              delay_ms(2);
                              SetCnPrint(1);
                              delay_ms(2);
                              
                              //打印用户名和标题
                              GoOneHang(1);
                              U1SendString("用 户 名：");
                              i2c_ee_read_to_pc(USER_NAME_ADDR,20,0);
                              U1SendByte(0x0a);
                              U1SendString("标    题：");
                              i2c_ee_read_to_pc(TITLE_ADDR,20,0);
                              U1SendByte(0x0a);
                              GoOneHang(1);
                              
                              #if PRINT_ALL_CH_EN==1//打印全部通道
                                //温度
                                #if (JLY_MODEL==_2_NTC)
                                  U1SendString("日期    时间     温度1  温度2\n");
                                #endif
                              #endif
                              
                              
                              PrintEnd();
                              
                          #endif
                  }
               #endif
                 
                 
                #if PRINT_RT_LIST_EN==1
                    
                    #if PRINT_BSQ_DATA==1//W95打印
                       //if(StateC.PcLinkPt==0)//没有与PC通讯时才打印,无线通讯的去掉这个，因为2无线通讯的是把U0的数据转到U1上去了。
                       U0_RecErr();//无线变送器，U1打印数据
                       PrintOneList();//打印记录点的时间
                    #else
                      if(StateC.PcLinkPt==0)//没有与PC通讯时才打印
                        PrintOneList();           
                    #endif
  
  
                #endif
              
                #if RF_MULTI_EN==0
              
                      U1SendStrPC("REC\r\n");//zz
                      
                      #if BAT_LCD_EN==1
                      if(1==Flag.SeeComing)//zz
                      {
                        ComSendH();
                        
                        U1SendString("B=");
                        U1SendValue(StateC.BatV);
                        
                        U1SendString(",C=");
                        U1SendValue(GetBatt());
                        U1SendString("\r\n");
                        
                        ComSendL();
                      }
                      #endif
                
                #endif
 
          }
        }
        
        
        #if GPRS_UP_TIME_EN==1
        
           #if ((ZX_EN==1)||(GPRS_UP_REAL_EN==1))
               if(Pt.PcWt>0)
                 Pt.PcWt--;
        
               TT=(Rtc.SS+2)%Pt.GprsSendTime;//提前2秒
    
           #else
                //上传时间到
                #if LBS_LAC_EN==1
                        TT=(Rtc.SS+30)%Pt.GprsSendTime;//zz 提前启动 
                #elif LBS_JWD_EN==1
                        TT=(Rtc.SS+40)%Pt.GprsSendTime;
                #else
                        TT=(Rtc.SS+25)%Pt.GprsSendTime; 
                #endif
 
            #endif
                    
                    
            if(TT<=7)
            {

                  Pt.Gprsing=1;//有数据时，开启上传
                  
                  
                  #if ((ZX_EN==1)||(GPRS_UP_REAL_EN==1))
                  if(Pt.PcWt==0)
                  {
                    Pt.PcWt=8;
                    
                    Pt.UpCmd=0x24;//开启上传实时数据24指令
                  
                  }
                  
                  #endif
                  

            }
            
            
            
        #endif
        
}
#endif

//无线 传感器+记录仪
#if ((RF_REC_EN==1)&&(RECORD_ENABLE==1))
void LoggerRfRec(void)
{
    if(StateA2.WorkState==WORK_STATE_RECORDING)
    {
          Pt.RecordPt++;
          
          //手动，假停状态.................................................
          if((StateB.StartMode==START_MODE_HAND)&&(StateB.StopMode==STOP_MODE_HAND)&&(Flag.HandOff==1))
          {
              LcdOFFX(OFF_HAND);
              POWER_CTL_ALL_OFF;
              if(Pt.RecordPt>=StateB.RecordTime)
              {
                  Pt.RecordPt=0;
                  
                  for(u8 j=0;j<CH_NUM;j++)
                  {
                    StateC.Value[j]=HAND_STOP;
                  }
                  
                  LoggerRecord();
              }
          }
          else//正常记录状态......................................................
          {
                RfDataToChDeel();//接收缓冲到通道缓冲
                RfLcdChDeel();//通道数据轮显
                LoggerAlarmAllSeek();//通道数据超标检测
                LoggerAlarmDeel();//通道数据报警检测
                LoggerSample();//这里有电池电压检测
            
            
              if(Pt.RecordPt>=StateB.RecordTime)
              {
                  Pt.RecordPt=0;
                  LoggerRecord();
              }

              
              if(StateB.StopMode==STOP_MODE_LATER)
              {
				
		Rtc.SS=ReadRtcD10();
				
                StrcutRtc DTime;
                DTime.Year=StateB.LaterStopTime[0];
                DTime.Month=StateB.LaterStopTime[1];
                DTime.Day=StateB.LaterStopTime[2];
                DTime.Hour=StateB.LaterStopTime[3];
                DTime.Minute=StateB.LaterStopTime[4];
                DTime.Second=StateB.LaterStopTime[5];
                RtcBcdToD10(&DTime);
                DTime.SS=DateToSeconds(&DTime);
                if(Rtc.SS>=DTime.SS)
                {
                  LoggerStop();
                  StateA2.StopCause=OFF_LATER_TIME_STOP;
                  StateA2ToEE();
                  
                }
              }
              
          }
    }
    else
    {
          POWER_CTL_ALL_OFF;
          
          LcdOFFX(StateA2.StopCause);
          if(StateA2.StopCause==OFF_LATER_TIME_START)
          {
                //定时时间小于重启时间时，立即启动
				
		Rtc.SS=ReadRtcD10();
				
                StrcutRtc DTime;
                DTime.Year=StateB.LaterStartTime[0];//定时时间
                DTime.Month=StateB.LaterStartTime[1];
                DTime.Day=StateB.LaterStartTime[2];
                DTime.Hour=StateB.LaterStartTime[3];
                DTime.Minute=StateB.LaterStartTime[4];
                DTime.Second=StateB.LaterStartTime[5];
                RtcBcdToD10(&DTime);
                DTime.SS=DateToSeconds(&DTime);
                if(Rtc.SS>=DTime.SS)
                {
                      Pt.RtcPt=0;
                      Pt.RecordPt=0;
                      Pt.RealSamplePt=0;
                      StateA2.WorkState=WORK_STATE_RECORDING;
                      
                      RestartClr();
                      
                      StateA2.StopCause=OFF_NOT;
                      
                      StrcutRtc STime;
                      STime.Year=StateA2.StartTime[0];//重启时间
                      STime.Month=StateA2.StartTime[1];
                      STime.Day=StateA2.StartTime[2];
                      STime.Hour=StateA2.StartTime[3];
                      STime.Minute=StateA2.StartTime[4];
                      STime.Second=StateA2.StartTime[5];
                      RtcBcdToD10(&STime);
                      STime.SS=DateToSeconds(&STime);
                      if(STime.SS<DTime.SS)
                      {
                        for(u8 j=0;j<6;j++)
                          StateA2.StartTime[j]=StateB.LaterStartTime[j];
                      }
                      StateA2ToEE();
                }
          }
    }

}
#endif

void SampleRecordDeel(void)
{
              //正常模式---------------------------------------------------------
              #if BSQ_ENABLE==1
              StateB.LcdRefreshMode=LCD_IMMEDIATE;
              #endif
              
              if(StateB.LcdRefreshMode==LCD_IMMEDIATE)
              {
                  SampleRealDo();//实时采样
                  
                  
                  if(Pt.RecordPt>=StateB.RecordTime)
                  {
                    Pt.RecordPt=0;
                    #if RECORD_ENABLE==1
                    LoggerRecord();//记录
                    
                    #endif
                  }
              }
              //省电模式----------------------------------------------------------
              #if BSQ_ENABLE==0
              else if(StateB.LcdRefreshMode==LCD_SYNCHRONOUS)
              {
                  //省电模式下滤波处理，提前一段时间开始连续采样FILET_NUM次
                  #if DIGITAL_FILTER_EN==1
                      #if POWER_TIME_ENABLE==1
                      if(StateB.RecordTime>POWER_D_TIME+LCD_REFRESH_TIME*FILET_NUM)
                      {
                          //提前打开电源
                          if(Pt.RecordPt==StateB.RecordTime-(POWER_D_TIME+LCD_REFRESH_TIME*FILET_NUM))
                          {
                             VT_CTL_ON;
                             
                             PowTimeStart();
                             
                             #if DIGITAL_FILTER_EN==1
                             FilterClr();//采样开始前，滤波计数清0
                             #endif
                          }
                          //电源关闭状态
                          else if(Pt.RecordPt<StateB.RecordTime-(POWER_D_TIME+LCD_REFRESH_TIME*FILET_NUM))
                          {
                            if(PowShutReady())
                            {
                              PowTimeClr();
                              

                              VT_CTL_OFF;

                            }
                          }
                      }
                      #endif
                        
                      //滤波模式实时采样,必须连续采样多个点数据
                      if(StateB.RecordTime>LCD_REFRESH_TIME*FILET_NUM)
                      {
                        if((Pt.RecordPt>(StateB.RecordTime-LCD_REFRESH_TIME*FILET_NUM))&&(Pt.RecordPt<StateB.RecordTime-1))
                        {
                           SampleRealDo();//实时采样
                        }
                      }
                      else
                      {
                        SampleRealDo();//实时采样
                      }
                  
                  #else//无滤波处理---------------------------------------------
                  
                      #if POWER_TIME_ENABLE==1
                      if(Pt.RecordPt+POWER_D_TIME==StateB.RecordTime)//提前POWER_D_TIME打开电源
                      {

                        VT_CTL_ON;

                        
                        PowTimeStart();
                      }
                      else if(Pt.RecordPt+POWER_D_TIME<StateB.RecordTime)//电源关闭状态
                      {
                        if(PowShutReady())
                        {
                          PowTimeClr();

                          VT_CTL_OFF;

                        }
                      }
                      #endif

                  #endif
                  

                  if(Pt.RecordPt+1==StateB.RecordTime)//记录前一秒采样
                  {
                    LoggerSample();
                  }
                  if(Pt.RecordPt>=StateB.RecordTime)
                  {
                    Pt.RecordPt=0;
                    LoggerCalculateValue();
                    
                    //省电模式下，记录完成后，才关电源
                    #if POWER_TIME_ENABLE==1
                    if(PowShutReady())
                    {
                      PowTimeClr();
                      

                      VT_CTL_OFF;

                    }
                    #endif
                    
                    LoggerAlarmAllSeek();
                    LcdValue();
                    
                    #if RECORD_ENABLE==1
                    LoggerRecord();
                    #endif
                  }
              }
              #endif
}

//实时采样，时间间隔 LCD_REFRESH_TIME >= 2
//全局变量：Pt.RealSamplePt，Pt.ErrCt
void SampleRealDo(void)
{
    u8 RefSampTime;
    
    //记录间隔小于10时，采样间隔为2
    if(StateB.RecordTime<10)
      RefSampTime=2;
    else
      RefSampTime=LCD_REFRESH_TIME;
    
    
    if((Pt.RealSamplePt%RefSampTime)==1) //每LCD_REFRESH_TIME 秒采样一次
    {
      //有错误,重新采样，不记录
      if(LoggerCalculateValue())
      {
         LoggerAlarmAllSeek();
         #if  ((LCD_NO==7)&&(CH_NUM<=2))
         LcdValue();
         #endif
      }
      else
      {
        Pt.ErrCt++;
      }
    }
    else if((Pt.RealSamplePt%RefSampTime)==0)
    {
        LoggerSample();
    }

    Pt.RealSamplePt++;
    if(Pt.RealSamplePt>=RefSampTime)
    {
      Pt.RealSamplePt=0;
    }
}
//记录一条数据
void LoggerRecOne(void)
{
  u16 j,Len;
  u8 BufTmp[38];
  
  NOP;
  NOP;
  NOP;
  UC1IE &=~ UCA1RXIE;
  
  #if MIN_MAX_AVG_ENABLE==1
  u16 fc;
  #endif
    
  for(Len=0,j=0;j<CH_NUM;j++)
  {
    //..................................................................
    
    if((StateC.Value[j]==SENIOR_NULL)||(StateC.Value[j]==HAND_STOP))//3.4
    {
      BufTmp[Len++]=0xff&StateC.Value[j];//LSB8
      BufTmp[Len++]=0xff&(StateC.Value[j]>>8);//HSB8
    }
    else
    {
      BufTmp[Len++]=0xff&StateC.Value[j];//LSB8
      if(0x01&(StateC.FuhaoBit>>j))//负数HSB8
      {
        BufTmp[Len]=0xff&(StateC.Value[j]>>8);
        BufTmp[Len]|=0x80;
        Len++;
        #if MIN_MAX_AVG_ENABLE==1
        fc=0x8000;
        #endif
      }
      else//正数HSB8
      {
        BufTmp[Len]=0x7f&(StateC.Value[j]>>8);
        Len++;
        #if MIN_MAX_AVG_ENABLE==1
        fc=0x0000;
        #endif
      }
    }
    

    
    #if MIN_MAX_AVG_ENABLE==1//取最小，最大，平均值
    fc=fc|StateC.Value[j];//添加符号
    if(StateA1.RecordNum==0)
    {
      if((StateC.Value[j]==SENIOR_NULL)||(StateC.Value[j]==HAND_STOP))
      {
        StateC.avg[j]=StateC.min[j]=StateC.max[j]=SENIOR_NULL;
        StateC.mum[j]=0;
        StateC.YouxiaoNum[j]=0;
      }
      else
      {
        StateC.avg[j]=StateC.min[j]=StateC.max[j]=fc;//取第一个记录点值
        StateC.mum[j]=u16_to_long(fc);
        StateC.YouxiaoNum[j]=1;
      }
      SaveMinMaxAvgToEE();//保存第一点的极值
    }
    else
    {
      //第二个点开始
      if((StateC.Value[j]==SENIOR_NULL)||(StateC.Value[j]==HAND_STOP))
      {
        continue;
      }
      //min
      StateC.min[j]=get_min(StateC.min[j],fc);
      //max
      StateC.max[j]=get_max(StateC.max[j],fc);
      //avg
      StateC.mum[j]=get_mum(StateC.mum[j],fc);
      StateC.YouxiaoNum[j]++;
      StateC.avg[j]=get_avg(StateC.mum[j],StateC.YouxiaoNum[j]);
      
      NOP;
    }
    #endif
  }
  
  
  #if L_REC_AVG_EN==1
  //每次记录的是平均值
  Len=0;
  for(j=0;j<CH_NUM;j++)
  {
      BufTmp[Len++]=0xff&StateC.LRavg[j];//LSB8
      BufTmp[Len++]=0xff&(StateC.LRavg[j]>>8);//HSB8
  }
  
  #endif
  

  WDT_CLR;
  
  #if SHUXIAN_ENABLE==0
 
        u8 QuHao;//当前存储片区号
        u32 EE_32Pt;
    
        if((StateA1.RecordNum==StateC.RecordMaxNum)&&(StateB.StopMode==STOP_MODE_FULL))//记满停止除外
        {
          NOP;NOP;
        }
        else
        {
            EE_32Pt=(StateA1.RecordNum%StateC.RecordMaxNum)*StateC.RecordBytes;//EE地址
            
            if((EE_32Pt+Len)<=StateC.E1_MaxMem)//E1未满
            {
              QuHao=0;
              I2C_EE_BufferWrite(BufTmp,EE_32Pt,Len,QuHao);
            }
            else//E1已满
            {
              u8 EE_Num=I2cSeekEE();
              if(EE_Num==1)
              {
                QuHao=0;
                EE_32Pt=(EE_32Pt-StateC.E1_MaxMem)%StateC.E1_MaxMem;
              }
              else
              {
                QuHao=1+(EE_32Pt-StateC.E1_MaxMem)/StateC.E2_MaxMem;
                EE_32Pt=(EE_32Pt-StateC.E1_MaxMem)%StateC.E2_MaxMem;
              }
              I2C_EE_BufferWrite(BufTmp,EE_32Pt,Len,QuHao);
            }
            StateA1.RecordNum++;
            StateA2.RecordOverNum=StateA1.RecordNum/StateC.RecordMaxNum;//溢出次数
                   
            if((StateA1.RecordNum==StateC.RecordMaxNum)&&(StateB.StopMode==STOP_MODE_FULL))//记满停止
            {
    
              StateA1ToEE();
              LoggerStop();
              StateA2.StopCause=OFF_RECORD_FULL;
              StateA2ToEE();

            }
            //时间间隔记录参数定时保存
            if(StateB.RecordTime>=A1_TIME)//记录间隔大于A1_TIME时，每记录一次，存一次A1，A2
            {
              StateA1ToEE();
              StateA2ToEE();

            }
            else
            {
              if(Pt.A1Pt==A1_TIME)//记录间隔小于A1_TIME时，每隔A1_TIME，存一次A1,A2
              {
                Pt.A1Pt=0;
    
                StateA1ToEE();
                StateA2ToEE();

              }
            }
        }
  
  #endif
  
  NOP; 
  NOP; 
  NOP; 
  UC1IE |= UCA1RXIE;
  
  NOP;NOP;NOP;NOP;NOP;
  
  #if RECORD_ENABLE==1
      #if PRINT_REAL_EN==1//记录一个点打印一个点曲线---------------------------------
      if(StateC.PcLinkPt==0)//没有与PC通讯时才打印
        PrintOneCurve();
      #endif
      
      #if PRINT_RT_LIST_EN==1//记录一个点打印一个数据列表----------------------------------
       if(StateC.PcLinkPt==0)//没有与PC通讯时才打印
       {
           #if RF_U1_EN==1
            U1_TO_PC;//打印前，先把U1切换到PC
            PrintOneList();
            //打印完成后，显示U1状态
            if(Pt.U1toPC==1)//这种状态下，记录仪不会记录
            {
               U1_TO_PC;
               LcdNN(U1TOPC);
            }
            else
            {
               U1_TO_RF;
               //LcdNN(HAND_START_SAMPLE);  记录仪记录一条打印一条时不显示
            }
         
           #else
            PrintOneList();        
           #endif
          
       }

      #endif
      
      #if PRINT_NEW_EN==1
      PrintDataSave();//打印缓冲区，存储需打印的数据
      #endif
  #endif
  
}


#if L_SYN_RTC_EN==1


//根据记录条数求当前时间
u32 TimeFromJLY(void)
{
  u32 tt;
  StrcutRtc time_bcd;
  
  time_bcd.Year=StateA2.StartTime[0];
  time_bcd.Month=StateA2.StartTime[1];
  time_bcd.Day=StateA2.StartTime[2];
  time_bcd.Hour=StateA2.StartTime[3];
  time_bcd.Minute=StateA2.StartTime[4];
  time_bcd.Second=StateA2.StartTime[5];
  RtcBcdToD10(&time_bcd);
  tt=DateToSeconds(&time_bcd);//把启动时间转换为秒数
  
  
  #if L_Stime_First_EN==1
    tt+=(StateA1.RecordNum-1)*StateB.RecordTime;//当前序号点时间秒数
  #else
    tt+=StateA1.RecordNum*StateB.RecordTime;//当前序号点时间秒数
  #endif
  
  return tt;
}
//比较 记录仪时间和 RTC时间， 如果判断缺少至少1条数据，则自动补数据
void SynToRtc(void)
{
     u32 j,tt,recn;
     
     //在下载数据时不补数据
     if(Download.Downloading==1)
       return;
     
     //记录仪时间
     tt=TimeFromJLY();
    
     //Rtc时间
     Rtc.SS=ReadRtcD10();
     
     //记录时间偏慢
     if(tt<Rtc.SS)
     {
       recn=(Rtc.SS-tt)/StateB.RecordTime;//需要补的数据条数
       
       Pt.RecordPt=(Rtc.SS-tt)%StateB.RecordTime;//zz
       
       //每次最多补4个数据,这样刚好是原先的1+4即5倍速度
       if(recn>4)
         recn=4;

       for(j=0;j<recn;j++)
         LoggerRecOne();
     }
     
}

//每隔30s检测一次时钟，是否偏慢
void LogSynRtcDeel(void)
{
  if(StateA2.WorkState==WORK_STATE_RECORDING)
  {
      if(Pt.LogDpt++>30)
      {
        Pt.LogDpt=0;
        SynToRtc();//如果时间偏慢自动补数据
      }
  }
}

#endif

void LoggerRecord(void)
{
  LoggerRecOne();
  
  #if L_Stime_First_EN==1
  
  if(StateA1.RecordNum==1)
  {
       RtcReadTime();
       StateA2.StartTime[0]=Rtc.Year;
       StateA2.StartTime[1]=Rtc.Month;
       StateA2.StartTime[2]=Rtc.Day;
       StateA2.StartTime[3]=Rtc.Hour;
       StateA2.StartTime[4]=Rtc.Minute;
       StateA2.StartTime[5]=Rtc.Second;
       RtcBcdToD10(&Rtc);
       StateA2ToEE();
  }
  
  #endif
  
  #if L_SYN_RTC_EN==1
    SynToRtc();//如果时间偏慢自动补数据
  #endif
  
                      #if L_REC_AVG_EN==1
                      for(u8 j=0;j<CH_NUM;j++)//每次记录后，AVG有效数清0
                        StateC.LRYouxiaoNum[j]=0;
                      #endif
  
}

void LoggerExtInt(void)
{
  
    #if (((RF_REC_EN==1)||(RF_RP_EN==1)||(RF_TXRX_470M_EN==1))||((SEN_U1_EN==1)&&(GPRS_ENABLE==1)))
      VDC33_ON;
      #if RF_REC_EN==1
      RF_IN_REC;
      #endif
    #endif
  
  
    //省电模式正常模式自动切换
    //----------------------------------------------------------------------
    #if LCD08_SD_SHIFT_EN==1
      if(Flag.LCD08_Sd_en==1)
      {
         #if LCD_NO==7
         Pt.sd_pt=0;
         WakeUp();
         #else
         if(Pt.sd_pt==0)
         {
           Pt.sd_pt=SD_TIME;
         }
         #endif
      }
    #else
      #if SD_ENABLE==1
         #if LCD_NO==7
         Pt.sd_pt=0;
         WakeUp();
         #else
         if(Pt.sd_pt==0)
         {
           Pt.sd_pt=SD_TIME;
         }
         #endif
      #endif
    #endif
  
    //------------------------------------------------------------------------
    #if ((GPRS_ENABLE==1)||(WIFI_ENABLE==1))
      GprsDueOutFromEE();   
    #endif
         
         
    #if GPRS_ENABLE==1
      
      GprsSleepFromEE();
      
      #if GPRS_UP_TIME_EN==1
      Gprs_UpTime_FromEE();//读上传间隔
      
      if(Pt.GprsDueOut>0)//上电时，有数据需要上传
      {
        Pt.Gprsing=1;
      }
      #endif
      
      
      
      #if GPRS_PRT_CAP_EN==1
      Gprs_PrtCAP_FromEE();//读打印条数容量
      #endif
      
      
    #endif
      
    #if GPRS_TC_EN==1
      Gprs_SF_XLH_FromEE();
      PrintDueOutFromEE();
    #endif
      

    #if U0U1_TONG_EN==1
    Flag.U0U1ing=1;//U0-U1通 
    #endif
    
    #if GSM_ENABLE==1
     
       #if SIM68_EN==1
       U1_TO_PC;
       #endif
     
     
       #if SMS_INV_ENABLE==1
       GsmInvInit();
       #endif
       
       #if GSM_KEY_SHUT_EN==1
           
             #if GPRS_ENABLE==1
             LcdShowOn(1);
             #endif
             
             SmsKeyRead();
             
             //错误检测，如果EE读取有误，可能是因为MCU异常，需外部看门狗复位
             #if GPRS_TC_EN==1
             
             if(((Sms.GsmKeyShut==0x00)||(Sms.GsmKeyShut==0x01))==0)
             {
                 ComSendH();
                 U1SendString("EE ERR\r\n");//zz
                 ComSendL();        
                 DogReset();//只有驱动外部看门狗复位，才能恢复正常。
             }
             
             #endif
             
             
             if(Sms.GsmKeyShut==0)//开
             {
               LcdGsmXh(31);
             }
             else//关
             {
               LcdGsmXh(100);
             }
             
             UART_U0_TXD_SET;
             #if SMS_INV_ENABLE==1
               //GSM模块电源只由电池提供
               #if SMS_BATONLY_ENABLE==1
               GSMPOW_OFF;
               UART_U0_TXD_CLR;
               Sms.GsmOff=1;//默认关机
               #else
               EM310_Rst();
               EM310_PWon();
               #endif
               
             #else //非定时发送模式
             if(Sms.GsmKeyShut==0)//开
             {
               Sms.GsmOff=0;
               SmsKeyOn();
             }
             else//关
             {
               Sms.GsmOff=0;
               SmsKeyOff();
             }
             #endif

       #else
       
             #if SMS_BATONLY_ENABLE==1
             GSMPOW_ON;
             UART_U0_TXD_SET;
             delay_ms(200);
             #endif
             
             
             EM310_Rst();
             
             GsmToPowOn();
             
       #endif
  
    #endif
    
    //-----------------------------------------------------------------
    #if LED_WORK_ENABLE==1
    Pt.LedPt=2;
    #endif
    
    #if LCD08_SD_SHIFT_EN==1
    GetSdShiftEnFromEE();
    #endif
    
    //-----------------------------------------------------------------
    #if ALARM_TIME_ENABLE==1
    AlarmedFormEE();
    #endif
    
    //-------------------------------------------------------------------
    #if ((KEY_SET_ENABLE==1)||(PRINT_NEW_EN==1)||(CO2_GSS_TTL_EN==1)||(RF_REC_EN==1)||(RF_RP_EN==1)||(RF_TXRX_470M_EN==1)\
      ||(L_LCD_BAT_EN==1))
    TB5_START;
    #endif
    
    //----------------------------------------------------------------------
   
    #if WIFI_ENABLE==1
      OFF6KeyRead();
      OFF6toOFF(Pt.Fg60FF);
    #endif
    
      
   //#if SHR1000_ENABLE==1
   //  shr1000Write();//气压传感器初始化设置
   //#endif
     
   #if OW_ENABLE==1
     OW_PORT_INI;//OW数据线初始化
   #endif
     
    #if WIRELESS_ENABLE==1//WIRELESS 与 OW 同时使用，时，WIRELESS在OW后面放置，这样DC一直开
      WirelessPowOn();//被动模式则一直打开电源
    #endif
     
   #if PRINT_REAL_EN==1//取实时曲线打印虚线点位
   GetPrintXX();
   #endif
   
   #if ((PRINT_NEW_EN==1)&&(GPRS_TC_EN==0))
   PrintNewFromEE();
   #endif
   
   #if ((RJ45_ENABLE==1)||(WIFI_ENABLE==1))
     DC_3V3_ON;
     delay_ms(400);
     
     Wifi_NET_Reset();//复位Net模块

   
     #if WIFI_ENABLE==1
     SET_NLINK_IN;//输入模式
     SET_NREADY_IN;
     #endif
   #endif
     


  #if RF_U1_EN==1
    U1ToRf();
  #endif
    
  #if SIM68_EN==1
  U1Init(115200,1);
  delay_ms(200);
  U1SendString("PSIMIPR,W,9600\r\n");
  delay_ms(200);
  U1Init(9600,0);
  

    //上电后，10秒后立即唤醒
    #if SIM68_SLP_EN==1
    SIM68_to_wake();
    StateC.AwakeWait=10;
    #endif
  
  #endif
    
  #if HTU_ENABLE==1  
  Pt.wd_pt=SEN_NULL_CT;
  Pt.sht_pt=SEN_NULL_CT;
  #endif
  
  #if PT_MAX31865_EN==1
  NTC_ON;//电源开
  rtd_io_ini();//IO口 INI
  delay_ms(10);//上电时间10ms
  for(u16 j=0;j<CH_NUM;j++)
  {
     max31865_ini(j);
     Pt.t_pt[j]=SEN_NULL_CT;
  }
  NTC_OFF;
  rtd_io_all_l();//默认全L, NTC_OFF, 省电状态
  #endif
  
  #if K_MAX31855_EN==1
  for(u16 j=0;j<CH_NUM;j++)
    Pt.k_pt[j]=SEN_NULL_CT;
  
  k_io_all_l();
  #endif
  
  
  #if OW_ENABLE==1
  for(u16 j=0;j<CH_NUM;j++)
    Pt.ow_pt[j]=SEN_NULL_CT;
  #endif
  
  
  #if SEN_MODBUS_485_EN==1
  for(u16 j=0;j<4;j++)
    StateC.sen_spt[j]=SEN_REC_TIME;//初始状态为NULL
  #endif
  
  
  #if DIGITAL_FILTER_EN==1
     #if BAT_AD_ENABLE==1
         #if BAT_FIL_EN==1
         FilterChClr(7);//对应通道数字滤波变量清0
         #endif
     #endif
  #endif
         
         
         
  
}
void LoggerInit(void)
{
      u16 j;
    
     //带RTC时间，共需6个字节
    #if ((RTC_RECORD_ENABLE==1)||(PCBSQ_RECORD_EN==1))
      #if GPRS_ENABLE==1
          #if GPRS_TC_EN==1
                #if ((GPS_MOUSE_EN==1)||(LBS_LAC_EN==1)||(LBS_JWD_EN==1))
                   StateC.RecordBytes=13;//RTC(4)+BAT(1)+GPS(8) 
                #else
                   StateC.RecordBytes=5;//RTC(4)+BAT(1)         
                #endif
          #else
                StateC.RecordBytes=17;
          #endif
      #else
          
          #if BSQ_RTC4_EN==1
             StateC.RecordBytes=4;//RTC(4)             
          #else
             StateC.RecordBytes=6;//RTC(6)             
          #endif
                
          
      #endif
    #else
    StateC.RecordBytes=0;
    #endif
    for(j=0;j<CH_NUM;j++)
      StateC.RecordBytes+=2;//每个通道占固定2个字节
   
    #if PCBSQ_RECORD_EN==1//变送器只能用1片，最大存储条数
    
      #if GPRS_MEMS_EN==1 
    
        StateC.EE_n=I2cSeekEE();
        
        //储存空间计算
        StateC.E1_MaxMem=(((u32)STATE_FIRST_ADDR-RECORD_FIRST_ADDR)/StateC.RecordBytes)*StateC.RecordBytes;
        StateC.E2_MaxMem=((((u32)1+EE_SIZE)-0)/StateC.RecordBytes)*StateC.RecordBytes;
        StateC.RecordMaxNum=StateC.E1_MaxMem/StateC.RecordBytes;
        if(StateC.EE_n>1)
          StateC.RecordMaxNum+=(StateC.E2_MaxMem/StateC.RecordBytes)*(StateC.EE_n-1); 
        
        //容量计算
        PcBsq.RecCap=StateC.RecordMaxNum;
        PCBSQ_CapToEE();
        
      #else
         StateC.E1_MaxMem=(((u32)STATE_FIRST_ADDR-RECORD_FIRST_ADDR)/StateC.RecordBytes)*StateC.RecordBytes;
         StateC.RecordMaxNum=StateC.E1_MaxMem/StateC.RecordBytes;
      #endif
         
    #else
         
        u8 EE_Num=I2cSeekEE();
        StateC.E1_MaxMem=(((u32)STATE_FIRST_ADDR-RECORD_FIRST_ADDR)/StateC.RecordBytes)*StateC.RecordBytes;//整除
        StateC.E2_MaxMem=((((u32)1+EE_SIZE)-0)/StateC.RecordBytes)*StateC.RecordBytes;
        StateC.RecordMaxNum=StateC.E1_MaxMem/StateC.RecordBytes;
        if(EE_Num>1)
          StateC.RecordMaxNum+=(StateC.E2_MaxMem/StateC.RecordBytes)*(EE_Num-1); 
        
    #endif
        
        
   
    
    //读取参数
    if(*(char *)CH_CONFIG_FLAG_ADDR==CH_CONFIG_FLAG)
    {
        EEToStateA1();
        EEToStateA2();
        EEToStateB();
    }
    else
    {
      LoggerConfigFirst();
    }

   #if BSQ_ENABLE==1
     bsq_init();
     LcdNN(StateB.Address);
     //变送器雨量固定 1天清一次
     #if BSQ_YL_ENABLE==1
     StateC.Value[YL_CH]=Pt.RainPt=0;//通道是雨量
     SET_YL1_INT; 
     #endif
   #endif
       
   #if SHUXIAN_ENABLE==1
    StateA1.RecordNum=0;
    StateA2.WorkState=WORK_STATE_RECORDING;//始终工作
    StateA2.StopCause=0;
    StateB.LcdRefreshMode=LCD_IMMEDIATE;//即时采样
    StateB.RecordTime=2;//必须
   #endif
   

   #if RECORD_ENABLE==1//记录仪手动模式
   GetHandFlagFromEE();
   #endif
   
   #if MIN_MAX_AVG_ENABLE==1
   GetMinMaxAvgFromEE();
   #endif
   //......................................................
  
   
   #if ((RF_MULTI_EN==1)||(RF_RP_EN==1))
   
      #if RF_RP_EN==1
       Pt.ScanPt=RF_RP_TIME-1;
      #endif
       
   #else
   LcdAlarmEn();
   LcdMode();
   #endif
   
  #if  ((RF_REC_EN==1)||(RF_RP_EN==1)||(RF_TXRX_470M_EN==1))
  GetRfFzFromEE();
  #endif
  
  #if RF_REC_EN==1
    GetRfSnFromEE();
  #endif
    
  #if RF_KP_EN==1
    GetKpSnFromEE();  
  #endif

 
   Flag.StartSample=START_SAMPLE_TIME;
   Flag.RstFirstSample=0;
   Flag.SampPt=0;
   Sms.IntervalPt=0;
   
   #if GPRS_ENABLE==1
   Pt.GprsRstErrPt=0;
   #endif
   
   RestartClr();
   
   #if RF_MULTI_EN==1
   MultiBufEE(2);//从EE取数据,防止复位时数据丢失
   Pt.Spt=9;
   
   
   KpInfor_FromEE();//取卡片数和记录参数
   
   #endif
   
   
    #if ((WIFI_ENABLE==1)&&(RF_YQ_EN==1))
    Read_EE_LastOne_To_RfBuf();
    #endif
    
    #if PRINT_52_42_EN==1
    GetBcFromEE();
    #endif
    
   
    POWER_CTL_ALL_OFF;
   
    Rtc.SS=ReadRtcD10();
   
    Pt.RecordPt=0;
    Pt.RealSamplePt=0;
    Pt.RtcPt=0;
    TB1_START;
}



#if BSQ_ENABLE==1
void bsq_allwaysSet(void)
{
  StateA2.StopCause=0;
  StateB.LcdRefreshMode=LCD_IMMEDIATE;//即时采样
  
  #if GPRS_TC_EN==1
    StateB.RecordTime=5;//必须zz
  #else
    StateB.RecordTime=2;
  #endif
}
void bsq_init(void)
{
  bsq_allwaysSet();
  StateA2.WorkState=WORK_STATE_RECORDING;//始终工作
  
  //读取变送器参数，记录间隔，记录条数，记录缓冲
  #if PCBSQ_RECORD_EN==1
    PCBSQ_FromEE();
    
    #if GPRS_MEMS_EN==0
    PCBSQ_CapFromEE();
    #endif
  
  #endif
}
#endif
void LoggerConfigFirst(void)
{
  u16 j;
  

    //工作参数配置 EE------------------------------------------------------------
    u8 BufA[20];
    
    StateA1.RecordNum=0;
    StateA1.CurrentBufPt=RECORD_FIRST_ADDR;
    StateA1ToEE();
    
    
    StateA2.CurrentSavePage=0;
    StateA2.RecordOverNum=0;
    
    StateA2.WorkState=WORK_STATE_RECORDING;
    StateA2.StopCause=0;
    
    for(j=0;j<6;j++)
      StateA2.StartTime[j]=start_time_first[j];
    for(j=0;j<6;j++)
      StateA2.bb[j]=0;
    StateA2ToEE();
    
    StateB.StartLaterTime=10;
    StateB.RecordTime=RECORD_TIME_FIRST;
    
    //StateB.StartMode=START_MODE_RIGHT;
    //StateB.StopMode=STOP_MODE_FIFO;
    StateB.StartMode=START_MODE_HAND;
    StateB.StopMode=STOP_MODE_HAND;
      
    StateB.LcdRefreshMode=LCD_IMMEDIATE;
    
    
    StateB.Address=1;//变送器时，复位时不初始化地址


    #if BOOT_FROM_EE_EN==1
    
    #else
        for(j=0;j<20;j++)BufA[j]=use_name_first[j];
        I2C_EE_BufferWrite(BufA,USER_NAME_ADDR,20,0);
        
        for(j=0;j<20;j++)BufA[j]=title_first[j];
        I2C_EE_BufferWrite(BufA,TITLE_ADDR,20,0);
        
        for(j=0;j<10;j++)BufA[j]=model_no_first[j];
        I2C_EE_BufferWrite(BufA,MODEL_NO_ADDR,10,0);
        
        for(j=0;j<10;j++)BufA[j]=serial_no_first[j];
        I2C_EE_BufferWrite(BufA,SERIAL_NO_ADDR,10,0);
        
    #endif
    
    for(j=0;j<6;j++)StateB.LaterStartTime[j]=0;
    for(j=0;j<6;j++)StateB.LaterStopTime[j]=0;
    StateBToEE();
    
    BufA[0]=STATE_CONFIG_FLAG;
    I2C_EE_BufferWrite(BufA,STATE_CONFIG_FLAG_ADDR,1,0);//设置完成后置标志位

    #if PCBSQ_RECORD_EN==1
      #if GPRS_ENABLE==1
        PcBsq.RecTime=(u16)60*5;//5分钟, 会自动与GPRS间隔同步设置到EE   
      #elif WIFI_ENABLE==1
        PcBsq.RecTime=60;//1分钟, wifi默认是1分钟
      #else
        PcBsq.RecTime=PCBSQ_REC_TIME_FIRST;    
      #endif
        
      #if ((BOOT_FROM_EE_EN==1)&&(WIFI_ENABLE==0))
      #else
         PCBSQ_RecTime_ToEE();  
      #endif
        
      PCBSQ_RecClr();//清空
      
      
      #if GPRS_MEMS_EN==0
         PcBsq.RecCap=PCBSQ_REC_CAP_FIRST;//单片程序这里执行容量
         PCBSQ_CapToEE();
      #endif
      
    #endif
    
  
  #if GSM_ENABLE==1
      
      #if BOOT_FROM_EE_EN==1
      
      #else
          ClrPhoneToEE();
      
          u8 buf[20];
          for(j=0;j<20;j++)
            buf[j]=0x00;
          I2C_EE_BufferWrite(buf,SMS_TITLE_ADDR,20,0);//短信标题Uni,清空
      #endif

  #endif
    
    
  #if GPRS_TC_EN==1
  Flag.XlhPt=0;
  Gprs_SF_XLH_ToEE();
  
  Pt.PrintDueout=0;
  PrintDueOutToEE();
  

  #endif
  
  
  #if ((GPRS_ENABLE==1)||(WIFI_ENABLE==1))
     Pt.GprsDueOut=0;
     GprsDueOutToEE();
  #endif
    
  
  #if GPRS_ENABLE==1

     #if BOOT_FROM_EE_EN==1//GPRS发送时是直接从EE取出的
                
     #else//出厂默认值，省电模式，IP，端口，域名，开关
        
        //省电模式
     
        #if LBS_JWD_EN==1
        Pt.GprsSleep=1;
        #else
        Pt.GprsSleep=0;       
        #endif
        GprsSleepToEE();
        
        
        #if GPRS_UP_TIME_EN==1
        buf[0]=5;
        Pt.GprsSendTime=60*5;//1分钟，单位是分钟
        I2C_EE_BufferWrite(buf,GPRS_UPTIME_ADDR,1,0);
        #endif
        
        
        #if GPRS_PRT_CAP_EN==1
        Pt.PrtCap=PRINT_NEW_CAP;//默认值
        buf[0]=0xff&(Pt.PrtCap);//低字节在前
        buf[1]=0xff&(Pt.PrtCap>>8);
        I2C_EE_BufferWrite(buf,GPRS_PRT_CAP_ADDR,2,0);
        #endif
        
       
      
        //IP
        buf[0]=112;
        buf[1]=124;
        buf[2]=106;
        buf[3]=188;
        I2C_EE_BufferWrite(buf,GPRS_IP_ADDR,4,0);
        
        //端口 8020
        buf[0]=0xff&8020;
        buf[1]=0xff&(8020>>8);
        I2C_EE_BufferWrite(buf,GPRS_PORT_ADDR,2,0);
        
        //发送间隔,已由PcBsq.RecTime同步
        
        //域名地址
        u8 domain[30];
        domain[0]='s';
        domain[1]='1';
        domain[2]='.';
        domain[3]='h';
        domain[4]='z';
        domain[5]='j';
        domain[6]='l';
        domain[7]='y';
        domain[8]='.';
        domain[9]='c';
        domain[10]='n';
        for(j=11;j<30;j++)
          domain[j]=0x00;
        I2C_EE_BufferWrite(domain,GPRS_DOMAIN_ADDR,30,0);
      
        //域名使能  1开
        buf[0]=1;
        I2C_EE_BufferWrite(buf,GPRS_DOMAIN_EN_ADDR,1,0);  
     #endif
  #endif
  
  #if SMS_INV_ENABLE==1
  u32 buf32[2];
  buf32[0]=(u32)3600*24;
  buf32[1]=0;
  GsmInvSet(buf32);
  #endif
  
  #if GSM_KEY_SHUT_EN==1
  Sms.GsmKeyShut=0;
  SmsKeySet();
  #endif
  
  #if ALARM_TIME_ENABLE==1
  AlarmedClr();
  #endif
  
  #if ALARM_BELL_TIME_EN==1
  Pt.AlarmTimePt=0;
  #endif
  
  #if LCD08_SD_SHIFT_EN==1
  SetSdShiftEnToEE(1);//默认省电模式
  #endif
  
   #if PRINT_REAL_EN==1//默认 实时曲线打印虚线点位
   StateC.PrintXB[0]=100+0x8000;//虚线点位
   StateC.PrintXB[1]=0;//虚线点位
   StateC.PrintXB[2]=100;//虚线点位
   StateC.PrintXB[3]=200;//虚线点位
   StateC.PrintXB[4]=300;//虚线点位
   SetPrintXX();
   #endif
   
  #if PRINT_NEW_EN==1
    #if GPRS_TC_EN==1
       PrintDueout_Clr();
    #else
       PrintNewClr();
    #endif
  #endif
  
  
  #if ((RF_REC_EN==1)||(RF_KP_EN==1)||(RF_RP_EN==1)||(RF_TXRX_470M_EN==1))

  VDC33_ON;
  delay_ms(50);
       
  Pt.Fz=2;
  SetRfFzToEE();
  GetRfFzFromEE();//验证是否正确
  RfSetF(Pt.Fz);
  delay_ms(100);
  RF_IN_REC;//设置完成后，始终处于接收状态
  #endif
  
  #if RF_REC_EN==1
  GetRfSnFromEE();
  #endif
  
  #if RF_MULTI_EN==1
    MultiBufEE(0);//清空

    BufA[0]=30;
    I2C_EE_BufferWrite(BufA,RF_N_ADDR,1,0);//卡片数量
      
    BufA[0]=30;//分钟
    BufA[1]=0;
    I2C_EE_BufferWrite(BufA,RF_REC_T_ADDR,2,0);//记录间隔
      
    BufA[0]=30;//分钟
    BufA[1]=0;
    I2C_EE_BufferWrite(BufA,RF_T_OUT_ADDR,2,0);//超时时间
    
  #endif
    
    
    #if PRINT_52_42_EN==1
    Pt.bcSS=0;
    Pt.bcAL=0;
    SaveBcToEE();
    #endif
  
  
  
  //通道参数FF------------------------------------------------------------------------
  channel_to_flash_fisrt();
   
  StructCurve Curve;
  for(j=0;j<CH_NUM;j++)
  {
    //水位
    #if (JLY_MODEL==_1_SW_0_500mm)
      Curve=curve_shift(sw_0_500_first);
    #elif (JLY_MODEL==_1_SW_0_1000mm)
      Curve=curve_shift(sw_0_1000_first);
   #elif (JLY_MODEL==_1_SW_0_3000mm)
      Curve=curve_shift(sw_0_3000_first);
      
   #elif (JLY_MODEL==_1_SW_0_2000mm)    
     Curve=curve_shift(sw_0_2000_first);
      
   #elif (JLY_MODEL==_1_SW_500_10mm)
      Curve=curve_shift(sw_0_500_first);
   #elif (JLY_MODEL==_1_SW_200_10mm)
      Curve=curve_shift(sw_0_200_first);
   #elif (JLY_MODEL==_1_SW_1000_10mm)
      Curve=curve_shift(sw_0_1000_first);
      
   #elif (JLY_MODEL==_2_WD_SW_1000_10mm)
      if(j==0)
       Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(sw_0_1000_first);
      
   
   #elif (JLY_MODEL==_2_SW_30m_SHD_20m)
      Curve=curve_shift(sw_0_30_first);

      
   #elif (JLY_MODEL==_1_SW_0_50_m)
       Curve=curve_shift(sw_0_50_first);
   #elif (JLY_MODEL==_2_WD_SW_0_500mm)
      if(j==0)
       Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(sw_0_500_first);
   #elif (JLY_MODEL==_2_WD_SW_0_1000mm)
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(sw_0_1000_first);
   #elif (JLY_MODEL==_2_WD_SW_0_3000mm)
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(sw_0_3000_first);
   #elif (JLY_MODEL==_2_WD_SW_500_10mm)
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(sw_0_500_first);
   //电参数
   #elif  (JLY_MODEL==_1_DY_500_10mv)
      Curve=curve_shift(v_0_500_first);
      
   #elif (JLY_MODEL==_3_DL_10A)
      Curve=curve_shift(a_0_10_first);
      
   #elif (JLY_MODEL==_3_DY_150v)
      Curve=curve_shift(v420_0_150_first);
      
      
      //醋液漏液检测
   #elif  (JLY_MODEL==_3_CF)
      Curve=curve_shift(cf_0_100_first);
   //深度
   #elif  (JLY_MODEL==_1_SDU_200_10mm)
      Curve=curve_shift(sdu_0_200_first);
   //压强
   #elif (JLY_MODEL==_1_YALI_160_10kpa)
      Curve=curve_shift(yq_0_160_first);
   #elif (JLY_MODEL==_2_YALI_160_10kpa_PTH)   
      if(j==0)
        Curve=curve_shift(yq_0_160_first);
      else
        Curve=curve_shift(pt_0_300_first);
   //PH
   #elif ((JLY_MODEL==_1_PH_0_14)||(JLY_MODEL==_3_PH_14))
       Curve=curve_shift(ph_0_14_first);
   #elif (JLY_MODEL==_2_NTC_PH)
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(ph_0_14_first);
   #elif ((JLY_MODEL==_1_YALI_400_kpa)||(JLY_MODEL==_3_YALI_400_kpa))
      Curve=curve_shift(yq_0_400_first);
   #elif (JLY_MODEL==_1_YALI_F100_100_kpa)
      Curve=curve_shift(yq_F100_100_first);
    //气体-----------------------------------------
    #elif ((JLY_MODEL==_1_CO2_5000PPM)||(JLY_MODEL==_2_CO2_5000PPM))
      Curve=curve_shift(digit_0_500_first);
    #elif (JLY_MODEL==_1_CO2_MH410D_0_10)
      Curve=curve_shift(co2_04_20_first);
    #elif (JLY_MODEL==_1_CO2_0_5)  
      Curve=curve_shift(digit_0_5_first);
    #elif (JLY_MODEL==_1_CO2_2000PPM)
      Curve=curve_shift(digit_0_200_first);
    #elif (JLY_MODEL==_1_CO2_SOHATECH_3K)
      Curve=curve_shift(digit_0_300_first);
    #elif ((JLY_MODEL==_1_CO2_Z14_5000)||(JLY_MODEL==_2_CO2_Z14_5000))
      Curve=curve_shift(co2_z14_500_first);
   
    #elif (JLY_MODEL==_1_CO2_MK400_2000)
      Curve=curve_shift(co2_mk400_200_first);
      
    #elif JLY_MODEL==_2_O2
      Curve=curve_shift(o2_0_30_first);
    #elif ((JLY_MODEL==_2_O2_CO2)||(JLY_MODEL==_1_O2))
      if(j==0)
        Curve=curve_shift(o2_0_30_first);
      else if(j==1)
        Curve=curve_shift(co2_0_100_first);
    #elif (JLY_MODEL==_1_CO2_COZIR_W10V)
      Curve=curve_shift(co2_cozir_w10v_first);
    #elif (JLY_MODEL==_3_NTC_HIH_CO2_5000PPM)
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_0_100_first);
      else
        Curve=curve_shift(digit_0_500_first);
      
    #elif (JLY_MODEL==_3_NTC_HIH_CO2TTL20BF)  
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_0_100_first);
      else
        Curve=curve_shift(co2_TTL_20BF_first);
      
    #elif (JLY_MODEL==_3_NTC_HIH_CO2TTL10BF) 
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_0_100_first);
      else
        Curve=curve_shift(co2_TTL_10BF_first);
      
    #elif (JLY_MODEL==_1_CO2_MISIR_5000)
      Curve=curve_shift(co2_MISIR_500_first);
      
    #elif (JLY_MODEL==_2_CO2_5000PPM_SD) 
      if(j==0)
        Curve=curve_shift(digit_0_500_first);
      else if(j==1)
        Curve=curve_shift(digit_0_100_first);
    #elif (JLY_MODEL==_2_CO2_5000PPM_O2)  
      if(j==0)
        Curve=curve_shift(digit_0_500_first);
      else if(j==1)
        Curve=curve_shift(o2_0_30_first); 
    #elif (JLY_MODEL==_2_CO2_2000_NTC)
      if(j==0)
        Curve=curve_shift(digit_0_200_first);
      else if(j==1)
        Curve=curve_shift(ntc_f40_100_first);
      

    #elif (JLY_MODEL==_1_VOC_0_100)
      Curve=curve_shift(voc_0_100_first);
      
      //PM2.5
    #elif ((JLY_MODEL==_1_PM25_500)||(JLY_MODEL==_3_PM25_500))
      Curve=curve_shift(pm_500_first);
      
      //PM2.5
    #elif ((JLY_MODEL==_1_PM25_TTL_1000)||(JLY_MODEL==_1_PM25_V_1000)||(JLY_MODEL==_2_PM25_TTL1000_PM25V_1000))
      Curve=curve_shift(digit_sz_pm25_0_1000_first);
      
    #elif (JLY_MODEL==_1_PM25_PWM_1000)
      Curve=curve_shift(pm_pwm_1000_first);

    #elif (JLY_MODEL==_2_PM25_TTL1000_CO2_MISIR_5000)
      if(j==0)
        Curve=curve_shift(digit_sz_pm25_0_1000_first);
      else if(j==1)
        Curve=curve_shift(co2_MISIR_500_first);
      
    #elif ((JLY_MODEL==_2_LS_SS)||(JLY_MODEL==_4_2LS_2SS))
      if((j==0)||(j==2))
      {
         Curve=curve_shift(LS_F1_5_first);
      }
      else if((j==1)||(j==3))
      {
         Curve=curve_shift(SS_0_10_first);
        
      }
      
    #elif (JLY_MODEL==_1_CO2_TTL_5000)
      Curve=curve_shift(digit_sz_0_500_first);
      
     #elif (JLY_MODEL==_2_O2_CO2_TTL_5000)
      if(j==1)
      {
        Curve=curve_shift(digit_sz_0_500_first);
      }
      else
      {
         Curve=curve_shift(o2_0_30_first);
      }
      
    #elif (JLY_MODEL==_1_CO2_TTL_20BF)
      Curve=curve_shift(co2_TTL_20BF_first);
    
    #elif (JLY_MODEL==_1_HCH2O_TTL_0_373)
      Curve=curve_shift(digit_sz_0_373_first);
      
    #elif (JLY_MODEL==_1_HCH2O_V_0_373)
      Curve=curve_shift(ch2o_v_0_373_first);
      
      
    //光合有效辐射
    #elif (JLY_MODEL==_1_GH_400_10umol)  
      Curve=curve_shift(ghyxfs_0_400_first);
    #elif (JLY_MODEL==_3_WD_SD_GH400_10umol)
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_0_100_first);
      else if(j==2)
        Curve=curve_shift(ghyxfs_0_400_first);
      
      //紫外辐射
    #elif (JLY_MODEL==_2_NTC_ZWFS)
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(zwfs_0_10_first);
      
    #elif (JLY_MODEL==_1_SSFS_0_2000)
       Curve=curve_shift(ssfs_sz0_200_first);
      
      
    //气压
    #elif (JLY_MODEL==_1_SHR_30_120_kpa)
      Curve=curve_shift(digit_qy_30_120_first);
    //照度---------------------------------------------
    #elif (JLY_MODEL==_1_GZ_65K)
      Curve=curve_shift(digit_gz_0_65k_first);
    #elif (JLY_MODEL==_1_GZ_100LX) 
      Curve=curve_shift(digit_gz_0_100lx_first);
    #elif (JLY_MODEL==_1_GZ_1000LX)  
      Curve=curve_shift(digit_gz_0_1000lx_first);
    #elif (JLY_MODEL==_1_GZ_100K)
      Curve=curve_shift(digit_gz_0_100k_first);
    #elif (JLY_MODEL==_1_GZ_200K)
      Curve=curve_shift(digit_gz_0_200k_first);
    #elif (JLY_MODEL==_1_GZV_200K)
      Curve=curve_shift(digit_gzv_0_200k_first);
    #elif (JLY_MODEL==_4_WD_SD_CO2_5000_GZ200K) 
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_0_100_first);
      else if(j==2)
        Curve=curve_shift(digit_0_500_first);
      else if(j==3)
        Curve=curve_shift(digit_gz_0_200k_first);
      
      
    #elif (JLY_MODEL==_6_2NTC_2HIH_2GZ100K)  
      if((j==0)||(j==1))
        Curve=curve_shift(ntc_f40_100_first);
      else if((j==2)||(j==3))
        Curve=curve_shift(digit_0_100_first);
      else
        Curve=curve_shift(digit_gz_0_100k_first);
      
    #elif (JLY_MODEL==_5_2WD_2SD_GZ200K)  
      if((j==0)||(j==2))
        Curve=curve_shift(ntc_f40_100_first);
      else if((j==1)||(j==3))
        Curve=curve_shift(digit_0_100_first);
      else
        Curve=curve_shift(digit_gz_0_200k_first);  
      
    #elif (JLY_MODEL==_6_WD_SD_CO2TTL5000_GZ200K_WD_TRSF)  
      if((j==0)||(j==4))
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_0_100_first);
      else if(j==2)
        Curve=curve_shift(digit_sz_0_500_first);
      else if(j==3)
        Curve=curve_shift(digit_gz_0_200k_first);
      else if(j==5)
        Curve=curve_shift(trsf_0_100_first);
      
    #elif (JLY_MODEL==_3_WD_SD_CO2TTL10000)  
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_0_100_first);
      else if(j==2)
        Curve=curve_shift(digit_sz_0_1000_first);
      
      
    #elif (JLY_MODEL==_4_WD_SD_CO2TTL5000_GZ200K)
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_0_100_first);
      else if(j==2)
        Curve=curve_shift(digit_sz_0_500_first);
      else if(j==3)
        Curve=curve_shift(digit_gz_0_200k_first);
      
    #elif (JLY_MODEL==_8_NTC_HIH_CO2TTL5000_GZ200K_QY_NH3_H2S_CH4)
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_0_100_first);
      else if(j==2)
        Curve=curve_shift(digit_sz_0_500_first);
      else if(j==3)
        Curve=curve_shift(digit_gz_0_200k_first);
      else if(j==4)
        Curve=curve_shift(digit_qy_30_120_first);//2位小数
      
      else if(j==5)
        Curve=curve_shift(NH3_v_0_50_first);//zz
      else if(j==6)
        Curve=curve_shift(H2S_v_0_50_first);
      else if(j==7)
        Curve=curve_shift(CH4_v_0_5_first);
      
    #elif (JLY_MODEL==_3_WD_TRSF_GZ200K)  
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(trsf_0_100_first);
      else if(j==2)
        Curve=curve_shift(digit_gz_0_200k_first);
      
    #elif (JLY_MODEL==_5_WD_TRSF_GZ200K_WD_SD)  
      if((j==0)||(j==3))
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(trsf_0_100_first);
      else if(j==2)
        Curve=curve_shift(digit_gz_0_200k_first);
      else if(j==4)
        Curve=curve_shift(digit_0_100_first);
      
    #elif (JLY_MODEL==_4_WD_SD_WD_GZ200K)  
      if((j==0)||(j==2))
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_0_100_first);
      else if(j==3)
        Curve=curve_shift(digit_gz_0_200k_first);
      
    #elif ((JLY_MODEL==_5_WD_SD_WD_GZ200K_CO2TTL5000)||(JLY_MODEL==_7_WD_SD_WD_GZ200K_CO2TTL5000_2WD))   
      if(j==1)
        Curve=curve_shift(digit_0_100_first);
      else if(j==3)
        Curve=curve_shift(digit_gz_0_200k_first);
      else if(j==4)
        Curve=curve_shift(digit_sz_0_500_first);
      else
        Curve=curve_shift(ntc_f40_100_first);
      
    #elif (JLY_MODEL==_2_WD_GZ100K)
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_gz_0_100k_first);
    #elif (JLY_MODEL==_2_WD_GZ200K)
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_gz_0_200k_first);
    #elif ((JLY_MODEL==_3_WD_SD_GZ100K))
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_0_100_first);
      else if(j==2)
        Curve=curve_shift(digit_gz_0_100k_first);
    #elif ((JLY_MODEL==_3_WD_SD_GZ200K))
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_0_100_first);
      else if(j==2)
        Curve=curve_shift(digit_gz_0_200k_first);
    //风速---------------------------------------------
    #elif (JLY_MODEL==_2_FS_FX)
      if(j==0)
        Curve=curve_shift(fs_0_60_first);
    #elif (JLY_MODEL==_3_FS_FX_01YL)
      if(j==0)
        Curve=curve_shift(fs_0_60_first);
    #elif ((JLY_MODEL==_4_WD_GZ100K_SD_YL01)||(JLY_MODEL==_6_WD_GZ100K_SD_YL01_FS_FX)||(JLY_MODEL==_6_WD_GZ100K_SD_YL05_FS_FX))//雨量和风向没有曲线
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_gz_0_100k_first);
      else if(j==2)
        Curve=curve_shift(digit_0_100_first);
      else if(j==4)
        Curve=curve_shift(fs_0_60_first);
      
    #elif (JLY_MODEL==_4_WD_SD_FS_FX)  
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_0_100_first);
      else if(j==2)
        Curve=curve_shift(fs_0_60_first);
      
    #elif ((JLY_MODEL==_7_WD_GZ200K_SD_YL01_FS_FX_TRWD)||(JLY_MODEL==_8_WD_GZ200K_SD_YL01_FS_FX_TRWD_TRSF))//雨量和风向无曲线

      if((j==0)||(j==6))
        Curve=curve_shift(ntc_f40_100_first);
      if(j==1)
        Curve=curve_shift(digit_gz_0_200k_first);
      else if(j==2)
        Curve=curve_shift(digit_0_100_first);
      else if(j==4)
        Curve=curve_shift(fs_0_60_first);
      else if(j==7)
        Curve=curve_shift(trsf_0_100_first);

      
    #elif (JLY_MODEL==_8B_WD_GZV200K_SD_YL01_TRWD_TRSF_FS_FX)
      if(j==0||j==4)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_gzv_0_200k_first);
      else if(j==2)
        Curve=curve_shift(digit_0_100_first);
      else if(j==5)
        Curve=curve_shift(trsf_0_100_first);
      else if(j==6)
        Curve=curve_shift(fs_0_60_first);
    #elif ((JLY_MODEL==_5_WD_GZ100K_TRWD_TRSF_SD)||(JLY_MODEL==_7_WD_GZ100K_TRWD_TRSF_SD_YL01_QY))
      if(j==0||j==2)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_gz_0_100k_first);
      else if(j==3)
        Curve=curve_shift(trsf_0_100_first);
      else if(j==4)
        Curve=curve_shift(digit_0_100_first);
      else if(j==6)
        Curve=curve_shift(digit_qy_30_120_first);
      
    #elif (JLY_MODEL==_3B_WD_GZ100K_TRSF)
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_gz_0_100k_first);
      else if(j==2)
        Curve=curve_shift(trsf_0_100_first);

      
    #elif ((JLY_MODEL==_8_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)\
           ||(JLY_MODEL==_8B_WD_GZ100K_SD_YL01_TRWD_TRSF_FS_FX)\
             )
      if(j==0||j==4)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_gz_0_100k_first);
      else if(j==2)
        Curve=curve_shift(digit_0_100_first);
      else if(j==5)
        Curve=curve_shift(trsf_0_100_first);
      else if(j==6)
        Curve=curve_shift(fs_0_60_first);
      
    #elif ((JLY_MODEL==_3_WD_SD_QY))
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_0_100_first);
      else if(j==2)
        Curve=curve_shift(digit_qy_30_120_first);//1位小数

    #elif ((JLY_MODEL==_6B_WD_SD_QY_YL01_FS_FX))
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_0_100_first);
      else if(j==2)
        Curve=curve_shift(digit_qy_1bit_30_120_first);//1位小数
      else if(j==4)
        Curve=curve_shift(fs_0_60_first);
      
    #elif (JLY_MODEL==_6_WD_SD_QY_YL01_FS_FX) 
      if(j==0)
        Curve=curve_shift(ntc_f40_100_first);
      else if(j==1)
        Curve=curve_shift(digit_0_100_first);
      else if(j==2)
        Curve=curve_shift(digit_qy_30_120_first);//2位小数
      else if(j==4)
        Curve=curve_shift(fs_0_60_first);
      
    //湿度--------------------------------------------------
    #elif (JLY_MODEL==_3_2NTC_1HIH)
      if(j==1)
        Curve=curve_shift(digit_0_100_first);
      else
        Curve=curve_shift(ntc_f40_100_first);
      
    #elif (JLY_MODEL==_8_6NTC_2HIH)
      if((j==6)||(j==7))
        Curve=curve_shift(digit_0_100_first);
      else
        Curve=curve_shift(ntc_f40_100_first);
    #elif (JLY_MODEL==_8_5NTC_3HIH)
      if((j==5)||(j==6)||(j==7))
        Curve=curve_shift(digit_0_100_first);
      else
        Curve=curve_shift(ntc_f40_100_first);
    #elif (JLY_MODEL==_8_5NTC_HIH_NTC_HIH)  
      if((j==5)||(j==7))
        Curve=curve_shift(digit_0_100_first);
      else
        Curve=curve_shift(ntc_f40_100_first);
  
    #elif (JLY_MODEL==_3_2_NTC_1HIH)   
      if(j==2)
        Curve=curve_shift(digit_0_100_first);
      else
        Curve=curve_shift(ntc_f40_100_first);
    #elif (JLY_MODEL==_4_3NTC_1HIH) 
      if(j==3)
        Curve=curve_shift(digit_0_100_first);
      else
        Curve=curve_shift(ntc_f40_100_first);
    #elif (JLY_MODEL==_6_5NTC_1HIH)   
      if(j==5)
        Curve=curve_shift(digit_0_100_first);
      else
        Curve=curve_shift(ntc_f40_100_first);
    #elif (JLY_MODEL==_8_134678NTC_25HIH)
      if((j==1)||(j==4))
        Curve=curve_shift(digit_0_100_first);
      else
        Curve=curve_shift(ntc_f40_100_first);
      
      
    #elif (JLY_MODEL==_8_7NTC_1HIH) 
      if(j==7)
        Curve=curve_shift(digit_0_100_first);
      else
        Curve=curve_shift(ntc_f40_100_first);
      
    #elif (JLY_MODEL==_7_6NTC_1HIH)  
      if(j==6)
        Curve=curve_shift(digit_0_100_first);
      else
        Curve=curve_shift(ntc_f40_100_first);
    #elif (JLY_MODEL==_5_4NTC_1HIH)
      if(j==4)
        Curve=curve_shift(digit_0_100_first);
      else
        Curve=curve_shift(ntc_f40_100_first);
    #elif (JLY_MODEL==_8_4WD_0_80_4SD_0_100)
      if(j==1||j==3||j==5||j==7)
        Curve=curve_shift(an_0_100_first);
      else
        Curve=curve_shift(an_0_80_first);
      
      
    #elif ((JLY_MODEL==_4_1NTC_1HIH_2NTC)||(JLY_MODEL==_6_1NTC_1HIH_4NTC))
      if(j==1)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      
    #elif (JLY_MODEL==_6_1PT_F40_100_1HIH_2NTC_2HIH)  
      if(j==1||j==3||j==5||j==7)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else if((j==2)||(j==4))
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      else if(j==0)
      {
        Curve=curve_shift(pt_f40_100_first);
      }
   
    #elif (JLY_MODEL==_8_3NTC_3HIH_2NTC)
      if(j==1||j==3||j==5)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
    #elif ((JLY_MODEL==_8_4NTC_4HIH5030)||(JLY_MODEL==_4_2NTC_2HIH5030)||(JLY_MODEL==_6_3NTC_3HIH5030))
      if(j==1||j==3||j==5||j==7)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
    #elif ((JLY_MODEL==_2_NTC_HIH6130)||(JLY_MODEL==_2_wdNTC_sdSHT30))
      if(j==0)
      {
          Curve=curve_shift(ntc_f40_100_first);
      }
      else if(j==1)
      {
          Curve=curve_shift(sz_0_100_first);
      }
      
    #elif (JLY_MODEL==_8_3NTC_3HIH5030_1HIH6130)
      if(j==1||j==3||j==5)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else if((j==0)||(j==2)||(j==4))
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      
      else if(j==6)
      {
          Curve=curve_shift(sz_f40_100_first);
      }
      else if(j==7)
      {
          Curve=curve_shift(sz_0_100_first);
      }

      
      
    #elif (JLY_MODEL==_7_3NTC_3HIH_CO2_Z14_5000)  
      if(j==1||j==3||j==5)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else if(j==0||j==2||j==4)
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      else if(j==6)
      {
        Curve=curve_shift(co2_z14_500_first);
      }
    #elif (JLY_MODEL==_7_3NTC_3HIH_CO2_MISIR_5000)  
      if(j==1||j==3||j==5)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else if(j==0||j==2||j==4)
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      else if(j==6)
      {
        Curve=curve_shift(co2_MISIR_500_first);
      }
    #elif (JLY_MODEL==_5_2NTC_2HIH_CO2_Z14_5000)
      if(j==1||j==3)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else if(j==0||j==2)
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      else if(j==4)
      {
        Curve=curve_shift(co2_z14_500_first);
      }
    #elif (JLY_MODEL==_5_2NTC_2HIH_CO2_MISIR_5000)  
      if(j==1||j==3)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else if(j==0||j==2)
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      else if(j==4)
      {
        Curve=curve_shift(co2_MISIR_500_first);
      }
    #elif (JLY_MODEL==_4_2PT_F50_200_2HIH) 
      if(j==1||j==3)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else
      {
        Curve=curve_shift(pt_f50_200_first);
      }
      
    #elif (JLY_MODEL==_4_2PTH_2HIH)  
      if(j==1||j==3)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else
      {
        Curve=curve_shift(pt_0_300_first);
      }
      
    #elif (JLY_MODEL==_4_2PT_F50_100_2HIH)  
      if(j==1||j==3)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else
      {
        Curve=curve_shift(pt_f50_100_first);
      }
    
    #elif  (JLY_MODEL==_8_4PT_4ROTYONIC)
      if(j<4)
      {
        Curve=curve_shift(pt_0_300_first);
      }
      else
      {
        Curve=curve_shift(rotronic_0_100_first);
      }
      
   #elif (JLY_MODEL==_1_ROTYONIC)
      Curve=curve_shift(rotronic_0_100_first);
      
    #elif ((JLY_MODEL==_6_2PT_2ROTYONIC_NTC_HIH)||(JLY_MODEL==_2_1PT_1ROTYONIC))
      if(j==5)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else if(j==4)
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      else if(j==0||j==2)
      {
        Curve=curve_shift(pt_0_300_first);
      }
      else if(j==1||j==3)
      {
        Curve=curve_shift(rotronic_0_100_first);
      }
    #elif (JLY_MODEL==_6_4NTC_2HIH5030)
      if(j==4||j==5)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
    #elif ((JLY_MODEL==_1_HIH5030)||(JLY_MODEL==_2_HIH5030)||(JLY_MODEL==_4_HIH5030)||(JLY_MODEL==_6_HIH5030)||(JLY_MODEL==_8_HIH5030))
      Curve=curve_shift(digit_0_100_first);
    
      
    #elif ((JLY_MODEL==_1_SD420mA_0_100)||(JLY_MODEL==_2_SD420mA_0_100))
      Curve=curve_shift(an_0_100_first);
      
    #elif ((JLY_MODEL==_4_WD420mA_0_800)||(JLY_MODEL==_1_WD420mA_0_800))
      Curve=curve_shift(an_0_800_first);
      
    #elif (JLY_MODEL==_1_WD420mA_0_500)
      Curve=curve_shift(an_0_500_first);
      
      
    #elif (JLY_MODEL==_3_WD_F10_60_SD_0_100_JDSD_0_200) 
      if(j==0)
      {
        Curve=curve_shift(an_f10_60_first);
      }
      else if(j==1)
      {
        Curve=curve_shift(an_0_100_first);
      }
      else if(j==2)
      {
        Curve=curve_shift(an_0_200_first);
      }
      
    #elif (JLY_MODEL==_4_WD420mA_0_400)
      Curve=curve_shift(an_0_400_first);
    
    #elif (JLY_MODEL==_6_3PT_0_300_3HIH) 
        if(j>2)
        {
          Curve=curve_shift(digit_0_100_first);
        }
        else
        {
          Curve=curve_shift(pt_0_300_first);
        }
    #elif (JLY_MODEL==_8_4PT_0_300_4HIH)    
        if(j>3)
        {
          Curve=curve_shift(digit_0_100_first);
        }
        else
        {
          Curve=curve_shift(pt_0_300_first);
        }
    #elif (JLY_MODEL==_4_2PT_F40_100_2HIH)    
        if((j%2)==1)
        {
          Curve=curve_shift(digit_0_100_first);
        }
        else
        {
          Curve=curve_shift(pt_f40_100_first);
        }
    #elif (JLY_MODEL==_4_2PT_F200_100_2HIH)   
        if((j%2)==1)
        {
          Curve=curve_shift(digit_0_100_first);
        }
        else
        {
          Curve=curve_shift(pt_f200_100_first);
        }
        
    #elif (JLY_MODEL==_4_2PT_F100_200_2HIH)     
        if((j%2)==1)
        {
          Curve=curve_shift(digit_0_100_first);
        }
        else
        {
          Curve=curve_shift(pt_f100_200_first);
        }
        
    #elif (JLY_MODEL==_8_4PT_F40_100_4HIH)     
        if(j>3)
        {
          Curve=curve_shift(digit_0_100_first);
        }
        else
        {
          Curve=curve_shift(pt_f40_100_first);
        }
    #elif (JLY_MODEL==_3_1NTC_1HIH_1PT_F40_100)
        if(j==1)
        {
          Curve=curve_shift(digit_0_100_first);
        }
        else if(j==0)
        {
          Curve=curve_shift(ntc_f40_100_first);
        }
        else if(j==2)
        {
          Curve=curve_shift(pt_f40_100_first);
        }
        
    #elif (JLY_MODEL==_2_NTC_01YL)    
        if(j==0)
        {
          Curve=curve_shift(ntc_f40_100_first);
        }

        
    #elif ((JLY_MODEL==_2_NTC_HIH5030)||(JLY_MODEL==_3_NTC_HIH5030_01YL))
        if(j==1)
        {
          Curve=curve_shift(digit_0_100_first);
        }
        else
        {
          Curve=curve_shift(ntc_f40_100_first);
        }
    #elif (JLY_MODEL==_4_1PT_F100_200_2NTC_1HIH)    
        if(j==0)
        {
          Curve=curve_shift(pt_f100_200_first);
        }
        else if(j==3)
        {
          Curve=curve_shift(digit_0_100_first);
        }
        else
        {
          Curve=curve_shift(ntc_f40_100_first);
        }
        
        
    #elif (JLY_MODEL==_2_1PT_F100_100_1HIH)
        if(j==1)
        {
          Curve=curve_shift(digit_0_100_first);
        }
        else
        {
          Curve=curve_shift(pt_f100_100_first);
        }
        
    #elif (JLY_MODEL==_2_1PT_F100_200_1HIH)
        if(j==1)
        {
          Curve=curve_shift(digit_0_100_first);
        }
        else
        {
          Curve=curve_shift(pt_f100_200_first);
        }
        
    #elif (JLY_MODEL==_2_1PT_F200_100_1HIH)    
        if(j==1)
        {
          Curve=curve_shift(digit_0_100_first);
        }
        else
        {
          Curve=curve_shift(pt_f200_100_first);
        }   
        
    #elif (JLY_MODEL==_2_1PT_F40_150_1HIH)
        if(j==1)
        {
          Curve=curve_shift(digit_0_100_first);
        }
        else
        {
          Curve=curve_shift(pt_f40_150_first);
        }
    #elif (JLY_MODEL==_4_2PT_F50_250_2HIH)
        if(j>1)
        {
          Curve=curve_shift(digit_0_100_first);
        }
        else
        {
          Curve=curve_shift(pt_f50_250_first);
        }
    #elif (JLY_MODEL==_2_1PT_F50_250_1HIH)    
        if(j==1)
        {
          Curve=curve_shift(digit_0_100_first);
        }
        else
        {
          Curve=curve_shift(pt_f50_250_first);
        }
    #elif (JLY_MODEL==_2_1PT_F50_200_1HIH)    
        if(j==1)
        {
          Curve=curve_shift(digit_0_100_first);
        }
        else
        {
          Curve=curve_shift(pt_f50_200_first);
        } 
    #elif (JLY_MODEL==_2_1PT_0_300_1HIH)
        if(j==1)
        {
          Curve=curve_shift(digit_0_100_first);
        }
        else
        {
          Curve=curve_shift(pt_0_300_first);
        }
    #elif (JLY_MODEL==_3_2PT_0_300_1HIH)
        if(j==2)
        {
          Curve=curve_shift(digit_0_100_first);
        }
        else
        {
          Curve=curve_shift(pt_0_300_first);
        }
    #elif ((JLY_MODEL==_2_WDHTU_SDHTU)||(JLY_MODEL==_2_WDHIH6130_SDHIH6130)||(JLY_MODEL==_2_wdSHT30_sdSHT30))
        if(j==0)
        {
          Curve=curve_shift(sz_f40_100_first);
        }
        else if(j==1)
        {
          Curve=curve_shift(sz_0_100_first);
        }
        
    #elif (JLY_MODEL==_20_NTC_SHT)
        if(j==0)
        {
          Curve=curve_shift(ntc_f40_100_first);
        }
        else if(j==1)
        {
          Curve=curve_shift(digit_sht_humi_first);
        }
    #elif (JLY_MODEL==_20_SHT) 
        if(j==0)
        {
          Curve=curve_shift(digit_f40_100_first);
        }
        else if(j==1)
        {
          Curve=curve_shift(digit_sht_humi_first);
        }

    //土壤水分
    #elif ((JLY_MODEL==_1_TRSF)||(JLY_MODEL==_4_TRSF)||(JLY_MODEL==_5_TRSF)||(JLY_MODEL==_6_TRSF)\
      ||(JLY_MODEL==_3_TRSF)||(JLY_MODEL==_2_TRSF))
       Curve=curve_shift(trsf_0_100_first);
       
    #elif (JLY_MODEL==_7_4NTC_2TRSF_1HIH)
      if((j==0)||(j==1)||(j==2)||(j==3))
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      else if(j==6)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else if((j==4)||(j==5))
      {
        Curve=curve_shift(trsf_0_100_first);
      }
      
    #elif (JLY_MODEL==_6_4NTC_1HIH_1TRSF)  
      if((j==0)||(j==1)||(j==2)||(j==3))
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      else if(j==4)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else if(j==5)
      {
        Curve=curve_shift(trsf_0_100_first);
      }
      
    #elif (JLY_MODEL==_3_2NTC_TRSF)
      if(j==2)
      {
        Curve=curve_shift(trsf_0_100_first);
      }
      else
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
    #elif (JLY_MODEL==_3_NTC_HIH_TRSF)  
      if(j==0)
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      else if(j==1)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else if(j==2)
      {
        Curve=curve_shift(trsf_0_100_first);
      }
      
      
    #elif (JLY_MODEL==_4_NTC_HIH_NTC_TRSF)
      if((j==0)||(j==2))
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      else if(j==1)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else if(j==3)
      {
        Curve=curve_shift(trsf_0_100_first);
      }
    #elif (JLY_MODEL==_5_4NTC_TRSF)  
      if(j==4)
      {
        Curve=curve_shift(trsf_0_100_first);
      }
      else
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
    #elif ((JLY_MODEL==_5_1W1TRSF_1W1TRSF_1W)||(JLY_MODEL==_6_1W1TRSF_1W1TRSF_2W))
      if(j==1||j==3)
      {
        Curve=curve_shift(trsf_0_100_first);
      }
      else
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
    #elif ((JLY_MODEL==_2_NTC_TRSF)||(JLY_MODEL==_4_2NTC_2TRSF)\
         ||(JLY_MODEL==_6_3NTC_3TRSF)||(JLY_MODEL==_8_4NTC_4TRSF))
      if(j==1||j==3||j==5||j==7)
      {
        Curve=curve_shift(trsf_0_100_first);
      }
      else
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      
   #elif (JLY_MODEL==_6_3NTC_3EC5)   
      if(j==1||j==3||j==5)
      {
        Curve=curve_shift(sz_0_100_first);//ec5 类似 HIH  已经通过公式算出值了
      }
      else
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      
    
   #elif (JLY_MODEL==_4_TRWD_TRSF_TYFS_ZF)  
      if(j==0)
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      else if(j==1)
      {
        Curve=curve_shift(trsf_0_100_first);
      }
      else if(j==2)
      {
        Curve=curve_shift(tyfs_200_first);
      }
      else if(j==3)
      {
        Curve=curve_shift(zf_240_first);
      }
      
    #elif (JLY_MODEL==_8_4NTC_2HIH_2TRSF)
      if(j==5||j==7)
      {
        Curve=curve_shift(trsf_0_100_first);
      }
      else if(j==1||j==3)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
    #elif (JLY_MODEL==_6_1NTC_1HIH_2NTC_2TRSF)
      if(j==3||j==5)
      {
        Curve=curve_shift(trsf_0_100_first);
      }
      else if(j==1)
      {
        Curve=curve_shift(digit_0_100_first);
      }
      else
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      
    //电阻
    #elif (JLY_MODEL==_1_DZ_0_60_R)
      Curve=curve_shift(pt_0_60_first);
      
    //温度----------------------------------------------------------------
    #elif ((JLY_MODEL==_1_K_F200_1350)||(JLY_MODEL==_2_K_F200_1350_COLD)||(JLY_MODEL==_3_K_F200_1350))
      Curve=curve_shift(digit_f200_1350_first);
      
    #elif ((JLY_MODEL==_1_RTD_F200_300)||(JLY_MODEL==_4_RTD_F200_300))
      Curve=curve_shift(digit_f200_300_first);
      
    #elif (JLY_MODEL==_2_K_F200_1350_DS_F55_125)  
      if(j==0)
        Curve=curve_shift(digit_f200_1350_first);
      else if(j==1)
      {
        Curve=curve_shift(digit_f55_125_first);
      }
      
    #elif ((JLY_MODEL==_1_PT_0_300)||(JLY_MODEL==_2_PT_0_300)\
      ||(JLY_MODEL==_3_PT_0_300)||(JLY_MODEL==_4_PT_0_300))
      Curve=curve_shift(pt_0_300_first);
      
    
    #elif (JLY_MODEL==_5_4PT_0_300_1NTC)
      if(j==4)
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      else
      {
        Curve=curve_shift(pt_0_300_first);
      }
    #elif (JLY_MODEL==_8_3PT_F100_100_5NTC)  
      if(j<=2)
      {
        Curve=curve_shift(pt_f100_100_first);
        
      }
      else
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      
    #elif ((JLY_MODEL==_3_PT_F100_100_2NTC)||(JLY_MODEL==_4_PT_F100_100_3NTC))  
      if(j==0)
      {
        Curve=curve_shift(pt_f100_100_first);
        
      }
      else
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      
    #elif ((JLY_MODEL==_8_1PT_F100_200_7NTC)||(JLY_MODEL==_2_1PT_F100_200_1NTC))
      if(j==0)
      {
        Curve=curve_shift(pt_f100_200_first);
        
      }
      else
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      
    #elif (JLY_MODEL==_5_4PT_F100_200_1NTC)
      if(j==4)
      {
        Curve=curve_shift(ntc_f40_100_first);
      }
      else
      {
        Curve=curve_shift(pt_f100_200_first);
      }
    
    #elif (JLY_MODEL==_1_PT_0_200)
      Curve=curve_shift(pt_0_200_first);
      
    #elif ((JLY_MODEL==_1_PT_F40_100)||(JLY_MODEL==_2_PT_F40_100)||(JLY_MODEL==_4_PT_F40_100)||(JLY_MODEL==_3_PT_F40_100))
      Curve=curve_shift(pt_f40_100_first);
      
    #elif (JLY_MODEL==_1_PT_F40_70)
      Curve=curve_shift(pt_f40_70_first);
     
    #elif (JLY_MODEL==_1_PT_F20_120)  
      Curve=curve_shift(pt_f20_120_first);
      
    #elif (JLY_MODEL==_1_PT_F40_120)
      Curve=curve_shift(pt_f40_120_first);
      
    #elif (JLY_MODEL==_1_PT_F40_250) 
      Curve=curve_shift(pt_f40_250_first);
      
    #elif (JLY_MODEL==_1_PT_F200_100) 
      Curve=curve_shift(pt_f200_100_first);
    
    #elif (JLY_MODEL==_1_PT_F200_200)
      Curve=curve_shift(pt_f200_200_first);
      
    #elif ((JLY_MODEL==_1_PT_F100_200)||(JLY_MODEL==_2_PT_F100_200)\
          ||(JLY_MODEL==_1_PT_F200_50)\
            ||(JLY_MODEL==_3_PT_F100_200)||(JLY_MODEL==_4_PT_F100_200))
      Curve=curve_shift(pt_f100_200_first);
      
    #elif (JLY_MODEL==_8_4PT_F100_200_4HIH)  
      
      if(j<4)
      {
        Curve=curve_shift(pt_f100_200_first);
      }
      else
      {
        Curve=curve_shift(digit_0_100_first);
      }
      
    #elif (JLY_MODEL==_8_4PT_F100_300_4HIH)   
      
      if(j<4)
      {
        Curve=curve_shift(pt_f100_300_first);
      }
      else
      {
        Curve=curve_shift(digit_0_100_first);
      }
      
    #elif (JLY_MODEL==_2_PT_F100_200_PH)
      if(j==0)
      {
        Curve=curve_shift(pt_f100_200_first);
      }
      else
      {
        Curve=curve_shift(ph_0_14_first);
      }
      
    #elif ((JLY_MODEL==_2_PT_F200_100)||(JLY_MODEL==_3_PT_F200_100)||(JLY_MODEL==_4_PT_F200_100))
      Curve=curve_shift(pt_f200_100_first);
      
    #elif ((JLY_MODEL==_2_PT_F100_100)||(JLY_MODEL==_4_PT_F100_100)||(JLY_MODEL==_1_PT_F100_100)||(JLY_MODEL==_3_PT_F100_100))
      Curve=curve_shift(pt_f100_100_first);
      
    #elif (JLY_MODEL==_4_PT_F150_150)
      Curve=curve_shift(pt_f150_150_first);
     
    #elif ((JLY_MODEL==_3_PT_F50_250)||(JLY_MODEL==_2_PT_F50_250)||(JLY_MODEL==_4_PT_F50_250))
      Curve=curve_shift(pt_f50_250_first);
      
    #elif (JLY_MODEL==_4_PT_F50_200)
      Curve=curve_shift(pt_f50_200_first);
      
    #elif (JLY_MODEL==_4_PT_F50_150)
      Curve=curve_shift(pt_f50_150_first);
      
    #elif ((JLY_MODEL==_3_PT_F50_300)||(JLY_MODEL==_1_PT_F50_300))
      Curve=curve_shift(pt_f50_300_first);
      
    #elif (JLY_MODEL==_2_PT_F50_350)
      Curve=curve_shift(pt_f50_350_first);
      
    #elif (JLY_MODEL==_4_PT_F50_300)
      Curve=curve_shift(pt_f50_300_first);
      
    #elif ((JLY_MODEL==_1_NTC_F20_120)||(JLY_MODEL==_2_NTC_F20_120))
      Curve=curve_shift(ntc_f20_120_first);
      
    #elif ((JLY_MODEL==_6_DS18B20_F55_125)||(JLY_MODEL==_8_DS18B20_F55_125)||(JLY_MODEL==_1_DS18B20_F55_125)||(JLY_MODEL==_2_DS18B20_F55_125)\
      ||(JLY_MODEL==_4_DS18B20_F55_125)||(JLY_MODEL==_3_DS18B20_F55_125))
      Curve=curve_shift(digit_f55_125_first);
      
    #elif (JLY_MODEL==_2_DS18B20_HIH)
      if(j==0)
        Curve=curve_shift(digit_f55_125_first);
      else
        Curve=curve_shift(digit_0_100_first);
    //-----------------------------------------------------------------
    #else
      Curve=curve_shift(ntc_f40_100_first);
    #endif
      
    CurveBufToFlash(&Curve,j);
  }
  
  
}

StructCurve curve_shift(StructCurve dd)
{
  StructCurve cc;
  cc=dd;
  return cc;
}

//设置报警或控制参数
void alarm_buf_to_flash(u8* buf,u8 ch_no,u8 CC)
{
  char *pt1,*pt2;
  u16 i,j;
  char tmp[512];
  
  pt1=(char *)CH_CONFIG_FLAG_ADDR;
  pt2=tmp;
  for(j=0;j<512;j++)
    *pt2++=*pt1++;
  
  pt1=(char *)CH_CONFIG_FLAG_ADDR;
  pt2=tmp;
  delay_us(300);
  WDT_STOP;
  FLASH_CLK_INIT;
  FCTL3 = FWKEY;
  FCTL1 = FWKEY + ERASE;
  *pt1 = 0;
  FCTL1 = FWKEY + WRT;                    
  
  *pt1++=*pt2++;
  *pt1++=*pt2++;
  
  for(j=0;j<CH_MAX_NUM;j++)
  {
    for(i=0;i<ONE_CH_CONFIG_BYTES;i++)
    {
      if(CC==1)//报警上限，报警下限，报警使能
      {
          if((ch_no==j)&&(i==0||i==1||i==2||i==3||i==8))
            *pt1=*buf++;
          else
            *pt1=*pt2;
      }
      else if(CC==2)//控制上限，控制下限，控制使能
      {
          if((ch_no==j)&&(i==13||i==14||i==15||i==16||i==17))
            *pt1=*buf++;
          else
            *pt1=*pt2;
      }

      pt1++;
      pt2++;
    }
  }
  
  FCTL1 = FWKEY;                    
  FCTL3 = FWKEY + LOCK; 
  WDT_START;
}

//所有通道报警使能设置
//ch=99为所有通道，ch!=99为单个通道
void ChAEnToFlash(u8 ch,u8 EN)
{
  char *pt1,*pt2;
  u16 i,j;
  char tmp[512];
  
  pt1=(char *)CH_CONFIG_FLAG_ADDR;
  pt2=tmp;
  for(j=0;j<512;j++)
    *pt2++=*pt1++;
  
  pt1=(char *)CH_CONFIG_FLAG_ADDR;
  pt2=tmp;
  delay_us(600);
  WDT_STOP;
  FLASH_CLK_INIT;
  FCTL3 = FWKEY;                          
  FCTL1 = FWKEY + ERASE;
  *pt1 = 0;
  FCTL1 = FWKEY + WRT;                    
  
  *pt1++=*pt2++;
  *pt1++=*pt2++;
  
  for(j=0;j<CH_MAX_NUM;j++)
  {
    for(i=0;i<ONE_CH_CONFIG_BYTES;i++)
    {
      if(i==8)//报警使能位
      {
        if(ch==99)//所有通道
          *pt1=EN;
        else
        {
          if(j==ch)//单个通道
            *pt1=EN;
          else
            *pt1=*pt2;
        }
      }
      else
      {
        *pt1=*pt2;
      }

      pt1++;
      pt2++;
    }
  }
  
  FCTL1 = FWKEY;                    
  FCTL3 = FWKEY + LOCK; 
  WDT_START;
}
void channel_to_flash_fisrt(void)
{
  char *pt1,*pt2;
  u16 i,j;
  char tmp[512];
  
  pt1=(char *)CH_CONFIG_FLAG_ADDR;
  pt2=tmp;
  for(j=0;j<512;j++)
    *pt2++=*pt1++;
 
  pt1=(char *)CH_CONFIG_FLAG_ADDR;
  pt2=tmp;
  delay_us(600);
  WDT_STOP;
  FLASH_CLK_INIT;
  FCTL3 = FWKEY;
  FCTL1 = FWKEY + ERASE;
  *pt1 = 0;
  FCTL1 = FWKEY + WRT;
  
  *pt1++=CH_CONFIG_FLAG;
  *pt1++=CH_NUM;
  pt2++;
  pt2++;
  
  for(j=0;j<CH_MAX_NUM;j++)
  {
    *pt1++=0xff&channel_first[j].alarm_L;
    *pt1++=0xff&(channel_first[j].alarm_L>>8);
    *pt1++=0xff&channel_first[j].alarm_H;
    *pt1++=0xff&(channel_first[j].alarm_H>>8);
    *pt1++=0xff&channel_first[j].value_L;
    *pt1++=0xff&(channel_first[j].value_L>>8);
    *pt1++=0xff&channel_first[j].value_H;
    *pt1++=0xff&(channel_first[j].value_H>>8);
    *pt1++=channel_first[j].alarm_E;
    *pt1++=channel_first[j].type;
    *pt1++=channel_first[j].unit;
    *pt1++=channel_first[j].style;
    *pt1++=channel_first[j].ref;
    *pt1++=0xff&(221+j);
    *pt1++=0xff&((0x8000+221+j)>>8);//控制下限
    *pt1++=0xff&(281+j);
    *pt1++=0xff&((281+j)>>8);//控制上限
    *pt1++=0;//控制使能
    
     pt2+=ONE_CH_BYTES;
     for(i=0;i<ONE_CURVE_BYTES;i++)
     {
       *pt1++=*pt2++;
     }
  }
  
  FCTL1 = FWKEY;                      
  FCTL3 = FWKEY + LOCK;                 
  WDT_START; 
}
void CurveBufToFlash(StructCurve* Curve,u8 ch_no)
{
  char *pt1,*pt2;
  u16 i,j,k;
  
  char tmp[512];

  pt1=(char *)CH_CONFIG_FLAG_ADDR;
  pt2=tmp;
  for(j=0;j<512;j++)
   *pt2++=*pt1++;

  pt1=(char *)CH_CONFIG_FLAG_ADDR;
  pt2=tmp;
  
  delay_us(600);
  WDT_STOP;
  FLASH_CLK_INIT;
  FCTL3 = FWKEY;                          
  FCTL1 = FWKEY + ERASE;
  *pt1 = 0;
  FCTL1 = FWKEY + WRT;     
  
  *pt1++=*pt2++;
  *pt1++=*pt2++;
  
  for(j=0;j<CH_MAX_NUM;j++)
  {
    for(i=0;i<ONE_CH_BYTES;i++)
    {
      *pt1++=*pt2++;
    }
    for(i=0;i<ONE_CURVE_BYTES;i++)
    {
      if(ch_no==j)
      {
        for(k=0;k<15;k++)
        {
          *pt1++=0xff&Curve->Point[k];
          *pt1++=0xff&(Curve->Point[k]>>8);
        }
        for(k=0;k<14;k++)
        {
          *pt1++=Curve->Space[k];
        }
        *pt1++=Curve->PointNum;
        
        pt2+=ONE_CURVE_BYTES;
        break;
      }
      else
      {
        *pt1++=*pt2++;
      }
    }
  }
  
  FCTL1 = FWKEY;                    
  FCTL3 = FWKEY + LOCK; 
  WDT_START;
}
void CurveFlashToBuf(StructCurve* Curve,u8 ChNo)
{
  u16 j;
  for(j=0;j<15;j++)
  {
    Curve->Point[j]= *((char *)CURVE1_POINT_ADDR+1+ONE_CH_CONFIG_BYTES*ChNo+j*2);
    Curve->Point[j]=Curve->Point[j]*256+*((char *)CURVE1_POINT_ADDR+ONE_CH_CONFIG_BYTES*ChNo+j*2);
  }
  for(j=0;j<14;j++)
    Curve->Space[j]=*((char *)CURVE1_SPACE_ADDR+(ONE_CH_CONFIG_BYTES)*ChNo+j); 
  Curve->PointNum=*((char *)CURVE1_POINT_NUM_ADDR+(ONE_CH_CONFIG_BYTES)*ChNo); 
}
//.................................................................................
//保存手动标志
void SaveHandFlagToEE(void)
{

   u8 BufTmp[1];
   BufTmp[0]=Flag.HandOff;
   I2C_EE_BufferWrite(BufTmp,HANG_SS_ADDR,1,0);//保存标志

}
//读取手动标志
void GetHandFlagFromEE(void)
{

    u8 BufTmp[1];
    I2C_EE_BufferRead(BufTmp,HANG_SS_ADDR,1,0);
    Flag.HandOff=BufTmp[0];
    if(Flag.HandOff!=0)Flag.HandOff=1;

}
//读取最大最小平均值
void GetMinMaxAvgFromEE(void)
{

    #if SHUXIAN_ENABLE==0
      #if MIN_MAX_AVG_ENABLE==1
      u8 j;
      u8 BufTmp[4];
      u32 xx;
      
      for(j=0;j<CH_NUM;j++)
      {
          I2C_EE_BufferRead(BufTmp,CH1_MIN_ADDR+j*2,2,0);
          StateC.min[j]=U8_TO_U16(BufTmp[1],BufTmp[0]);
        
          I2C_EE_BufferRead(BufTmp,CH1_MAX_ADDR+j*2,2,0);
          StateC.max[j]=U8_TO_U16(BufTmp[1],BufTmp[0]);
    
          I2C_EE_BufferRead(BufTmp,CH1_MUM_ADDR+j*4,4,0);
          StateC.mum[j]=U8_TO_U32(BufTmp[3],BufTmp[2],BufTmp[1],BufTmp[0]);
    
          I2C_EE_BufferRead(BufTmp,CH1_YOUXIAONUM_ADDR+j*4,4,0);
          StateC.YouxiaoNum[j]=U8_TO_U32(BufTmp[3],BufTmp[2],BufTmp[1],BufTmp[0]);
        
          xx=(StateC.mum[j]*10)/StateC.YouxiaoNum[j];
          StateC.avg[j]=Get45(xx);
      }
      #endif
    #endif

}
//保存最大最小平均值
void SaveMinMaxAvgToEE(void)
{

    #if SHUXIAN_ENABLE==0
      #if MIN_MAX_AVG_ENABLE==1
      u8 BufTmp[4];
      for(u8 j=0;j<CH_NUM;j++)
      {
          BufTmp[0]=0xff&StateC.min[j];
          BufTmp[1]=0xff&(StateC.min[j]>>8);
          I2C_EE_BufferWrite(BufTmp,CH1_MIN_ADDR+j*2,2,0);
          BufTmp[0]=0xff&StateC.max[j];
          BufTmp[1]=0xff&(StateC.max[j]>>8);
          I2C_EE_BufferWrite(BufTmp,CH1_MAX_ADDR+j*2,2,0);
        
          BufTmp[0]=0xff&StateC.mum[j];
          BufTmp[1]=0xff&(StateC.mum[j]>>8);
          BufTmp[2]=0xff&(StateC.mum[j]>>16);
          BufTmp[3]=0xff&(StateC.mum[j]>>24);
          I2C_EE_BufferWrite(BufTmp,CH1_MUM_ADDR+j*4,4,0);
          
          BufTmp[0]=0xff&StateC.YouxiaoNum[j];
          BufTmp[1]=0xff&(StateC.YouxiaoNum[j]>>8);
          BufTmp[2]=0xff&(StateC.YouxiaoNum[j]>>16);
          BufTmp[3]=0xff&(StateC.YouxiaoNum[j]>>24);
          I2C_EE_BufferWrite(BufTmp,CH1_YOUXIAONUM_ADDR+j*4,4,0);
      }
      #endif
    #endif

}
void StateA1ToEE(void)
{

  u8 BufTmp[6];
  u16 i,Len;
  i=0;
  WDT_CLR;
  BufTmp[i++]=0xff&StateA1.RecordNum;
  BufTmp[i++]=0xff&(StateA1.RecordNum>>8);
  BufTmp[i++]=0xff&(u8)(StateA1.RecordNum>>16);
  BufTmp[i++]=0xff&(u8)(StateA1.RecordNum>>24);
  BufTmp[i++]=0xff&StateA1.CurrentBufPt;
  BufTmp[i++]=0xff&(StateA1.CurrentBufPt>>8);
  Len=i;
  I2C_EE_BufferWrite(BufTmp,RECORD_NUM_ADDR,Len,0);
  SaveMinMaxAvgToEE();
  NOP;

}
void StateA2ToEE(void)
{

  u8 BufTmp[17];
  u16 j,Len;
  Len=0;
  WDT_CLR;
  BufTmp[Len++]=0xff&StateA2.CurrentSavePage;
  BufTmp[Len++]=0xff&(StateA2.CurrentSavePage>>8);
  BufTmp[Len++]=StateA2.RecordOverNum;
  BufTmp[Len++]=StateA2.WorkState;
  BufTmp[Len++]=StateA2.StopCause;
  for(j=0;j<6;j++)BufTmp[Len++]=StateA2.StartTime[j];
  for(j=0;j<6;j++)BufTmp[Len++]=StateA2.bb[j];;
  I2C_EE_BufferWrite(BufTmp,CURRENT_SAVE_PAGE_ADDR,Len,0);

}
void EEToStateA1(void)
{

  u8 BufTmp[6];
  I2C_EE_BufferRead(BufTmp,RECORD_NUM_ADDR,6,0);
  StateA1=*(StructStateA1*)BufTmp;

}
void EEToStateA2(void)
{

  u8 BufTmp[17];
  I2C_EE_BufferRead(BufTmp,CURRENT_SAVE_PAGE_ADDR,17,0);
  StateA2=*(StructStateA2*)BufTmp;

}
void StateBToEE(void)
{

  u16 j,Len;
  u8 BufTmp[24];
  
  Len=0;
  WDT_CLR;
  BufTmp[Len++]=0xff&StateB.StartLaterTime;
  BufTmp[Len++]=0xff&(StateB.StartLaterTime>>8);
  BufTmp[Len++]=0xff&(StateB.StartLaterTime>>16);
  BufTmp[Len++]=0xff&(StateB.StartLaterTime>>24);
  BufTmp[Len++]=0xff&StateB.RecordTime;
  BufTmp[Len++]=0xff&(StateB.RecordTime>>8);
  BufTmp[Len++]=0xff&(u8)(StateB.RecordTime>>16);
  BufTmp[Len++]=0xff&(u8)(StateB.RecordTime>>24);
  BufTmp[Len++]=StateB.StartMode;
  BufTmp[Len++]=StateB.StopMode;
  BufTmp[Len++]=StateB.LcdRefreshMode;
  BufTmp[Len++]=StateB.Address;
  I2C_EE_BufferWrite(BufTmp,START_LATER_TIME_ADDR,Len,0);

  Len=0;
  for(j=0;j<6;j++)BufTmp[Len++]=StateB.LaterStartTime[j];
  for(j=0;j<6;j++)BufTmp[Len++]=StateB.LaterStopTime[j];
  I2C_EE_BufferWrite(BufTmp,LATER_START_TIME_ADDR,Len,0);

}

void EEToStateB(void)
{

  u8 BufTmp[24];
  I2C_EE_BufferRead(BufTmp,START_LATER_TIME_ADDR,12,0);
  I2C_EE_BufferRead(&BufTmp[12],LATER_START_TIME_ADDR,12,0);
  StateB=*(StructStateB*)BufTmp;

}

//复位、重启 后需清的变量
void RestartClr(void)
{
 //省电模式正常模式自动切换
  #if LCD08_SD_SHIFT_EN==1
    if(Flag.LCD08_Sd_en==1)
    {
      Pt.sd_pt=0;
      WakeUp();
    }
  #else
    #if SD_ENABLE==1
    Pt.sd_pt=0;
    WakeUp();
    #endif
  #endif
  
  Flag.HandJustStart=0;
  
  #if L_Stime_First_EN==1
    Pt.RecordPt=StateB.RecordTime-2;
  #else
    Pt.RecordPt=0;
  #endif
  
  
  Pt.RealSamplePt=0;
  Flag.RstFirstSample=0;
  Flag.SampPt=0;

  #if POWER_TIME_ENABLE==1
    PowTimeClr();
    VT_CTL_OFF;
  #endif
  
  #if ALARM_TIME_ENABLE==1
  AlarmedClr();
  #endif
  
  #if ALARM_BELL_TIME_EN==1
  Pt.AlarmTimePt=0;
  #endif
  
  #if DIGITAL_FILTER_EN==1
  FilterClr();

  #endif

  
  #if SMS_INV_ENABLE==1
  GsmInvInit();
  #endif
  
  #if PRINT_REAL_EN==1//记录一个点打印一个点
  StateC.HaveBc=0;
  #endif
  
 
  #if RF_REC_EN==1
  RfDataNULL();//初始NULL
  Pt.SampPt=RF_SAMP_TIME-1;
  #endif
  
  
  #if L_REC_AVG_EN==1
   for(u8 j=0;j<CH_NUM;j++)//每次记录后，AVG有效数清0
     StateC.LRYouxiaoNum[j]=0;
  #endif
  
}

#if ALARM_POINT_ENABLE==1

//只适用于正数
//bc<point，dc>=point
//bc>point，dc<=point
u8 PiontSeek(u16 bc,u16 dc,u16 point)
{
  if(((bc==SENIOR_NULL)||(bc==HAND_STOP))
     ||((dc==SENIOR_NULL)||(dc==HAND_STOP)))
    return 0;
  
  if(((bc<point)&&(dc>=point))
    ||((bc>point)&&(dc<=point)))
  {
    return 1;
  }
  else
  {
    return 0;
  }

}
//通道ch数据 60. 70... 200 到点启动警报
u8 AlarmPointSeek(void)
{
  if(!(StateA2.WorkState==WORK_STATE_RECORDING))
  {
    return 0;
  }
  
  if(0x01&(StateC.FuhaoBit>>0))//负数则退出
  {
    return 0;
  }
  
  for(u16 j=0;j<15;j++)
  {
    if(PiontSeek(Pt.ValueBc,StateC.Value[0],600+j*100))
    {
      return 1;//只要有一个点启动就退出
    }
  }
  return 0;
}
//先保存上次采样的数据，和这次数据比较，上升或下降都启动警报
//只适用于正数
void AlarmPointBc(void)
{
  Pt.ValueBc=StateC.Value[0];
}
//启动警报
void AlarmPointStart(void)
{
  Pt.AlarmPointPt=ALARM_POINT_TIME;
}
//.............................................................................
void AlarmPointDeel(void)
{
  if(AlarmPointSeek())
  {
    AlarmPointStart();
  }
  
  if(Pt.AlarmPointPt>0)
  {
    Pt.AlarmPointPt--;
    if(Pt.AlarmPointPt==0)
    {
      Bell_Off();
    }
    else
    {
      Bell_Shan();
    }
  }
}
#endif

//-----------------------------------------------------------------

#if ((ALARM_TIME_ENABLE==1)||(ALARM_BELL_TIME_EN==1))
void AlarmTimeDeel(void)
{
  if(Pt.AlarmTimePt>0)
  {
    Pt.AlarmTimePt--;
  }
}
#endif
//-----------------------------------------------------
#if ALARM_BELL_TIME_EN==1
void AlarmBellTimeDo(void)//有数据超标
{
    if(Pt.AlarmTimePt==0)
    {
      Pt.AlarmTimePt=ALARM_JIANGE;
    }
    
    if((Pt.AlarmTimePt>=(ALARM_JIANGE-ALARM_CHIXU))&&(Pt.AlarmTimePt<=ALARM_JIANGE))
    {
      Bell_Shan();
    }
    else
    {
      Bell_Off();
    }
}
#endif
//时间间隔报警-----------------------------------------------------------------------------
#if ALARM_TIME_ENABLE==1

void AlarmedFormEE(void)
{
  u8 Buf[2];
  I2C_EE_BufferRead(Buf,ALARMED_ADDR,2,0);
  
  for(u16 j=0;j<CH_NUM;j++)
  {
    if(Buf[j])
    {
      Flag.AlarmedCh[j]=1;
    }
    else
    {
      Flag.AlarmedCh[j]=0;
    }
  }
}

void AlarmedToEE(void)
{
  I2C_EE_BufferWrite(Flag.AlarmedCh,ALARMED_ADDR,2,0);
}
void AlarmedClr(void)
{
  Pt.AlarmTimePt=0;
  Flag.AlarmedCh[0]=0;
  Flag.AlarmedCh[1]=0;
  AlarmedToEE();
}
//只有有通道超标，就返回1, 否则返回0
u8 HaveChAlarmed(void)
{
  u16 j;
  for(j=0;j<CH_NUM;j++)
  {
    if(Flag.AlarmedCh[j]==1)
      return 1;
  }
  return 0;
}
//监测数据，是否设置超标标志
void AlarmedSet(void)
{
  u8 cc;
  cc=0;
  //有超标变化才设置
  for(u16 j=0;j<CH_NUM;j++)
  {
    if(1&(Flag.AlarmB>>j))//通道1超标
    {
      if(Flag.AlarmedCh[j]==0)
      {
        Flag.AlarmedCh[j]=1;
        cc=1;
      }
    }
  }
  if(cc==1)//有变化才进入设置到ee
  {
    AlarmedToEE();
  }
}

//报警时间触发
void AlarmTimeDo(void)
{
  //持续时间内响
  if(HaveChAlarmed())//曾经超标过，只能通过按钮清
  {
    if(Pt.AlarmTimePt==0)
    {
      Pt.AlarmTimePt=ALARM_JIANGE;
    }
    
    if((Pt.AlarmTimePt>=(ALARM_JIANGE-ALARM_CHIXU))&&(Pt.AlarmTimePt<=ALARM_JIANGE))
    {
      Bell_Shan();
    }
    else
    {
      Bell_Off();
      if(ChAlarm())//持续超标时,一直15秒报警
      {
        if(Pt.AlarmTimePt<(ALARM_JIANGE-ALARM_CHIXU))
        {
          Pt.AlarmTimePt=0;
        }
      }
      
    }
  }
  else
  {
    Bell_Off();
    Pt.AlarmTimePt=0;//没有超标过，则一直为0
  }
}
#endif


#if (RY_GSM_ENABLE==1)//短信继电器控制
void RyGsmDeel(void)
{
  if(Flag.Ry1ed==0)
  {
    RY1_OFF;
    RY2_OFF;
  }
  else
  {
    RY1_ON;
    RY2_ON;
  }
}
#endif


//继电器控制电机------------------------------------------------------------------
#if RY_CONTROL_ENABLE==1
//控制使能查询, 0:控制关闭，1：上限闭合模式，2：下限闭合模式
u8 ChControlEn(u8 ChNo)
{
    u8 En=0;
    
    En=*((char *)CH1_K_E_ADDR+ONE_CH_CONFIG_BYTES*ChNo);
    if(En>2)
      En=0;
    return En;
}

void RyedWrite(u8 cc,u8 ch)
{
    
    if(ch==0)
    {
       Flag.Ry1ed=cc;
       
        #if CMD_CTRL_EN==1
        if(StateC.PcLinkPt==0)
        {
            
            if(cc==1)
            {
                if(Pt.wdkai==0)
                {
                    Pt.wdkai=1;
                    
                    ComSendH();//红外控制器，开指令
                    
                    BellOne();
                    
                    delay_ms(200);
                    WDT_CLR;
                    delay_ms(200);
                    WDT_CLR;
                    
                    U1SendByte('F');
                    U1SendByte('0');//地址00
                    U1SendByte('0');
                    U1SendByte('0');//001 开
                    U1SendByte('0');
                    U1SendByte('1');
                    
                    
                    delay_ms(200);
                    WDT_CLR;
                    delay_ms(200);
                    WDT_CLR;
                    
                    U1SendByte('F');
                    U1SendByte('0');//地址00
                    U1SendByte('0');
                    U1SendByte('0');//001 开
                    U1SendByte('0');
                    U1SendByte('1');
                    
                    delay_ms(200);
                    WDT_CLR;
                    delay_ms(200);
                    WDT_CLR;
                    
                    U1SendByte('F');
                    U1SendByte('0');//地址00
                    U1SendByte('0');
                    U1SendByte('0');//001 开
                    U1SendByte('0');
                    U1SendByte('1');
                    
                    
                    ComSendL(); 

                }
            }
            else
            {
               if(Pt.wdkai==1)
               {
                    Pt.wdkai=0;
                    
                    ComSendH();//红外控制器，开指令
                    
                    BellOne();
                    
                    delay_ms(200);
                    WDT_CLR;
                    delay_ms(200);
                    WDT_CLR;
                    
                    U1SendByte('F');
                    U1SendByte('0');//地址00
                    U1SendByte('0');
                    U1SendByte('0');//002  关
                    U1SendByte('0');
                    U1SendByte('2');
                    
                    delay_ms(200);
                    WDT_CLR;
                    delay_ms(200);
                    WDT_CLR;
                    
                    U1SendByte('F');
                    U1SendByte('0');//地址00
                    U1SendByte('0');
                    U1SendByte('0');//002  关
                    U1SendByte('0');
                    U1SendByte('2');
                    
                    delay_ms(200);
                    WDT_CLR;
                    delay_ms(200);
                    WDT_CLR;
                    
                    U1SendByte('F');
                    U1SendByte('0');//地址00
                    U1SendByte('0');
                    U1SendByte('0');//002  关
                    U1SendByte('0');
                    U1SendByte('2');
                    
                    
                    ComSendL(); 
 
               }
 
            }
        }
       #endif
       
       
    }
    else if(ch==1)
    {
       Flag.Ry2ed=cc;
       
       #if CMD_CTRL_EN==1
       
       
       if(StateC.PcLinkPt==0)
       {
              
              if(cc==1)
              {
                  if(Pt.sdkai==0)
                  {
                      Pt.sdkai=1;
                      
                      ComSendH();//除湿机控制指令
                      
                      BellOne();
                      
                      delay_ms(200);
                      WDT_CLR;
                      delay_ms(200);
                      WDT_CLR;
                      
                      U1SendByte(0x68);
                      U1SendByte(0xaa);
                      U1SendByte(0x00);
                      U1SendByte(0x80);
                      U1SendByte(0x01);
                      U1SendByte(0x0f);//开机
                      U1SendByte(0xa2);
                      U1SendByte(0x16);
                      
                      delay_ms(200);
                      WDT_CLR;
                      delay_ms(200);
                      WDT_CLR;
                      
                      U1SendByte(0x68);
                      U1SendByte(0xaa);
                      U1SendByte(0x00);
                      U1SendByte(0x80);
                      U1SendByte(0x01);
                      U1SendByte(0x0f);//开机
                      U1SendByte(0xa2);
                      U1SendByte(0x16);
                      
                      ComSendL(); 
                  }
                  
                  
              }
              else
              {
                
                  if(Pt.sdkai==1)
                  {
                      Pt.sdkai=0;
                      
                      ComSendH();//除湿机控制指令
                      
                      BellOne();
                      
                      delay_ms(200);
                      WDT_CLR;
                      delay_ms(200);
                      WDT_CLR;
                      
                      U1SendByte(0x68);
                      U1SendByte(0xaa);
                      U1SendByte(0x00);
                      U1SendByte(0x80);
                      U1SendByte(0x01);
                      U1SendByte(0xf0);//关机
                      U1SendByte(0x83);
                      U1SendByte(0x16);
                      
                      delay_ms(200);
                      WDT_CLR;
                      delay_ms(200);
                      WDT_CLR;
                      
                      U1SendByte(0x68);
                      U1SendByte(0xaa);
                      U1SendByte(0x00);
                      U1SendByte(0x80);
                      U1SendByte(0x01);
                      U1SendByte(0xf0);//关机
                      U1SendByte(0x83);
                      U1SendByte(0x16);
                      
                      ComSendL(); 
                  }
                  
                  
              }
        
       }
       #endif 
       
    }
}
void RyFirst(void)//初始状态
{
  Flag.Ry1ed=0;
  Flag.Ry2ed=0;
}
void RyControlDeel(void)
{
  u8 ch,k,En=0;
  u16 dd;
  

  //各个通道继电器动作
  for(ch=0;ch<CH_NUM;ch++)
  {
    En=ChControlEn(ch);
    if(En&&(!((StateC.Value[ch]==SENIOR_NULL)||(StateC.Value[ch]==HAND_STOP))))//控制使能打开
    {
       dd=StateC.Value[ch];
       if(0x01&(StateC.FuhaoBit>>ch))//负数
       {
         dd|=0x8000;
       }
       else
       {
         dd&=0x7fff;
       }
       
       k=AlarmXSeek(dd,ch,2);
       if(k==1)//上限超标
       {
         if(En==1)
         {
           RyedWrite(1,ch);//上限闭合  制冷风扇、制冷机
         }
         else if(En==2)
         {
           RyedWrite(0,ch);//上限断开
         }
       }
       else if(k==2)//下限超标
       {
         if(En==1)
         {
           RyedWrite(0,ch);//下限断开
         }
         else if(En==2)
         {
           RyedWrite(1,ch);//下限闭合 加热器、加湿器
         }
       }
    }
    else//关闭
    {
      RyedWrite(0,ch);
    }
  }
  NOP;
  NOP;
  
  //是否开启继电器电源,只有在上限超标时，关
  if((Flag.Ry1ed==0)&&(Flag.Ry2ed==0))//同时为0时，关
  {
    RY_POW_OFF;
    RY1_OFF;
    RY2_OFF;
  }
  else
  {
    RY_POW_ON;
    if(Flag.Ry1ed)
    {
      RY1_ON;
    }
    else
    {
      RY1_OFF;
    }
    
    if(Flag.Ry2ed)
    {
      RY2_ON;
    }
    else
    {
      RY2_OFF;
    }
  }
  NOP;

}
#endif

u16 GetBatt(void)
{
     
        u16 out;
        u32 xx;
        
        xx=StateC.BatV;
        xx=xx*100;
        
        
        if(xx>35800)//3.56
        {
          xx=xx-35600;
          xx=xx/(405-356);
        }
        else
        {
          xx=1;
        }
        
        if(xx>100)
          xx=100;
        
        out=xx;
        

        return out;
        
}


#if LCD08_SD_SHIFT_EN==1
void GetSdShiftEnFromEE(void)
{
   u8 Buf[1];
   I2C_EE_BufferRead(Buf,LCD08_SHIFT_EN_ADDR,1,0);
   Flag.LCD08_Sd_en=Buf[0];
}
//cc=0,正常模式，cc=1,省电模式
void SetSdShiftEnToEE(u8 cc)
{
  u8 Buf[1];
  Buf[0]=cc;
  I2C_EE_BufferWrite(Buf,LCD08_SHIFT_EN_ADDR,1,0);//保存标志
  Flag.LCD08_Sd_en=Buf[0];
}
#endif

#if PRINT_REAL_EN==1
void GetPrintXX(void)
{
  u16 j;
  u8 buf[10];
  I2C_EE_BufferRead(buf,PRINT_XX_1_ADDR,10,0);
  for(j=0;j<5;j++)
  {
    StateC.PrintXB[j]=U8_TO_U16(buf[j*2+1],buf[j*2]);//虚线点位
  }
}
void SetPrintXX(void)
{
  u16 j;
  u8 buf[10];
  
  for(j=0;j<5;j++)
  {
    buf[j*2]=0xff&(StateC.PrintXB[j]);
    buf[j*2+1]=0xff&(StateC.PrintXB[j]>>8);
  }
  I2C_EE_BufferWrite(buf,PRINT_XX_1_ADDR,10,0);
}
#endif


void ClrPhoneToEE(void)
{
  u8 BufA[46];
  u16 j;
  
  for(j=0;j<46;j++)
  {
    BufA[j]=0x00;
  }
  I2C_EE_BufferWrite(BufA,PHONE_NUM_ADDR,46,0);
}
void SetPhoneToEE(u8 *BufA)
{
  u16 j;
  if((BufA[0]>3))//号码个数错误
  {
    return;
  }
  else
  {
    if(!((BufA[1]>=0x30)&&(BufA[1]<=0x39)))//第一个号码错误
    {
      for(j=0;j<34;j++)
      {
        BufA[j]=0;//号码不对，清除号码
      }
    }
  }
  I2C_EE_BufferWrite(BufA,PHONE_NUM_ADDR,34,0);
}
u8 GetPhoneNumFromEE(void)
{
  u8 BufA[1];
  I2C_EE_BufferRead(BufA,PHONE_NUM_ADDR,1,0);
  if(BufA[0]>3)
  {
    BufA[0]=0;
  }
  return BufA[0];
}
void GetPhoneHaoFromEE(u8* BufA,u8 Pt)
{
  I2C_EE_BufferRead(BufA,PHONE1_ADDR+11*Pt,11,0);
}


//格式：1温-12.5超(CR)
u16 GetSmsUni(u8* UniBf,u8 Alarm)//1,超标报警，0，查询
{
    u16 j,i=0;
    
    volatile u16 VV[8];
    volatile u8 FlagVV;
    volatile u8 FlagB;
    
    #if SMS_SAME_EN==1
    
       if(Alarm==SMS_LOOK)//查询的是实时数据
       {
           for(j=0;j<8;j++)
           {
             VV[j]=StateC.Value[j];
           }
           FlagVV=StateC.FuhaoBit;
           FlagB=Flag.AlarmB;
       }
       else//报警数据
       {
       
           for(j=0;j<8;j++)
           {
             VV[j]=StateC.SmsValue[j];
           }
           FlagVV=StateC.SmsVBit;
           FlagB=StateC.SmsChAFlag;
       }
       
       
    #else
       
       for(j=0;j<8;j++)
       {
         VV[j]=StateC.Value[j];
       }
       FlagVV=StateC.FuhaoBit;
       FlagB=Flag.AlarmB;
       
    #endif
    

    #if SMS_RTC_EN==1
    i=i+GetRtcUni(&UniBf[i]);
    #endif
    
    
    i=i+GetSmsTitleUni(&UniBf[i]);

    #if (JLY_MODEL==_3_CF)
    
    if(ChAlarm())//有数据超标
    {
      //醋液漏了，请注意！
      UniBf[i++]=0x91;UniBf[i++]=0x8b;UniBf[i++]=0x6d;UniBf[i++]=0xb2;
      UniBf[i++]=0x6f;UniBf[i++]=0x0f;UniBf[i++]=0x4e;UniBf[i++]=0x86;
      UniBf[i++]=0xff;UniBf[i++]=0x0c;UniBf[i++]=0x8b;UniBf[i++]=0xf7;
      UniBf[i++]=0x6c;UniBf[i++]=0xe8;UniBf[i++]=0x61;UniBf[i++]=0x0f;
      UniBf[i++]=0xff;UniBf[i++]=0x01;
    }
    else
    {
      //醋液没有漏
      UniBf[i++]=0x91;UniBf[i++]=0x8b;UniBf[i++]=0x6d;UniBf[i++]=0xb2;
      UniBf[i++]=0x6c;UniBf[i++]=0xa1;UniBf[i++]=0x67;UniBf[i++]=0x09;
      UniBf[i++]=0x6f;UniBf[i++]=0x0f;
    }
    return i;
    #endif
    
    #if (JLY_MODEL==_1_SMOKE)
    
    if(ChAlarm())//有数据超标
    {
      //烟雾报警，请注意！
      UniBf[i++]=0x70;UniBf[i++]=0xDF;UniBf[i++]=0x96;UniBf[i++]=0xFE;
      UniBf[i++]=0x62;UniBf[i++]=0xA5;UniBf[i++]=0x8B;UniBf[i++]=0x66;
      UniBf[i++]=0xFF;UniBf[i++]=0x0C;UniBf[i++]=0x8b;UniBf[i++]=0xf7;
      UniBf[i++]=0x6c;UniBf[i++]=0xe8;UniBf[i++]=0x61;UniBf[i++]=0x0f;
      UniBf[i++]=0xff;UniBf[i++]=0x01;
    }
    else
    {

      //烟雾没有超标！
      UniBf[i++]=0x70;UniBf[i++]=0xDF;UniBf[i++]=0x96;UniBf[i++]=0xFE;
      UniBf[i++]=0x6c;UniBf[i++]=0xa1;UniBf[i++]=0x67;UniBf[i++]=0x09;
      UniBf[i++]=0x8D;UniBf[i++]=0x85;UniBf[i++]=0x68;UniBf[i++]=0x07;
      UniBf[i++]=0xff;UniBf[i++]=0x01;
    }
    return i;
    #endif
    
    
    
    #if SMS_WSD_DEDICATED_EN==1//温湿度专用
    
      for(u16 j=0;j<CH_NUM;j++)
      {  //查看或超标报警
        if((Alarm==SMS_LOOK)||((Alarm==SMS_ALARM)&&(1&(FlagB>>j))))
        {
             u8 ChT;//通道类型
             ChT=*((char*)CH1_T_ADDR+j*ONE_CH_CONFIG_BYTES);//读取该通道类型
          
              //通道类型......................................................
              if(ChT==_T_T)//温度
              {
                UniBf[i++]=(0x6E);
                UniBf[i++]=(0x29);
                UniBf[i++]=(0x5e);
                UniBf[i++]=(0xa6);
              }
              else if(ChT==_T_H)//湿度
              {
                UniBf[i++]=(0x6E);
                UniBf[i++]=(0x7F);
                UniBf[i++]=(0x5e);
                UniBf[i++]=(0xa6);
              }
              
              if(Alarm==SMS_ALARM)
              {
                //超标报警，请速处理，
                UniBf[i++]=(0x8d);
                UniBf[i++]=(0x85);
                UniBf[i++]=(0x68);
                UniBf[i++]=(0x07);
                UniBf[i++]=(0x62);
                UniBf[i++]=(0xa5);
                UniBf[i++]=(0x8b);
                UniBf[i++]=(0x66);
                UniBf[i++]=(0xff);
                UniBf[i++]=(0x0c);
                UniBf[i++]=(0x8b);
                UniBf[i++]=(0xf7);
                UniBf[i++]=(0x90);
                UniBf[i++]=(0x1f);
                UniBf[i++]=(0x59);
                UniBf[i++]=(0x04);
                UniBf[i++]=(0x74);
                UniBf[i++]=(0x06);
                UniBf[i++]=(0xff);
                UniBf[i++]=(0x0c);
              }
              
              //当前值为
              UniBf[i++]=(0x5f);
              UniBf[i++]=(0x53);
              UniBf[i++]=(0x52);
              UniBf[i++]=(0x4d);
              UniBf[i++]=(0x50);
              UniBf[i++]=(0x3c);
              UniBf[i++]=(0x4e);
              UniBf[i++]=(0x3a);
              
              if((VV[j]==SENIOR_NULL)||(VV[j]==HAND_STOP))
              {
                  UniBf[i++]=(0x00);//NULL
                  UniBf[i++]=('N');
                  UniBf[i++]=(0x00);
                  UniBf[i++]=('U');
                  UniBf[i++]=(0x00);
                  UniBf[i++]=('L');
                  UniBf[i++]=(0x00);
                  UniBf[i++]=('L');
              }
              else
              {
                  //通道数值......................................................
                  if(FlagVV&(1<<j))
                  {
                     UniBf[i++]=(0x00);//-
                     UniBf[i++]=(0x2d);
                  }
                  
                  if(VV[j]>999)
                  {
                    UniBf[i++]=(0x00);
                    UniBf[i++]=((VV[j]/1000)%10+0x30);
                  }
                  
                  if(VV[j]>99)
                  {
                    UniBf[i++]=(0x00);
                    UniBf[i++]=((VV[j]/100)%10+0x30);
                  }
                  
                  UniBf[i++]=(0x00);
                  UniBf[i++]=((VV[j]/10)%10+0x30);
                  UniBf[i++]=(0x00);//.
                  UniBf[i++]=(0x2e);
                  UniBf[i++]=(0x00);
                  UniBf[i++]=(VV[j]%10+0x30);
                  
                  //通道单位
                  if(ChT==_T_T)//温度℃
                  {
                    UniBf[i++]=(0x21);
                    UniBf[i++]=(0x03);
                  }
                  else if(ChT==_T_H)//湿度%RH
                  {
                    UniBf[i++]=(0x00);
                    UniBf[i++]=(0x25);
                    UniBf[i++]=(0x00);
                    UniBf[i++]=(0x52);
                    UniBf[i++]=(0x00);
                    UniBf[i++]=(0x48);
                  }
              }
              
              UniBf[i++]=(0x00);//换行
              UniBf[i++]=(0x0a);
        }
      }
    
    
    #else
      

      for(u16 j=0;j<CH_NUM;j++)
      {
        #if (SMS_SEND_8H_EN==1)
        if((Alarm==SMS_LOOK)//查看
           ||(Alarm==SMS_ALARM))//每8小时发送一次时
        #else
        if((Alarm==SMS_LOOK)//查看
           ||((Alarm==SMS_ALARM)&&(1&(FlagB>>j))))//有超标
        #endif
        {
              u8 ChT;//通道类型
              ChT=*((char*)CH1_T_ADDR+j*ONE_CH_CONFIG_BYTES);//读取该通道类型
              
              u8 ChS;//通道位数
              ChS=*((char*)CH1_S_ADDR+j*ONE_CH_CONFIG_BYTES);//读取该通道位数

              //通道号.......................................................
               #if CH_PAIR_ENABLE==1
                   UniBf[i++]=(0x00);
                   UniBf[i++]=(1+j/2+0x30);//成对的情况
               #else
                   UniBf[i++]=(0x00);
                   UniBf[i++]=(1+j+0x30);
               #endif
                
              //通道类型......................................................
              if(ChT==_T_T)//温度
              {
                UniBf[i++]=(0x6E);
                UniBf[i++]=(0x29);
              }
              else if(ChT==_T_H)//湿度
              {
                UniBf[i++]=(0x6E);
                UniBf[i++]=(0x7F);
              }
              
#if OPT_EN==0
              
              else if(ChT==_T_DL)//电流
              {
                UniBf[i++]=(0x75);
                UniBf[i++]=(0x35);
                UniBf[i++]=(0x6d);
                UniBf[i++]=(0x41);
              }
              else if(ChT==_T_DY)//电压
              {
                UniBf[i++]=(0x75);
                UniBf[i++]=(0x35);
                UniBf[i++]=(0x53);
                UniBf[i++]=(0x8B);
              }
              else if(ChT==_T_PH)//PH值
              {
                UniBf[i++]=(0x00);
                UniBf[i++]=(0x50);
                UniBf[i++]=(0x00);
                UniBf[i++]=(0x48);
                UniBf[i++]=(0x50);
                UniBf[i++]=(0x3c);
              }
              else if(ChT==_T_QY)//气压
              {
                UniBf[i++]=(0x6C);
                UniBf[i++]=(0x14);
                UniBf[i++]=(0x53);
                UniBf[i++]=(0x8B);
              }
              else
              {
                UniBf[i++]=(0x90);//通道x:
                UniBf[i++]=(0x1a);
                UniBf[i++]=(0x90);
                UniBf[i++]=(0x53);
                UniBf[i++]=(0x00);
                UniBf[i++]=(j+1+0x30);
                UniBf[i++]=(0xff);
                UniBf[i++]=(0x1a);
              }
#endif
              
              
              
              if((VV[j]==SENIOR_NULL)||(VV[j]==HAND_STOP))
              {
                  UniBf[i++]=(0x00);//NULL
                  UniBf[i++]=('N');
                  UniBf[i++]=(0x00);
                  UniBf[i++]=('U');
                  UniBf[i++]=(0x00);
                  UniBf[i++]=('L');
                  UniBf[i++]=(0x00);
                  UniBf[i++]=('L');
              }
              else
              {
                  //通道数值......................................................
                  if(FlagVV&(1<<j))
                  {
                     UniBf[i++]=(0x00);//-
                     UniBf[i++]=(0x2d);
                  }
#if OPT_EN==0
                  if(VV[j]>9999)//zz
                  {
                    UniBf[i++]=(0x00);
                    UniBf[i++]=((VV[j]/10000)%10+0x30);
                  }
#endif
                  
                  if(VV[j]>999)
                  {
                    UniBf[i++]=(0x00);
                    UniBf[i++]=((VV[j]/1000)%10+0x30);
                  }
                  
                  

                  if(ChS==_S_1)//默认1位小数
                  {
                      if(VV[j]>99)
                      {
                        UniBf[i++]=(0x00);
                        UniBf[i++]=((VV[j]/100)%10+0x30);
                      }
                      
                      UniBf[i++]=(0x00);
                      UniBf[i++]=((VV[j]/10)%10+0x30);
                      UniBf[i++]=(0x00);//.
                      UniBf[i++]=(0x2e);
                      UniBf[i++]=(0x00);
                      UniBf[i++]=(VV[j]%10+0x30);
                  }
#if OPT_EN==0
                  else if(ChS==_S_2)//2位小数
                  {
                      UniBf[i++]=(0x00);
                      UniBf[i++]=((VV[j]/100)%10+0x30);
                      UniBf[i++]=(0x00);//.
                      UniBf[i++]=(0x2e);
                      UniBf[i++]=(0x00);
                      UniBf[i++]=((VV[j]/10)%10+0x30);
                      UniBf[i++]=(0x00);
                      UniBf[i++]=(VV[j]%10+0x30);
                  }
#endif
                  
                  //是否超标............................................................
                  #if SMS_SEND_8H_EN==0//每8小时发送一次时，不发超字
                  if(Alarm==SMS_ALARM)
                  {
                    UniBf[i++]=(0x8d);//超
                    UniBf[i++]=(0x85);
                  }
                  #endif
              }
              UniBf[i++]=(0x00);//换行
              UniBf[i++]=(0x0a);
        }
      }
      
      //电池信息状况
      #if GSM_BATT_INFOR_EN==1
      if(Alarm==SMS_LOOK)
      {
          i=i+GetBattUni(&UniBf[i],0);
      }
      #endif 
    
    #endif
      
      
    #if SMS_TCP_EN==1
    if(i>SMS_LEN-20)
      i=SMS_LEN-20;
    #else
    if(i>140)//不能大于70个字
      i=140;
    #endif
      
    return i;
}
u16 GetSmsTitleUni(u8* buf)
{
      u16 i=0,j;
  
      I2C_EE_BufferRead(buf,SMS_TITLE_ADDR,20,0);//短信标题Uni
      
      for(j=0;j<10;j++)
      {
        if(buf[j*2]==0x00&&buf[j*2+1]==0x00)//判断一个字是不是00 00
        {
          i=j*2;
          break;
        }
        if(j==9)//最后一个字
        {
          i=20;
          break;
        }
      }
      
      if(i>0)
      {
        buf[i++]=(0x00);//换行
        buf[i++]=(0x0a);
      }
      return i;
}

#if ((RF_REC_EN==1)||(RF_KP_EN==1))
//读取无线传感器 SN
void GetRfSnFromEE(void)
{
  I2C_EE_BufferRead(Pt.Sn,SERIAL_NO_ADDR,10,0);
  
  #if RF_CC_EN==1
  Pt.SnCRC16=GetCrc16(Pt.Sn,10);
  #endif
  
  #if RF_KP_EN==1
  Pt.KpSn[0]=0xff&(Pt.SnCRC16>>8);
  Pt.KpSn[1]=0xff&(Pt.SnCRC16);
  SetKpSnToEE();
  #endif
  
}
#endif


#if RF_REC_EN==1

void SendSnToSenior(void)
{
     u8 buf[14];
     u16 i;

     GetRfSnFromEE();
     
   #if RF_CC_EN==1  
     //AF(1)+ SN的CRC16(2) + 预留(4)+ADD(1)
     //主机SN号通过计算得到SN的CRC16(2) ，发送给无线卡片
     u8 add=0;

     i=0;
     add+=buf[i++]=0xAF;//头
     add+=buf[i++]=0xff&(Pt.SnCRC16>>8);//SN的CRC16
     add+=buf[i++]=0xff&(Pt.SnCRC16);
     add+=buf[i++]=0x00;
     add+=buf[i++]=0x00;
     add+=buf[i++]=0x00;
     add+=buf[i++]=0x00;
     buf[i++]=add;
     
   #else
     u16 j;
     i=0;
     buf[i++]=0xe0;//头
     buf[i++]=10;//字节数
     for(j=0;j<10;j++)
       buf[i++]=Pt.Sn[j];//SN
     unsigned short crc16;
     crc16=GetCrc16(buf,i);
     buf[i++]=0xff&(crc16>>8);
     buf[i++]=0xff&(crc16);
   #endif
     
     RF_IN_REC;

     
     delay_ms(10);
     RfU_SendBuf(buf,i);
     delay_ms(10);

     
}


//无线接收 单机或多机
void Rf_Rec_Yq(u8* buf,u16 len)
{
#if RF_CC_EN==1
    /*
    A0(1)  ADDR(1)  SN(2)  TH(3)  ADD(1)  
    
    A0(1):  固定头
    ADDR(1):  地址（1，255）
    SN(2) : 与主机SN号必须一致，2字节整数 0-65535
    TH(3): 温湿度共用3个字节, 即24位，温度占14位，湿度占10位
    温度14位最高位1为负，0为正。其余13位数值.  范围（-8191，8191）
    湿度10位，范围(0-3FF)， 即(0,1023)
    ADD(1): 校验和
  
  
    带电量指示----------------------------------------------------
    B0(1)  ADDR(1)  SN_BAT(2)  TH(3)  ADD(1)
    其他与A0指令一样，区别：
    1.  A0变成了B0
    2.  SN(2) 分成了2部分 SN_BAT(2)
        AAAB   AAA为原先SN(2)的前12位， B为电量(0-9)
    3.  TH(3): 温湿度共用3个字节, 即24位，温度占14位，湿度占10位
        温度14位最高位1为负，0为正。其余13位数值.  范围1FFF（-8191，8191）
        湿度10位，范围(0-3FF)， 即(0,1023)
  
    -----------------------------------
   【3】 支持2个温度  170818
   B0(1)  ADR(1)  SN_BAT(2)  TH(3)  ADD(1)
   TH(3) ：分为2个通道，前12位为通道1，后12位为通道2
         最高位1为负，正为负。其余11位数值，范围 7FF( -2047, 2047)
   ADR(1): 最高位1为 2温度卡片协议，最高位0为单温度或温湿度卡片协议。

  
    */
   u8 addr;
   volatile u8 TTflag;//2T协议判断
   u16 j,tt,hh,aa;

   if(!(((buf[0]>=0xA0)&&(buf[0]<0xAA))||((buf[0]>=0xB0)&&(buf[0]<0xBA))))
     return;
   
   
   
   addr= 0x7f&buf[1];//地址,最高位为2温度卡片协议标志位
   TTflag=0;
   if(0x80&buf[1])
     TTflag=1;
   
   
  #if RF_YQ_EN==1//单机仪器不能超过8，变送器系统可以超过
  if(!((addr>=1)&&(addr<=RF_SEN_MAX)))
    return;
  #endif
  
  
  #if RF_MULTI_EN==1
    if(addr>RF_SEN_MAX)
      return;
  
    if(StateB.Address>1)
    {
        u8 rp=buf[0]&0x0f;
        Lcd_Xp(rp,addr,1);//显示收到的地址 
    }
  #endif
  
  
  if(TTflag==1)
  {
      //T1
      aa=buf[4];
      aa=(aa<<8)|buf[5];
      aa=aa>>4;
      tt=aa&0xfff;
      
      //T2
      aa=buf[5];
      aa=(aa<<8)|buf[6];
      hh=aa&0xfff;
  }
  else
  {
      //温度
      aa=buf[4];
      aa=(aa<<8)|buf[5];
      aa=aa>>2;
      tt=aa&0x3fff;
      
      //湿度,无负数
      aa=buf[5];
      aa=(aa<<8)|buf[6];
      aa=aa&0x3ff;
      hh=aa;
  }
  
  if((buf[0]&0xF0)==0xB0)
  {
    Pt.Bat[addr-1]=(buf[3]&0x0f)*10;//电池电量 7-> 80  9->10  A->11
  }
  else
    Pt.Bat[addr-1]=0xff;//null NA 空的
  
  Pt.RfChN[addr-1]=2;//通道数默认2，如果CH2显示NULL，通道数为1
  
  for(j=0;j<2;j++)
  {
        if(TTflag==1)
        {
              if(j==0)//通道1 
              {
                aa=tt;
              }
              else
              {
                aa=hh;
              }
              
              if(aa==0xfff)
              {
                    Pt.RfData[addr-1][j].value=SENIOR_NULL;
              }
              else
              {
                    Pt.RfData[addr-1][j].value=aa&0x7ff;//数值
                    if(aa&0x800)
                    {
                      Pt.RfData[addr-1][j].value|=0x8000;
                    }
              }


        }
        else
        {
              if(j==0)//通道1 温度
              {
                  if(tt==0x3fff)
                    Pt.RfData[addr-1][j].value=SENIOR_NULL;
                  else
                  {
                    Pt.RfData[addr-1][j].value=tt&0x1fff;//数值
                    if(tt&0x2000)
                    {
                      Pt.RfData[addr-1][j].value|=0x8000;
                    }
                  }
              }
              else//通道2 湿度
              {
                  if(hh==0x3ff)
                  {
                    Pt.RfData[addr-1][j].value=SENIOR_NULL;
                    Pt.RfChN[addr-1]=1;
                    continue;//如果通道2是NULL,说明是单路温度的
                  }
                  else
                  {
                    Pt.RfData[addr-1][j].value=hh;//数值
                  }
              }
        }

  
        #if ((RF_YQ_EN==1)&&(RF_YQ_SS_EN==0))
        if(Pt.RfData[addr-1][j].value==SENIOR_NULL)
        {
            StateC.Value[addr-1+j]=SENIOR_NULL;
        }
        else
        {
            StateC.Value[addr-1+j]=0x7fff&Pt.RfData[addr-1][j].value;
            
            if(Pt.RfData[addr-1][j].value&0x8000)
              StateC.FuhaoBit|=1<<(addr-1+j);
            else
              StateC.FuhaoBit&=~(1<<(addr-1+j));
        }
        #endif
  }
  
  
  if(TTflag==1)
  {
    Pt.RfChN[addr-1]|=0x80;//最高位是1，表示是2T的协议
  }
  
#else
  
  
  u8 j;
  u8 addr;
  u8 chn;
  
  //F0 (1)+ 地址(1)+字节数x(1)+目标SN号(10)+电量W(1)+通道数N(1)+通道数值(2*N)+CRC16(2)
  //指令标志, 传感器F0,或中继器F1-FF都可以接收
  if(buf[0]<0xf0)
    return;

  //接收数据完成，进行CRC校验
  //if(GetCrc16(buf,len-2)!=U8_TO_U16(buf[len-2],buf[len-1]))
  //  return;
  
  chn=buf[14];//通道数
  if(chn>2)//通道数不能大于2
    return;
  
  addr= buf[1];//地址
  #if RF_YQ_EN==1//单机仪器不能超过8，变送器系统可以超过
  if(!((addr>=1)&&(addr<=8)))
    return;
  #endif
  
  Pt.RfChN[addr-1]=chn;//该通道数
  
  for(j=0;j<chn;j++)//暂时最多2个通道的传感器
  {
        Pt.RfData[addr-1][j].value=U8_TO_U16(buf[15+j*2],buf[16+j*2]);//数值
      
        #if RF_YQ_EN==1
        if(Pt.RfData[addr-1][j].value==SENIOR_NULL)
        {
            StateC.Value[addr-1+j]=SENIOR_NULL;
        }
        else
        {
            StateC.Value[addr-1+j]=0x7fff&Pt.RfData[addr-1][j].value;
            
            if(Pt.RfData[addr-1][j].value&0x8000)
              StateC.FuhaoBit|=1<<(addr-1+j);
            else
              StateC.FuhaoBit&=~(1<<(addr-1+j));
        }
        #endif
  }
  
  if(chn==1)//通道2没数据
  {
     Pt.RfData[addr-1][1].value=SENIOR_NULL;//空的
  }
  
#endif

  
  #if RF_MULTI_EN==1
    Pt.RfTimeout[addr-1]=Pt.KpTout;//多机
  
  
    if(1==Flag.SeeComing)
    {
        ComSendH();
        U1SendBuf(buf,len);
        ComSendL();
    }
  
  
  
  #else
    Pt.RfTimeout[addr-1]=RF_TIMEOUT;//单机
  #endif
  
  WDT_CLR;
}

//初始 所有通道 NULL
void RfDataNULL(void)
{
  u8 j;
  for(j=0;j<RF_SEN_MAX;j++)
  {
    Pt.RfData[j][0].value=SENIOR_NULL;
    Pt.RfData[j][1].value=SENIOR_NULL;
  }
}

void RfTimeoutClr(void)
{
   u16 j;
   for(j=0;j<RF_SEN_MAX;j++)
   {
      Pt.RfTimeout[j]=0;
   }
}

//传感器超时，显示NULL
void RfTimeoutDeel(void)
{
      if(Pt.Xz>0)//设置频率时，不进入
        return;
  
      u8 j;
      u8 nn;//传感器数
      
      
            #if BAT_LCD_EN==1//电量采集
            if(Pt.Spt==9)
             {
                 VPP_CTL_ON;
                 ADC_REF_ON;
                 ADC_ON;
                 
                 //AD采样开始前，Asum和置0
                 for(u8 j=0;j<8;j++)
                   StateC.Asum[j]=0;
                 
                 Pt.AdcPt=0;
                 TB0_START;
             }
            else if(Pt.Spt==10)
            {
                LcdABat();
            }
            #endif
            
            
      
      if(++Pt.Spt>10)//10秒统计一次数量
      {
          Pt.Spt=0;
          
          nn=0;
          for(j=0;j<RF_SEN_MAX;j++)
          {
            WDT_CLR;
            #if RF_MULTI_MNJ==1
            Pt.RfTimeout[j]=RF_TIMEOUT;//永不超时     
            #endif
            if(Pt.RfTimeout[j]>=10)
            {
                if((Pt.RfTimeout[j]>=300)&&(Pt.RfTimeout[j]<310))//掉线提前5分钟，上电复位一次模块 
                {
                  RF_First();//zz
                }
                
                
                Pt.RfTimeout[j]=Pt.RfTimeout[j]-10;
              
                if(Pt.RfData[j][0].value==SENIOR_NULL)
                {
                  NOP;
                }
                else
                {
                  nn++;
                }
            }
            else
            {
                Pt.RfTimeout[j]=0;
                Pt.RfData[j][0].value=SENIOR_NULL;//空的
                Pt.RfData[j][1].value=SENIOR_NULL;//空的

            }

          }
          
          
          #if RF_MULTI_EN==1
          
            Lcd_H(StateB.Address);
            
            LcdB3dst(nn,0);//显示连接数
            BuToLcdRam(0,17);


            if(StateB.Address==1)//H1才显示时钟
            {
              LcdRtcTime();//时钟显示  zz
            }
            else
            {
              if(nn==0)
                Lcd_Xp(0,0,0);//时钟位置，清0
            }

            
          #endif
      }
      

      if(++Pt.RFpt>600)//全部掉线时，每10分钟复位一次
      {
          Pt.RFpt=0;
          
          if(nn==0)
          {
             RF_First();//zz
          }
      }

      

}


#if RF_MULTI_EN==1
//多机接收缓冲保存到EE, 放置突发断电或复位，丢失PC数据
//cc=1, buf to EE ,cc=2, EE to buf, cc=0,清空
void MultiBufEE(u8 cc)
{
  u16 j;
  u8 buf[7];
  
  for(j=0;j<RF_SEN_MAX;j++)
  {
        if(cc==0)
        {
            buf[0]=0;
            buf[1]=0;
            buf[2]=0;
            buf[3]=0;
            buf[4]=0;
            buf[5]=0;
            buf[6]=0;
            I2C_EE_BufferWrite(buf,RF_REAL_S_ADDR+j*7,7,0);
        }
        else if(cc==1)
        {
            buf[0]=Pt.Bat[j];
            buf[1]=0xff&(Pt.RfData[j][0].value>>8);
            buf[2]=0xff&(Pt.RfData[j][0].value);
            buf[3]=0xff&(Pt.RfData[j][1].value>>8);
            buf[4]=0xff&(Pt.RfData[j][1].value);
            buf[5]=0xff&(Pt.RfTimeout[j]>>8);
            buf[6]=0xff&(Pt.RfTimeout[j]);
           
            I2C_EE_BufferWrite(buf,RF_REAL_S_ADDR+j*7,7,0);
        }
        else
        {
            I2C_EE_BufferRead(buf,RF_REAL_S_ADDR+j*7,7,0);
            
            Pt.Bat[j]=buf[0];
            Pt.RfData[j][0].value=U8_TO_U16(buf[1],buf[2]);
            Pt.RfData[j][1].value=U8_TO_U16(buf[3],buf[4]);
            Pt.RfTimeout[j]=U8_TO_U16(buf[5],buf[6]);
        }
  }

}
#endif



//单仪器，接收缓冲 到 通道缓冲
void RfDataToChDeel(void)
{
   u8 j;
   Pt.SampPt++;
   if(Pt.SampPt>=RF_SAMP_TIME)
   {
       Pt.SampPt=0;
       Flag.RstFirstSample=1;//有数据
       
       for(j=0;j<CH_NUM;j++)
       {
           //通道1
           if(Pt.RfData[j][0].value==SENIOR_NULL)
           {
               StateC.Value[j]=SENIOR_NULL;
           }
           else
           {
               StateC.Value[j]=0x7fff&Pt.RfData[j][0].value;
               if(0x8000&Pt.RfData[j][0].value)
                 StateC.FuhaoBit|=1<<j;
               else
                 StateC.FuhaoBit&=~(1<<j);
           }

           //通道2 如果有数据的，则放到下个通道
           if(j+2<=CH_NUM)
           {
               if(Pt.RfData[j][1].value!=SENIOR_NULL)
               {
                   StateC.Value[j+1]=0x7fff&Pt.RfData[j][1].value;
                   if(0x8000&Pt.RfData[j][1].value)
                     StateC.FuhaoBit|=(1<<(j+1));
                   else
                     StateC.FuhaoBit&=~(1<<(j+1));
                   
                   j++;
               }
           }
       }
   }
}

#endif



//Rf UART  初始化
void RfU_Init(u32 Baudrate,u8 UART_CLK)
{
    #if RF_U1_EN==1
       U1Init(Baudrate,UART_CLK);
    #else
       U0Init(Baudrate,UART_CLK);
    #endif
}

#if ((RF_REC_EN==1)||(RF_KP_EN==1)||(RF_RP_EN==1)||(RF_TXRX_470M_EN==1))
//保存Rf频率
void SetRfFzToEE(void)
{
   u8 BufTmp[1];
   BufTmp[0]=Pt.Fz;
   I2C_EE_BufferWrite(BufTmp,RF_FZ_ADDR,1,0);//保存标志
}
//读取Rf频率
void GetRfFzFromEE(void)
{
    u8 BufTmp[1];
    I2C_EE_BufferRead(BufTmp,RF_FZ_ADDR,1,0);
    Pt.Fz=BufTmp[0];
}


void RfU_SendByte(u8 cc)
{
    #if RF_U1_EN==1
      U1SendByte(cc);//无线模块接 U1
    #else
      U0SendByte(cc);//无线模块接 U0
    #endif
}

void RfU_SendBuf(u8* BufIn,u16 Len)
{
  for(u16 i=0;i<Len;i++)
    RfU_SendByte(BufIn[i]);
}

void RfReset(void)
{
         //设置时，用9600
         #if RF_PP_115200_EN==1
            RfU_Init(9600,1);
         #endif
         
         RF_IN_SLP;//配置休眠模式下才可进行参数设置
         delay_ms(200);
         WDT_CLR;
         
         RfU_SendByte(0xFF);
         RfU_SendByte(0x56);
         RfU_SendByte(0xAE);
         RfU_SendByte(0x35);
         RfU_SendByte(0xA9);
         RfU_SendByte(0x55);
         RfU_SendByte(0x01);
         
         delay_ms(50);
         WDT_CLR;
         #if RF_PP_115200_EN==1
            RfU_Init(115200,1);
         #endif
            
         RF_IN_REC;
}

void RF_First(void)
{
   #if RF_U1_EN==1
   if(Pt.U1toPC==1)
     return;
   #endif
  
   VDC33_OFF;
   WDT_CLR;
   delay_ms(200);
   WDT_CLR;
   delay_ms(200);
   WDT_CLR;
   delay_ms(100);
   WDT_CLR;
   VDC33_ON;
   delay_ms(200);
   RfReset();
}

//设置频率, 共可设置30个频段  456-485
//以470为中心，奇数向 470-456， 偶数向471-485
//1.3...29  470.469...456  、  2.4...30  471...485 、 
void RfSetF(u8 cc)
{        
         u32 fz;
         u8 xx;
         
         if((cc%2)==0)//偶数
         {
            xx=cc/2;
            fz=470000+1000*xx;
         }
         else
         {
            xx=(cc-1)/2;
            fz=470000-1000*xx;
         }
         
         
         //设置时，用9600
         #if ((RF_PP_115200_EN==1)||(RF_KP_EN==1))
            RfU_Init(9600,1);
         #endif
         

         RF_IN_SLP;//配置休眠模式下才可进行参数设置
         delay_ms(200);
         WDT_CLR;
         delay_ms(200);
         WDT_CLR;
         delay_ms(200);
         WDT_CLR;
         
         //设置频率，并写入模块EEPROM
         RfU_SendByte(0xFF);
         RfU_SendByte(0x56);
         RfU_SendByte(0xAE);
         RfU_SendByte(0x35);
         RfU_SendByte(0xA9);
         RfU_SendByte(0x55);
         RfU_SendByte(0x8c);
         RfU_SendByte(0x00);
         RfU_SendByte(0x03);
         
         RfU_SendByte(0xff&(fz>>16));
         RfU_SendByte(0xff&(fz>>8));
         RfU_SendByte(0xff&fz);
         
         
         delay_ms(200);
         WDT_CLR;
         delay_ms(200);
         WDT_CLR;
         delay_ms(200);
         WDT_CLR;
         

         //设置包长 0x01-2  0x02-4  0x03-8  0x04-16  0x05-32
         RfU_SendByte(0xFF);
         RfU_SendByte(0x56);
         RfU_SendByte(0xAE);
         RfU_SendByte(0x35);
         RfU_SendByte(0xA9);
         RfU_SendByte(0x55);
         RfU_SendByte(0x8c);
         
         RfU_SendByte(0x0c);
         RfU_SendByte(0x01);
         
        #if RF_CC_EN==1
           RfU_SendByte(0x03);
        #else
           RfU_SendByte(0x05);       
        #endif
         
         delay_ms(200);
         WDT_CLR;
         delay_ms(200);
         WDT_CLR;
         delay_ms(200);
         WDT_CLR;
         
         
         //设置空中波特率、串口波特率、功率
         #if ((RF_PP_115200_EN==1)||(RF_KP_EN==1))
           RfU_SendByte(0xFF);
           RfU_SendByte(0x56);
           RfU_SendByte(0xAE);
           RfU_SendByte(0x35);
           RfU_SendByte(0xA9);
           RfU_SendByte(0x55);
           RfU_SendByte(0x8c);
           
           RfU_SendByte(0x03);
           RfU_SendByte(0x03);
           
           RfU_SendByte(0x04);//空中波特率100k
           RfU_SendByte(0x07);//功率最大
           RfU_SendByte(0x07);//串口115200
         
         
         #else
         
           //设置功率 0x04-10.9dbm  0x07-20dbm 
           RfU_SendByte(0xFF);
           RfU_SendByte(0x56);
           RfU_SendByte(0xAE);
           RfU_SendByte(0x35);
           RfU_SendByte(0xA9);
           RfU_SendByte(0x55);
           RfU_SendByte(0x8c);
           
           RfU_SendByte(0x03);
           RfU_SendByte(0x03);
           
           RfU_SendByte(0x01);//空中波特率10k
           RfU_SendByte(0x07);//功率最大
           RfU_SendByte(0x03);//串口9600
         #endif
         
         delay_ms(50);
         WDT_CLR;
         #if ((RF_PP_115200_EN==1))
            RfU_Init(115200,1);
         #endif
            
         RF_IN_REC;
            
            
        #if RF_KP_EN==1
        RfU_Init(9600,0);
        #endif
         
         
}

#endif



#if RF_RP_EN==1
//中继器接收处理
void Rf_Rec_Rp(u8 cc)
{
  u8 addr;
  u8 rp;
  
  #if RF_CC_EN==1
  
      if(Uart_0.RecLen!=8)
        return;
  
      if(!(((Uart_0.RxBuf[0]>=0xA0)&&(Uart_0.RxBuf[0]<0xAA))||((Uart_0.RxBuf[0]>=0xB0)&&(Uart_0.RxBuf[0]<0xBA))))
        return;
      
      addr=Uart_0.RxBuf[1];//地址
      if(addr==0)
        return;

      rp=Uart_0.RxBuf[0]&0x0f;
      
      
      //地址修改成中继器地址 Ax
      if((Uart_0.RxBuf[0]&0xf0)==0xA0)
        Uart_0.RxBuf[0]=0xA0|StateB.Address;
      else if((Uart_0.RxBuf[0]&0xf0)==0xB0)
        Uart_0.RxBuf[0]=0xB0|StateB.Address;
    
      //重新计算CRC
      Uart_0.RxBuf[7]=get_add(Uart_0.RxBuf,7);
      
      Uart_0.RecLen=8;//固定为8字节
  
  #else
      
      //FF版本-------------------
      unsigned short crc16;
      
      if(!((Uart_0.RxBuf[0]>=0xF0)&&(Uart_0.RxBuf[0]<0xFA)))
        return;
      
      addr=Uart_0.RxBuf[1];//地址
      if(addr==0)
        return;
      
      rp=Uart_0.RxBuf[0]&0x0f;

    
      
      //地址修改成中继器地址 Fx
      Uart_0.RxBuf[0]=0xf0|StateB.Address;
      
      //重新计算CRC
      crc16=GetCrc16(Uart_0.RxBuf,Uart_0.RecLen-2);
      Uart_0.RxBuf[Uart_0.RecLen-2]=0xff&(crc16>>8);
      Uart_0.RxBuf[Uart_0.RecLen-1]=0xff&(crc16);
  
  #endif
  
  
   Lcd_Xp(rp,addr,1);//显示收到的地址   
      
  
   //同一地址的数据，不管是A0还是Ax，在发送后10s内不能再次发送
   if(Pt.HasTimeout[addr-1]>RF_RP_TIME-10)//至少更新间隔10s以上
     return;
      
    RF_IN_REC;
    UART_U0_TXD_SET;
    
    
    //1.包长 32字节  发送时间 58ms
    //2.包长 16字节  发送时间 35ms
    //3.包长 8字节   发送时间 24ms
    //CC版本发送8字节，30ms,  FF版本发送32字节，62ms
    //要避免多台中继器同时发送数据，根据中继器地址错开时间，
    //P1延时1tt,P2延时2tt...
    u16 tt;
    
    #if RF_CC_EN==1
    
      #if RF_PP_115200_EN==1
          tt=5;
      #else
          tt=30;    
      #endif
    #else
        tt=62;
    #endif

    tt=tt*StateB.Address;
    WDT_CLR;
    DelayMs(tt);
    WDT_CLR;
    
    U0SendBuf(Uart_0.RxBuf,Uart_0.RecLen);
      
    Pt.HasTimeout[addr-1]=RF_RP_TIME;

}
//初始，数据空的
void Rf_NULL_Rp(void)
{
  u8 j;
  for(j=0;j<RF_RP_MAX;j++)
  {
    Pt.HasTimeout[j]=0;
  }
}

//定期扫描连接数
void Rf_N_Rp_deel(void)
{
  u8 j,nn;
  
  if(Pt.Xz>0)//设置频率时，不进入   
    return;
  
      #if BAT_LCD_EN==1//电量采集
      if(Pt.ScanPt==9)
       {
           VPP_CTL_ON;
           ADC_REF_ON;
           ADC_ON;
           
           //AD采样开始前，Asum和置0
           for(u8 j=0;j<8;j++)
             StateC.Asum[j]=0;
           
           Pt.AdcPt=0;
           TB0_START;
       }
      else if(Pt.ScanPt==10)
      {
          LcdABat();
      }
      #endif
  
      
  if(++Pt.ScanPt>10)//10s扫描一次
  {
      Pt.ScanPt=0;
      
      nn=0;
      for(j=0;j<RF_RP_MAX;j++)
      {
          WDT_CLR;
          if(Pt.HasTimeout[j]>10)
          {
            Pt.HasTimeout[j]=Pt.HasTimeout[j]-10;
            nn++;
          }
          else
          {
            Pt.HasTimeout[j]=0;
          }
      }
      
      Pt.LinkN=nn;//连接数
      
      if(Key.AddrPt==0)//不在设置地址状态才显示连接数
      {
          Lcd_P(StateB.Address);
          LcdB3dst(Pt.LinkN,0);//显示这个时间内连接到的传感器数
          
          if(Pt.LinkN==0)
          {
            Lcd_Xp(0,0,0);
          }
          
          BuToLcdRam(0,17);
      }
  }
}


#endif


#if ((RF_RP_EN==1)||(RF_MULTI_EN==1))
void LcdRpSt(void)
{
    delay_ms(500);
    WDT_CLR;
    #if RF_MULTI_EN==1
      Pt.Spt=9;
    #else
      Lcd_P(StateB.Address);
      LcdB3dst(Pt.LinkN,0);//显示这个时间内连接到的传感器数
      BuToLcdRam(0,17);
    #endif
}
#endif

#if RF_MULTI_MNJ==1

//模拟
void RfDataMN(void)
{
  u8 j;
  for(j=0;j<RF_SEN_MAX;j++)
  {
    
    Pt.RfChN[j]=2;//通道数
    Pt.RfData[j][0].value=(1+j)*10;
    Pt.RfData[j][1].value=(1+j)*10;
    Pt.RfTimeout[j]=RF_TIMEOUT;  
    
    Pt.Bat[j]=((1+j)*10)%100;//电量
  }
  Pt.Spt=9;
 
}
#endif


#if RF_MULTI_EN==1

//接收机中继H1-H9，打包发送数据包
void RecRpSend(void)
{
  u8 add;
  u16 nn=0;
  u16 j;
  
          
  //得连接数
  for(j=0;j<RF_SEN_MAX;j++)
  {
    if(Pt.RfTimeout[j]>0)
    {
       if(Pt.RfData[j][0].value!=SENIOR_NULL)
       {
          nn++;
       }
    }
  }
  
  if(nn==0)
    return;
  
  //Cn+ SN_CRC(2)+连接数x(1)+【地址(1)_电量(1)_温度(2)_湿度(2)】（6x）+ADD+ CC
  add=0;
  
  add+=U0SendByte(0xC0|StateB.Address);
  
  add+=U0SendByte(0xff&(Pt.SnCRC16>>8));
  add+=U0SendByte(0xff&Pt.SnCRC16);
  
  
  add+=U0SendByte(nn);//连接数
  
  for(j=0;j<RF_SEN_MAX;j++)
  {
    if(Pt.RfTimeout[j]>0)
    {
       if(Pt.RfData[j][0].value!=SENIOR_NULL)
       {

          if(0x80&Pt.RfChN[j])//判断是否是2T协议卡片
          {
            add+=U0SendByte((0x80|(j+1)));//连上的地址
          }
          else
          {
            add+=U0SendByte(j+1);//连上的地址
          }
          
          
          add+=U0SendByte(Pt.Bat[j]);//电量
          
          //CH1
          add+=U0SendByte(0xff&(Pt.RfData[j][0].value>>8));
          add+=U0SendByte(0xff&(Pt.RfData[j][0].value));
          
          //CH2
          add+=U0SendByte(0xff&(Pt.RfData[j][1].value>>8));
          add+=U0SendByte(0xff&(Pt.RfData[j][1].value));

       }
    }
  }
  
  U0SendByte(add);
  U0SendByte(0xCC);
  
}


//数据接收，把中继器数据接收到 接收机缓冲
//Cn+ SN_CRC(2)+连接数x(1)+【地址(1)_电量(1)_温度(2)_湿度(2)】（6x）+ADD+ CC
void RecRPData(u8* buf,u16 len)
{
  volatile u8 addr,rp,TTflag;
  u16 j,nn;
  
  nn=buf[3];//连接数
  
  if(nn==0)//连接数不能为0
    return;
  
  if(nn>RF_SEN_MAX)
    return;
  
  if(nn*6+6 !=len)//确保数据个数正确
    return;
  
  for(j=0;j<nn;j++)
  {
    WDT_CLR;
    
    addr=0x7f&buf[4+j*6];//地址
    if(addr>RF_SEN_MAX)
      return;
    
    TTflag=0;
    if(0x80&buf[4+j*6])
      TTflag=1;
    
    
    Pt.Bat[addr-1]=buf[5+j*6];//电量
    
    Pt.RfData[addr-1][0].value= U8_TO_U16(buf[6+j*6],buf[7+j*6]);//CH1
    Pt.RfData[addr-1][1].value= U8_TO_U16(buf[8+j*6],buf[9+j*6]);//CH2
    
    if(Pt.RfData[addr-1][1].value==SENIOR_NULL)
      Pt.RfChN[addr-1]=1;
    else
      Pt.RfChN[addr-1]=2;
    
    if(TTflag==1)
      Pt.RfChN[addr-1]|=0x80;
    
    
    Pt.RfTimeout[addr-1]=Pt.KpTout;//zz  接收机接收中继器的数据，超时时间
  }
  
   Lcd_Xp(0,0,0);//时钟位置，清0
  
   rp=buf[0]&0x0f;
   Lcd_Xp(rp,nn,1);//显示收到的连接数  
   
   
   Pt.Spt=9;//立马显示更新连接数
  
  
}


#endif

//co2数字 TTL 传感器, Z 02783 z 02486
#if SEN_UART_EN==1
u16 Get_SenTTL_Value(u8* buf,u16 len)
{
  u16 vv=0;

  #if CO2_GSS_TTL_EN==1
  u16 aa;
  aa=GetXpt(buf,0,len,'Z',1);//获取第一个Z的位置
  if(buf[aa]=='Z')
  {
    if(((buf[aa+6]-0x30)>=0)&&((buf[aa+6]-0x30)<=9))
    {
      vv=(buf[aa+2]-0x30)*10000+(buf[aa+3]-0x30)*1000+(buf[aa+4]-0x30)*100+(buf[aa+5]-0x30)*10+(buf[aa+6]-0x30);
      StateC.sen_Pt=0;// 有正常数据，清0，否则会溢出
      
      /*
      if(Flag.AdcMd==1)//调试时输出传感器信号
      {
         ComSendH();
         U1SendByte(0x0d);
         U1SendByte(0x0a);
         U1SendValue(vv);
         ComSendL();
      }*/
      
    }
  }
  #elif (JLY_MODEL==_1_HCH2O_TTL_0_373)
  if((buf[0]==0xff)&&(buf[1]==0x17)&&(buf[2]==0x04))
  {
      u8 j,add=0;
      for(j=0;j<(len-1);j++)
        add+=buf[j];
      add=~add;//取反
      
      if(add==buf[len-1])//校验和
      {
          vv=U8_TO_U16(buf[4],buf[5]);//单位是ppb
          float ft;
          ft=vv;
          ft=ft*0.001*0.746;//ppb to ppm,ppm to mg/m3
          ft=ft*100;//2位小数
          vv=(u16)ft;
          StateC.sen_Pt=0;// 有正常数据，清0，否则会溢出
      }
  }
  #endif
  
  return vv;
  
}

#endif



#if SEN_MODBUS_485_EN==1

//取流速
u16 GetLS(u8* buf)
{
        float ft;
        u16 vv;

        ft=getFt_from_ieee(buf);
        if(!((ft>=-1)&&(ft<=5)))
          ft=0;
        vv=(u16)((int)(ft*100)+100);//量程-1~5
        return vv;
}

//取水深
u16 GetSS(u8* buf)
{
        float ft;
        u16 vv;

        ft=getFt_from_ieee(buf);
        if(ft<0)
          ft=0;
        vv=(u16)(ft*100);
        return vv;
}
//从接收缓冲中取数据
void Get485VV(u8* buf,u16 len)
{
   //取数据
    #if JLY_MODEL==_2_LS_SS
  
        //流速在 3 4 5 6  IEEE浮点数格式  2位小数

        StateC.sen_vbuf[0]=GetLS(&Uart_1.RxBuf[27]);//流速  
        StateC.sen_vbuf[1]=GetSS(&Uart_1.RxBuf[3]);//水深
        StateC.sen_spt[0]=0;// 有正常数据，清0，否则会溢出
  
    #elif JLY_MODEL==_4_2LS_2SS
        
        float ft;
        
        if(Uart_1.RxBuf[0]==1)//地址1
        {
            
            StateC.sen_vbuf[0]=GetLS(&Uart_1.RxBuf[27]);//流速
            StateC.sen_vbuf[1]=GetSS(&Uart_1.RxBuf[3]);//水深
            
            StateC.sen_spt[0]=0;// 有正常数据，清0，否则会溢出
          
        }
        else if(Uart_1.RxBuf[0]==2)//地址2
        {
            
            StateC.sen_vbuf[2]=GetLS(&Uart_1.RxBuf[27]);//流速
            StateC.sen_vbuf[3]=GetSS(&Uart_1.RxBuf[3]);//水深
            
            StateC.sen_spt[1]=0;// 有正常数据，清0，否则会溢出
        }
        
      
    #endif
  
  
}
#endif



//露点计算,根据温度和湿度计算露点
float GetDewpoint(float T,float RH)
{
  float DP;
  DP=((17.27*T)/(237.7+T))+log(RH/100);
  DP= (237.7*DP)/(17.27-DP);
  return DP;
}


void DogReset(void)
{
  _DINT();
  while(1);//死循环，等待外部看门狗复位
  
  //WDTCTL=0;

}

#if ((SIM68_EN==1)&&(SIM68_SLP_EN==1))
void SIM68_to_sleep(void)
{
  
  if(1==StateC.SeeBDSing)
  {
     U1_TO_PC;
     ComSendH();
     U1SendString("BDS SLP\r\n");//休眠，电流将至320uA
     ComSendL();
     U1_TO_RF; 
  }
  
  Lcd_Bc(1);//进入休眠，第二行小数字，显示c
  StateC.GpsSlping=1;
  delay_ms(10);
  U1SendString("$PMTK161,0*28\r\n");//休眠，电流将至320uA

}
void SIM68_to_wake(void)
{
   U1SendString("BDS WAKE\r\n");//任意字符可唤醒
   Lcd_Bc(0);
   StateC.GpsSlping=0;
}
#endif




#if ((GPRS_TC_EN==1)||(BSQ_REC_AA_EN==1))

//上传用的 U口
u8 UxSendByte(u8 cc)
{
    #if WIFI_ENABLE==1
      U1SendByte(cc);// U1  WIFI
    #else
      U0SendByte(cc);// U0  GPRS
    #endif  
      
    return cc;

}


#if GPRS_LG31_3000_EN==1
u8 TCP_LG31_Send_Head(u16 mm)//共发送条数mm
{
        u8 add=0;
        
        u8 bb=17+2*CH_NUM;//每条字节数
        u16 j,ss;
        
        #if WIFI_ENABLE==0
        if(1==Flag.SeeComing)//zz
        {
            ComSendH();
            U1SendString("DT,");
            ComSendL();
        }
        #endif
        
        
        //头--------------------------------------------------------------------------
        add+=UxSendByte(0x31);
        
        //字节数-----------------------------------------------------------------------

        ss=mm*bb+3*CH_NUM+23;

        add+=UxSendByte(0xff&(ss>>8));//字节数H
        add+=UxSendByte(0xff&(ss));//字节数L
        
        //SN
        #if RF_YQ_SS_EN==1
          u8 sn[10];
          I2C_EE_BufferRead(sn,SERIAL_NO_ADDR,10,0);
          
          //主机SN前7位+卡片地址3位
          sn[7]=((Pt.GprsRePt+1)/100)%10+0x30;
          sn[8]=((Pt.GprsRePt+1)/10)%10+0x30;
          sn[9]=((Pt.GprsRePt+1)/1)%10+0x30;
          
          add+=U0SendBuf(sn,10);

        
        #else
          add+=i2c_ee_read_to_u0(SERIAL_NO_ADDR,10,0);
        #endif
        
        
        //定位标志
        #if LBS_LAC_EN==1//zz
          add+=UxSendByte(0x00);
        #elif ((GPS_MOUSE_EN==1)||(LBS_JWD_EN==1))
          add+=UxSendByte(0x01);
        #else
         add+=UxSendByte(0x00);
        #endif


        //固件版本
        add+=UxSendByte(C_VER);
        
        
        #if LG31_RECTIME_EN==1
        
            add+=UxSendByte((u8)(PcBsq.RecTime/60));//分钟,记录间隔
            
            #if GSP_ENABLE==1
            
                if(PcBsq.RecTime>60)
                {
                  add+=UxSendByte((u8)(GSP_BP_JIANGE/60));
                }
                else
                {
                  add+=UxSendByte(1);
                }
                
            #else
                
                add+=UxSendByte((u8)(PcBsq.RecTime/60));//分钟
                
            #endif
          
          
        #else
        
            //预留
            for(j=0;j<2;j++)
              add+=UxSendByte(0x00);
        
        #endif
            
            
        //预留
        for(j=0;j<4;j++)
          add+=UxSendByte(0x00);
        
        
            
        #if CMD_CTRL_EN==1
            if(Pt.wdkai==1)
            {
                add+=UxSendByte(0xa1);
            }
            else
            {
               add+=UxSendByte(0xa0);
            }
            
            if(Pt.sdkai==1)
            {
                add+=UxSendByte(0xb1);
            }
            else
            {
               add+=UxSendByte(0xb0);
            }
        
        #else
            
            //预留
            for(j=0;j<2;j++)
              add+=UxSendByte(0x00);
            
        #endif
            



        //通道数
        add+=UxSendByte(CH_NUM);
        
        //通道参数
        for(j=0;j<CH_NUM;j++)
        {
          add+=UxSendByte(*((char *)CH1_T_ADDR+j*ONE_CH_CONFIG_BYTES));
          add+=UxSendByte(*((char *)CH1_U_ADDR+j*ONE_CH_CONFIG_BYTES));
          add+=UxSendByte(*((char *)CH1_S_ADDR+j*ONE_CH_CONFIG_BYTES));
        }
        
        //数据条数
        add+=UxSendByte(0xff&(mm>>8));//字节数H
        add+=UxSendByte(0xff&(mm));//字节数L
  
        return add;
}
#endif


#if ZX_EN==1

void ZX_Rtc_Send(void)
{
  //AAE8B90F42  
  u8 buf[15];
  u8 i=0;
  
  buf[i++]=0x02;
  buf[i++]='A';
  buf[i++]='A';
  buf[i++]='E';
  buf[i++]='8';
  buf[i++]='B';
  buf[i++]='9';
  buf[i++]='0';
  buf[i++]='F';
  buf[i++]='4';
  buf[i++]='2';
  buf[i++]=0X03;
  
  U0SendBuf(buf,i);
}

//23超限,24实时,25历史指令，buf 为ee取的历史数据
//返回实际发送的指令
u8 ZX_Send(u8* buf,u8 cc)
{
        //RTC
        u16 j,k,vv=0,temp[2],humi[2],ZX_Pt;
        u8 vvfh=0,ct,ch,gg[2],alarm=0;
        u8 ZX_Buf[80];//2个终端不会超过
        u8 ZX_Asc[160];
        u8 cmd;
        u8 nn;
        u8 zxch,zxadr,zxkk;//层号，地址,空库
        u32 tt;
        StrcutRtc time_bcd;
        
        I2C_EE_BufferRead(&zxkk,GPRS_ZXKK_ADDR,1,0);//空库
        if(zxkk)zxkk=1;
        
        
        temp[0]=0;
        temp[1]=0;
        
        humi[0]=0;
        humi[1]=0;
        
        gg[0]=0;
        gg[1]=0;
        
        
        cmd=cc;
        
        //取时间
        
        if(cmd==0x24)
        {
          tt=ReadRtcD10();//取实时数据
        }
        else
        {
          tt=U8_TO_U32(buf[0],buf[1],buf[2],buf[3]);
        }
        
        SecondsToDate(tt,&time_bcd);
        RtcD10ToBcd(&time_bcd);
        
        //取温湿度数据，现只支持1，2通道
        for(j=0;j<CH_NUM;j++)
        {
          
             if(cmd==0x24)//实时数据
             {
                 vv=StateC.Value[j];
                 if(0x01&(StateC.FuhaoBit>>j))
                   vv|=0x8000;
             }
             else//23 和  25  超限数据或历史数据
             {
                 #if ((GPS_MOUSE_EN==1)||(LBS_LAC_EN==1)||(LBS_JWD_EN==1))
                    vv=U8_TO_U16(buf[13+2*j],buf[14+2*j]);
                 #else
                    vv=U8_TO_U16(buf[5+2*j],buf[6+2*j]);         
                 #endif
             }
             
             if(j%2==0)//每队温湿度gg重新开始zz
               gg[j/2]=0;
             
             if(vv==SENIOR_NULL)
             {
                gg[j/2]|=BIT4;//传感器异常   
                vvfh=0;
                vv=0;
             }
             else
             {
                 alarm=AlarmXSeek(vv,j,1);
                 if(alarm==1)//上限超标
                 {
                    if(j%2==0)
                    {
                        gg[j/2]|=BIT0;
                    }
                    else if(j%2==1)
                    {
                        gg[j/2]|=BIT2;
                    }
  
                 }
                 else if(alarm==2)//下限超标
                 {
                    if(j%2==0)
                    {
                        gg[j/2]|=BIT1;
                    }
                    else if(j%2==1)
                    {
                        gg[j/2]|=BIT3;
                    }
                 }
                 
               
                 vvfh=0;
                 if(vv&0x8000)
                 {
                    vvfh=1;
                    vv=vv&0x7fff;
                 }
             }
             
             if(j%2==0)
             {
                temp[j/2]=vv;
             }
             else if(j%2==1)//湿度
             {
                humi[j/2]=vv;
             }
             
             
             if(zxkk)
               gg[j/2]|=BIT5;
             
             
             if(j==3)
               gg[j/2]|=BIT6;
           
        }
        
        
        
        
        
        
        //判断该条历史数据是否超标
        if(cmd==0x25)
        {
           if((gg[0]&0x0f)||(gg[1]&0x0f))//温湿度有超限数据
           {
               if(Pt.UpALing<2)//0,1
               {
                  Pt.UpALing=1;
                  cmd=0x23;//需先上传超限数据
               }
               else if(Pt.UpALing==2)//超限数据已经发送完成，开始发送25指令
               {
                  NOP;
               }
               else if(Pt.UpALing>2)//异常数据，置回0
               {
                  Pt.UpALing=0;
               }
                       

           }
           else
           {
               Pt.UpALing=0;
           }
        }
        
        
        
        //编辑指令
        I2C_EE_BufferRead(&zxch,GPRS_ZXCH_ADDR,1,0);//层号
        I2C_EE_BufferRead(&zxadr,GPRS_ZXADR_ADDR,1,0);//地址
        
        
        ZX_Pt=0;
        if(cmd==0x23)//超限数据，判断该条历史数据是否超限，超限时发送超限数据23
        {
           nn=0;//超限点数
           if(gg[0]&0x0f)
             nn++;
           if(gg[1]&0x0f)
             nn++;
          
            ZX_Buf[ZX_Pt++]=cmd;
            ZX_Buf[ZX_Pt++]=nn;//终端数   最多2个温湿度
            
            for(k=0;k<2;k++)
            {
                if(gg[k]&0x0f)//该终端点超标
                {
                    ZX_Buf[ZX_Pt++]=zxch;//层号
                    ZX_Buf[ZX_Pt++]=zxadr+k;//地址
                    
                    //4字节数据
                    ZX_Buf[ZX_Pt++]=(u8)(D10_TO_BCD(humi[k]/10));
                    ch=(u8)(D10_TO_BCD(humi[k]%10));
                    ct=(u8)(D10_TO_BCD(temp[k]/100));
                    if(vvfh==1)
                      ct=ct|0x08;
                    ZX_Buf[ZX_Pt++]=(ch<<4)|ct;
                    ZX_Buf[ZX_Pt++]=(u8)(D10_TO_BCD(temp[k]%100));
                    ZX_Buf[ZX_Pt++]=gg[k];//上下限等标记
                    
        
                    ZX_Buf[ZX_Pt++]=time_bcd.Year;
                    ZX_Buf[ZX_Pt++]=time_bcd.Month;
                    ZX_Buf[ZX_Pt++]=time_bcd.Day;
                    ZX_Buf[ZX_Pt++]=time_bcd.Hour;
                    ZX_Buf[ZX_Pt++]=time_bcd.Minute;
                    ZX_Buf[ZX_Pt++]=time_bcd.Second;
                    
                    for(j=0;j<10;j++)
                    {
                      ZX_Buf[ZX_Pt++]=0x00;//经纬度
                    }
                    
                    ZX_Buf[ZX_Pt++]=GSP_BP_JIANGE/60;//超限间隔 分钟
                }
            }
            

            
            Pt.GprsRealN++;//每发送一条，+1
            
        }
        else//0x24,0x25  实时数据和历史数据上传
        {

            ZX_Buf[ZX_Pt++]=cmd;
            ZX_Buf[ZX_Pt++]=zxch;//层号
            
            ZX_Buf[ZX_Pt++]=time_bcd.Year;
            ZX_Buf[ZX_Pt++]=time_bcd.Month;
            ZX_Buf[ZX_Pt++]=time_bcd.Day;
            ZX_Buf[ZX_Pt++]=time_bcd.Hour;
            ZX_Buf[ZX_Pt++]=time_bcd.Minute;
            ZX_Buf[ZX_Pt++]=time_bcd.Second;
            
            for(j=0;j<10;j++)
            {
              ZX_Buf[ZX_Pt++]=0x00;//经纬度?
            }
            
            ZX_Buf[ZX_Pt++]=CH_NUM/2;//终端数
            
            
            for(k=0;k<CH_NUM/2;k++)
            {
                ZX_Buf[ZX_Pt++]=zxch;//层号
                ZX_Buf[ZX_Pt++]=zxadr+k;//地址
                
                //4字节数据
                ZX_Buf[ZX_Pt++]=(u8)(D10_TO_BCD(humi[k]/10));
                ch=(u8)(D10_TO_BCD(humi[k]%10));
                ct=(u8)(D10_TO_BCD(temp[k]/100));
                if(vvfh==1)
                  ct=ct|0x08;
                ZX_Buf[ZX_Pt++]=(ch<<4)|ct;
                ZX_Buf[ZX_Pt++]=(u8)(D10_TO_BCD(temp[k]%100));
                ZX_Buf[ZX_Pt++]=gg[k];//上下限等标记
            }
            

            Pt.GprsRealN++;//每发送一条，+1
            
        }
        
        
        I2C_EE_BufferRead(&ZX_Buf[ZX_Pt],GPRS_ZXQYH_ADDR,7,0);//企业号+库号
        ZX_Pt=ZX_Pt+7;
        
        hex_2_ascii(ZX_Buf,&ZX_Asc[1],ZX_Pt);//转ASCII
            
        u8 crcbuf[4];
        Get_u8buf_formU32(crcbuf,get_crc32(&ZX_Asc[1],ZX_Pt*2,0,0));
        hex_2_ascii(crcbuf,&ZX_Asc[ZX_Pt*2+1],4);//取CRC32校验，转ASCII
        
        ZX_Asc[0]=0x02;//头
        ZX_Asc[ZX_Pt*2+9]=0x03;//尾
        U0SendBuf(ZX_Asc,ZX_Pt*2+10);
        
        if(1==Flag.SeeComing)
        {
            ComSendH();
            U1SendBuf(ZX_Asc,ZX_Pt*2+10);
            U1SendByte(0X0D);U1SendByte(0X0A);
        }
        
        return cmd;
        
        
}





#endif





//buf一条记录: RTC(4)+BAT(1)+[GPS(8)]+2*CH_NUM
//从buf中取数据并且转换为GPRS协议发送到串口，返回校验码
//输出 out 1,表示遇到了开机关机标记而中途结束
u8 Buf_To_Gprs(u8* buf)
{
          u8 bbc=0;

#if GPRS_LG31_3000_EN==1//LUGE 协议，支持3000条补发
        
          #if GPRS_UP_REAL_EN==1

            
            bbc+=GprsUpSend(buf,Pt.UpCmd);//Pt.UpCmd= 0x24 时为实时数据
            
            
          #else
            bbc+=GprsUpSend(buf,0x00);
          #endif
          
#elif ZX_EN==1
          

          if(Pt.UpCmd==0x24)//实时数据上传只发送最新的实时数据，发送完成后，退出
          {
            
          }
          else
          {
            Pt.UpCmd=0x25;
          }
          
          Pt.UpCmd=ZX_Send(buf,Pt.UpCmd);
          

        
#else
        //顺丰GPRS协议-----------------------------------
        
        u16 vv,dd;
        
        //采集时间 RTC
        u32 tt;
        StrcutRtc time_bcd;
                    
        tt=U8_TO_U32(buf[0],buf[1],buf[2],buf[3]);
        SecondsToDate(tt,&time_bcd);
        RtcD10ToBcd(&time_bcd);
        
        
        Pt.OnOffBJ=0;//开关机标记判断
                    
        //判断是否是开关机标记
        Flag.TC_Tp=Is_WSD(&buf[4]);
                
        if(Pt.GprsRealN==0)//第一条，先发送包头
        {
           bbc^=SF_Send_Head(Flag.TC_Tp,Flag.XlhPt);//发送包头
        }
        
        if(Flag.TC_Tp==0x01)//该条是温湿度数据，总字节=34+5*CH_NUM
        {

               #if GPS_MOUSE_EN==1

                    bbc^=U0_SF_SendByte(0x10);//定位方式 GPS
                    
                    
                    u8 jdzs,wdzs;
                    u32 jdxs,wdxs;
                    
                    //经度
                    jdzs=buf[5];
                    jdxs=U8_TO_U32(0,buf[6],buf[7],buf[8]);
                    //纬度
                    wdzs=buf[9];
                    wdxs=U8_TO_U32(0,buf[10],buf[11],buf[12]);
                    
                    
                    //经纬标记，正负
                    u8 bj=0;
                    if(jdxs&0x800000)
                      bj|=0x10;
                    if(wdxs&0x800000)
                      bj|=0x01;

                    bbc^=U0_SF_SendByte(bj);
                    
                    u32 gps;
                    
                    //经度
                    gps=jdzs;
                    gps=gps*10000000;
                    gps=gps+jdxs*10;
                    
                    bbc^=U0_SF_SendByte(0xff&(gps>>24));
                    bbc^=U0_SF_SendByte(0xff&(gps>>16));
                    bbc^=U0_SF_SendByte(0xff&(gps>>8));
                    bbc^=U0_SF_SendByte(0xff&(gps>>0));
                    
                    //纬度
                    gps=wdzs;
                    gps=gps*10000000;
                    gps=gps+wdxs*10;

                    bbc^=U0_SF_SendByte(0xff&(gps>>24));
                    bbc^=U0_SF_SendByte(0xff&(gps>>16));
                    bbc^=U0_SF_SendByte(0xff&(gps>>8));
                    bbc^=U0_SF_SendByte(0xff&(gps>>0));
                    
                    
              #else
                    
                    bbc^=U0_SF_SendByte(0x00);//定位方式 无 
                    for(j=0;j<9;j++)
                      bbc^=U0_SF_SendByte(0x00); 
                    
              #endif
                    
                    
                    //基地台ID
                    for(j=0;j<11;j++)
                      bbc^=U0_SF_SendByte(0x00);
                    
                    //采集时间
                    bbc^=U0_SF_SendByte(0x20);
                    bbc^=U0_SF_SendByte(time_bcd.Year);
                    bbc^=U0_SF_SendByte(time_bcd.Month);
                    bbc^=U0_SF_SendByte(time_bcd.Day);
                    bbc^=U0_SF_SendByte(time_bcd.Hour);
                    bbc^=U0_SF_SendByte(time_bcd.Minute);
                    bbc^=U0_SF_SendByte(time_bcd.Second);
                    
                    bbc^=U0_SF_SendByte(buf[4]);//电量

                    for(j=0;j<4;j++)
                      bbc^=U0_SF_SendByte(0x00);//预留
                    
                    //扩展长度，通道数据字节数
                    bbc^=U0_SF_SendByte(5*CH_NUM);
                    
                    for(j=0;j<CH_NUM;j++)
                    {
                        bbc^=U0_SF_SendByte(*((char *)CH1_T_ADDR+j*ONE_CH_CONFIG_BYTES));//通道类型
                        bbc^=U0_SF_SendByte(0x03);//内容长度3字节
                        bbc^=U0_SF_SendByte(j+1);//通道号
                        
                        
                        //通道数值
                        #if (GPS_MOUSE_EN==1)
                        vv=U8_TO_U16(buf[13+2*j],buf[14+2*j]);
                        #else
                        vv=U8_TO_U16(buf[5+2*j],buf[6+2*j]);                        
                        #endif
                        
                        if(vv==SENIOR_NULL)
                        {
                            bbc^=U0_SF_SendByte(0xff&(vv>>8));
                            bbc^=U0_SF_SendByte(0xff&vv);
                        }
                        else
                        {
                            dd=0x7fff&vv;
                            dd=dd*10;//2位小数
                            if(vv&0x8000)
                              dd=dd+10000;
                            

                            bbc^=U0_SF_SendByte(0xff&(dd>>8));
                            bbc^=U0_SF_SendByte(0xff&dd);
                          
                        }
                       
                    }
                    
                    Pt.GprsRealN++;
        }
        
        //该包是开关机标记
        else 
        {
                if(Pt.GprsRealN==0)//开关机标记在第1条位置，才发送
                {
                        bbc^=U0_SF_SendByte(0x20);
                        bbc^=U0_SF_SendByte(time_bcd.Year);
                        bbc^=U0_SF_SendByte(time_bcd.Month);
                        bbc^=U0_SF_SendByte(time_bcd.Day);
                        bbc^=U0_SF_SendByte(time_bcd.Hour);
                        bbc^=U0_SF_SendByte(time_bcd.Minute);
                        bbc^=U0_SF_SendByte(time_bcd.Second);
                        
                        Pt.GprsRealN++;    
                }
                
                Pt.OnOffBJ=1;//如果温湿度数据遇到开关机标记，则中途结束

        }
#endif
                    
        return bbc;

}


//cc=1,GPRS上传，返回校验，在限定的最大条数中取多条温湿度或1条开关机标记，发送
//cc=2,打印，按照打印格式
//cc=3,PC下载数据,返回和校验
u8 BufTx(u8* buf,u8 cc)
{
    u8 bbc=0;
    
    WDT_CLR;
    
    if(cc==1)
    {
        #if ((GPRS_LG31_3000_EN==1)||(ZX_EN==1))
           bbc+=Buf_To_Gprs(buf);//buf转化为协议格式再发送
        #else
           bbc^=Buf_To_Gprs(buf);//buf转化为协议格式再发送
        #endif
    }
    else if(cc==2)
    {
        #if PRINT_NEW_EN==1
           Buf_To_Print(buf);
        #endif
    }
    else if(cc==3)
    {
        bbc+=Buf_To_PC(buf);
    }
    
    return bbc;
}


//返回校验，cc 1 GPRS上传  3 PC下载和校验
u8 GetJY(u8 bbc,u8 cc,u8 xor)
{
    if(cc==1)
    {
      #if GPRS_LG31_3000_EN==1
          bbc+=xor;
      #elif ZX_EN==1    
          bbc+=xor;//无用的，实际要用CRC32
      #else
          bbc^=xor;
      #endif
    }
    else if(cc==3)
    {
      bbc+=xor;
    }
    
    return bbc;
}


#if GPRS_MEMS_EN==1
//多片储存，从某个地址取1条记录数据
void EE_Read_One(u8* buf,u32 addr)
{
  u8 QuHao;
  u32 EE_32Pt;
  
  EE_32Pt=addr;
  if(EE_32Pt+ONE_SIZE<=StateC.E1_MaxMem)
  {
    QuHao=0;
  }
  else
  {
    QuHao=1+(EE_32Pt-StateC.E1_MaxMem)/StateC.E2_MaxMem;
    EE_32Pt=(EE_32Pt-StateC.E1_MaxMem)%StateC.E2_MaxMem;
  }
  
  I2C_EE_BufferRead(buf,EE_32Pt,ONE_SIZE,QuHao);
  
}
#endif


//取最新nn条中的前mm条
//cc=1,GPRS上传，按照顺丰协议格式，返回异或校验，在限定的最大条数中取多条温湿度或1条开关机标记，发送
//cc=2,打印，按照打印格式
//cc=3,PC下载数据,返回和校验
u8 Gprs_SF_Send_Data(u16 nn,u16 mm,u8 cc)
{
      u8 bbc;
      u8 buf[29];//每条记录格式：RTC(4)+BAT(1)+GPS(8)+2*CH_NUM
      u16 j;
      
      #if GPRS_MEMS_EN==1
      u32 EE_32Pt;
      #endif

      bbc=0;
      
      if(Pt.GprsThisRec16Num<PcBsq.RecCap)//记录未满
      {
            for(j=0;j<mm;j++)
            {
              
                   #if GPRS_MEMS_EN==1
                     EE_32Pt=((u32)Pt.GprsThisRecPt-nn+j)*ONE_SIZE;
                     EE_Read_One(buf,EE_32Pt);
                   #else
                     I2C_EE_BufferRead(buf,(Pt.GprsThisRecPt-nn+j)*ONE_SIZE,ONE_SIZE,0);
                   #endif

                   //发送过程中，如果遇到开关机标记，会提前结束, 只针对顺丰协议，LG31不会这样
                   bbc=GetJY(bbc,cc,BufTx(buf,cc));
                   
                   #if ((GPRS_LG31_3000_EN==0)&&(ZX_EN==0)&&(ON_OFF_BJ_EN==1))
                   if(Pt.OnOffBJ==1)
                     return bbc;
                   #endif

            }

      }
      else//记录已满
      {
            if(Pt.GprsThisRecPt==0)
            {
                for(j=0;j<mm;j++)
                {
                  
                   #if GPRS_MEMS_EN==1
                     EE_32Pt=((u32)Pt.GprsThisRec16Num-nn+j)*ONE_SIZE;
                     EE_Read_One(buf,EE_32Pt);
                   #else
                     I2C_EE_BufferRead(buf,(Pt.GprsThisRec16Num-nn+j)*ONE_SIZE,ONE_SIZE,0);
                   #endif

                   bbc=GetJY(bbc,cc,BufTx(buf,cc));
                   
                   #if ((GPRS_LG31_3000_EN==0)&&(ZX_EN==0)&&(ON_OFF_BJ_EN==1))
                   if(Pt.OnOffBJ==1)
                     return bbc;
                   #endif

                }
                  
            }
            else if(Pt.GprsThisRecPt>=nn)
            {
                for(j=0;j<mm;j++)
                {
                  
                   #if GPRS_MEMS_EN==1
                     EE_32Pt=((u32)Pt.GprsThisRecPt-nn+j)*ONE_SIZE;
                     EE_Read_One(buf,EE_32Pt);
                   #else
                  
                     I2C_EE_BufferRead(buf,(Pt.GprsThisRecPt-nn+j)*ONE_SIZE,ONE_SIZE,0);
                   #endif
                  
                   bbc=GetJY(bbc,cc,BufTx(buf,cc));
                   
                   #if ((GPRS_LG31_3000_EN==0)&&(ZX_EN==0)&&(ON_OFF_BJ_EN==1))
                   if(Pt.OnOffBJ==1)
                     return bbc;
                   #endif
                   
                }
            }
            else if(Pt.GprsThisRecPt<nn)
            {

                  u16 BeginPt,EndPt;
                  
                  BeginPt=Pt.GprsThisRec16Num+Pt.GprsThisRecPt-nn;
                  EndPt=Pt.GprsThisRec16Num-BeginPt;
                  
                  if(mm<=EndPt)
                  {
                      for(j=0;j<mm;j++)
                      {
                      
                         #if GPRS_MEMS_EN==1
                           EE_32Pt=((u32)BeginPt+j)*ONE_SIZE;
                           EE_Read_One(buf,EE_32Pt);
                         #else
                           
                           I2C_EE_BufferRead(buf,(BeginPt+j)*ONE_SIZE,ONE_SIZE,0);
                         
                         #endif
                        
                         bbc=GetJY(bbc,cc,BufTx(buf,cc));
                         
                         #if ((GPRS_LG31_3000_EN==0)&&(ZX_EN==0)&&(ON_OFF_BJ_EN==1))
                         if(Pt.OnOffBJ==1)
                           return bbc;
                         #endif

                      }
                  }
                  else
                  {
                      for(j=0;j<EndPt;j++)
                      {
                        
                           #if GPRS_MEMS_EN==1
                             EE_32Pt=((u32)BeginPt+j)*ONE_SIZE;
                             EE_Read_One(buf,EE_32Pt);
                           #else
                          
                             I2C_EE_BufferRead(buf,(BeginPt+j)*ONE_SIZE,ONE_SIZE,0);
                           #endif
                          
                           bbc=GetJY(bbc,cc,BufTx(buf,cc));
                           
                           #if ((GPRS_LG31_3000_EN==0)&&(ZX_EN==0)&&(ON_OFF_BJ_EN==1))
                           if(Pt.OnOffBJ==1)
                             return bbc;
                           #endif

                      }
                      
                      for(j=0;j<(mm-EndPt);j++)
                      {
                        
                           #if GPRS_MEMS_EN==1
                             EE_32Pt=((u32)0+j)*ONE_SIZE;
                             EE_Read_One(buf,EE_32Pt);
                           #else
                             I2C_EE_BufferRead(buf,((u16)0+j)*ONE_SIZE,ONE_SIZE,0);
                           #endif
                          
                           bbc=GetJY(bbc,cc,BufTx(buf,cc));
                           
                           #if ((GPRS_LG31_3000_EN==0)&&(ZX_EN==0)&&(ON_OFF_BJ_EN==1))
                           if(Pt.OnOffBJ==1)
                             return bbc;
                           #endif

                      }
                      
                  }

            }
      }
      
      
      return bbc;
}



u8 GprsDataHav(void)
{
  #if SMS_TCP_EN==1
  if((Pt.SmsPow)||(Pt.SmsAL))
    return 1;
  #endif

  
  #if RTC_UTC_EN==1
    #if GPRS_POW_EN==1
    if((Pt.GprsDueOut>0)||(Pt.GprsPowDueOut>0)||(Pt.UtcEn==1))//有GPRS定时数据发送、有上电断电触发数据发送
    #else
    if((Pt.GprsDueOut>0)||(Pt.UtcEn==1))
    #endif
  #else
    #if GPRS_POW_EN==1
    if((Pt.GprsDueOut>0)||(Pt.GprsPowDueOut>0))//有GPRS定时数据发送、有上电断电触发数据发送
    #else
      
      #if SMS_TCP_EN==1
        if(Pt.GprsDueOut>0)
      
      #else
        if(Pt.GprsDueOut>0)
      #endif  
        
    #endif
  #endif
    {
          //有数据上传，指示
          #if WIFI_ENABLE==0
            LED_ON;
            #if LCD_NO==20
              if(Pt.GprsDueOut>2)//有大于2条以上数据补传，则指示补传标志
              {
                  Lcd20Up(1);
              }
            #endif
          
          #endif
          
          #if GPRS_UP_TIME_EN==1
           if(Pt.Gprsing==0)//不是上传时间，不进入数据通讯
             return 0;
          #endif
          
          return 1;
    }
    
    #if WIFI_ENABLE==0
        LED_OFF;
        #if LCD_NO==20
        Lcd20Up(0);
        #endif
    #endif
    return 0;
}


//GPRS缓冲记录
void GprsDueOutFromEE(void)
{
   u8 buf[2];
   I2C_EE_BufferRead(buf,GPRS_DUEOUT_ADDR,2,0);
   Pt.GprsDueOut=U8_TO_U16(buf[1],buf[0]);
}
void GprsDueOutToEE(void)
{
  u8 buf[2];
  buf[0]=0xff&Pt.GprsDueOut;
  buf[1]=0xff&(Pt.GprsDueOut>>8);
  I2C_EE_BufferWrite(buf,GPRS_DUEOUT_ADDR,2,0);
}


void GprsSendOk(void)
{
  #if GPRS_TC_EN==1

    if(1==Flag.SeeComing)//zz
    {
          ComSendH();
          U1SendByte('S');
          U1SendValue(Pt.GprsThisDueOut);//实际发送条数
          U1SendByte('/');
          U1SendValue(Pt.GprsDueOut);//总条数
          U1SendByte(',');
          ComSendL();
    }
  #endif
    
  
  
  #if GPRS_POW_EN==1
  if(Pt.GprsPowDueOut>0)
  {
      Pt.GprsPowDueOut=0;
  }
  else
  {
      if(Pt.GprsDueOut>Pt.GprsThisDueOut)
        Pt.GprsDueOut=Pt.GprsDueOut-Pt.GprsThisDueOut;
      else
        Pt.GprsDueOut=0;
       GprsDueOutToEE();
  }

  #else
  
       #if RF_YQ_SS_EN==1
  
  
        if(1==Flag.SeeComing)//zz
        {
              ComSendH();
              U1SendByte('X');
              U1SendValue(Pt.GprsRePt+1);//实际发送条数
              U1SendByte(',');
              ComSendL();
        }
    
       if(++Pt.GprsRePt>=RF_SEN_MAX)//全部通道发送完，才确认进入下一轮
       {
            Pt.GprsRePt=0;
            
            if(Pt.GprsDueOut>Pt.GprsThisDueOut)
                Pt.GprsDueOut=Pt.GprsDueOut-Pt.GprsThisDueOut;
            else
                Pt.GprsDueOut=0;
            GprsDueOutToEE();
            
            
            Pt.GprsThisDueOut=0;
       }
       #else
         
            if(Pt.GprsDueOut>Pt.GprsThisDueOut)
                Pt.GprsDueOut=Pt.GprsDueOut-Pt.GprsThisDueOut;
            else
                Pt.GprsDueOut=0;
            GprsDueOutToEE();
         
       #endif

  
  #endif
  
            
  #if RF_YQ_SS_EN==0
  Pt.GprsThisDueOut=0;//zz
  #endif
  
  #if MG323_GPRS_EN==1//S1
  if(Pt.GprsSleep==0)//正常模式
  {
      if(Pt.GprsDueOut==0)//每次发送完后，重启一次，针对MG323
      {
        ErrorToRst();
      }
  }
  #endif
  
  
  
  #if WIFI_ENABLE==0
  if(Pt.GprsDueOut==0)
  {
        LED_OFF;
        #if LCD_NO==20
        Lcd20Up(0);
        #endif
  }
  
  Gsm.ReadCsqDog=1;
  
  U1SendStrPC("发送OK\r\n");
  #endif
}





//发送包体0x01数据
void Gprs_SF_Tramit_Data(void)
{           
      //当前储存状态
      Pt.GprsThisRec16Num=PcBsq.Rec16Num;
      Pt.GprsThisRecPt=PcBsq.RecPt;
                          
      //需发送的数据条数
      
      #if RF_YQ_SS_EN==1
      if(Pt.GprsRePt==0)//第1通道时，才能确定每轮发送条数
      #endif
      {
            Pt.GprsThisDueOut=Pt.GprsDueOut;
                    
            /*
            #if WIFI_ENABLE==0
            //进入透传状态后，第一次发送1条，其后每次最大发送条数=15
            if(Flag.TCing==1)
            {
               if(Pt.GprsThisDueOut>10)//第一包发送，LG服务器接收>1条数据时，时间判断为+-7D, 单条为判断+-1h
                 Pt.GprsThisDueOut=10;
            }
            else
            #endif
            */
              
            {
               if(Pt.GprsThisDueOut>TC_PER_NUM)
                  Pt.GprsThisDueOut=TC_PER_NUM;
            }
            
            

      }
      
      #if GPRS_UP_ONE_EN==1
        Pt.GprsThisDueOut=1;//zz
      #endif
      
      
      #if GPRS_UP_REAL_EN==1
        if(Pt.UpCmd==0x24)
        {
          Pt.GprsThisDueOut=1;//zz
        }
      #endif
      
      
      #if GPRS_LG31_3000_EN==1
      
            u8 bbc=0;
            
            Flag.TC_Type=0x00;//等该包数据发送完成后，才赋值
            Pt.GprsRealN=0;
            
            //LG31协议，每次发送条数和字节数在发送前就可以计算出来
            bbc=Gprs_SF_Send_Data(Pt.GprsDueOut,Pt.GprsThisDueOut,1);//发送包头和包体，返回的是和校验
            
            #if GPRS_UP_REAL_EN==1
              bbc+=UxSendByte(0x38);//数据尾
            #else
              bbc+=UxSendByte(0x32);//数据尾            
            #endif
              
            UxSendByte(bbc);//校验和
            
            
            #if GPRS_FFEEDD_EN==1
            UxSendByte(0xFF);
            UxSendByte(0xEE);
            UxSendByte(0xDD);
            #endif
            
            Pt.GprsThisDueOut=Pt.GprsRealN;//实际发送条数
            Flag.TC_Type=0x01;//等该包数据发送完成后，才赋值
      
      #elif ZX_EN==1
            
            Pt.GprsThisDueOut=1;//每次发送一条
            
            Flag.TC_Type=0x00;//等该包数据发送完成后，才赋值
            Pt.GprsRealN=0;
            
            
            Gprs_SF_Send_Data(Pt.GprsDueOut,Pt.GprsThisDueOut,1);//发送包头和包体，返回的是和校验

            
            Pt.GprsThisDueOut=Pt.GprsRealN;//实际发送条数
            Flag.TC_Type=0x01;//等该包数据发送完成后，才赋值
            
      
      #else
            u8 bbc=0;
            
            //顺丰协议，每次发送条数和字节数在发送前是不固定的，需要模拟发送一遍才能计算出的，因为需要转换7E，以及开关机标记
                            
            //发送Pt.GprsThisDueOut条数据
            
            Flag.TC_Type=0x00;//等该包数据发送完成后，才赋值
            Pt.GprsRealN=0;//遇到开关机标记会终止后面的数据，发送过程中自动计算实际发送条数
            
            bbc=Gprs_SF_Send_Data(Pt.GprsDueOut,Pt.GprsThisDueOut,1);//发送包头和包体，返回的异或校验
            U0_SF_SendByte(bbc);//异或校验码
            U0SendByte(0x7E);//包尾
            
            //发送完成之后，等待接收数据
            
            
            Pt.GprsThisDueOut=Pt.GprsRealN;//实际发送条数
            Flag.TC_Type=Flag.TC_Tp;//发送完成后才赋值，防止发送未完成时指令还进来
            
      #endif
      
}


#endif


void Wifi_NET_Reset(void)
{
     WDT_CLR;
      
     P4OUT|=BIT1;//复位Net模块
     delay_ms(400);
     P4OUT&=~BIT1;
     
     WDT_CLR;
}


#if WIFI_ENABLE==1


u8 *sServerCode="300.10";//平台如果接收正确，回复这个 Code:300.10

u8 WifiRcvDo(void)
{
       //300.10 回文  //300.10 A160829151556 Save Data SN:89898989
       if((Uart_1.RecLen>=6)&&(Uart_1.RecLen<100))
       {
         
           if(CompBuf(Uart_1.RxBuf,Uart_1.RecLen,sServerCode,6))
           {
                if(Flag.TC_Type==0x01)
                {
                    Flag.TC_Type=0x00;
                    
                    
                    //#if TCP_RTC_EN==1
                   // TcpRtcAuto(Uart_1.RxBuf,Uart_1.RecLen,0);//根据回文，自动对时
                    //#endif
                    
                    #if  ((TCP_RTC_EN==1)||(TCP_SET_EN==1))
                    ServerCmdSet(Uart_1.RxBuf);//ARTC正确返回A  ,BSET正确返回B
                    #endif
                    
                    
                    GprsSendOk();
                    
                    Pt.WifiPt=0;//收到数据，清标志
                    
                    Flag.TC_WaitPt=1;//准备下一条
    
                }
                

                return 1;
           }
                                      
       }
       
       return 0;
}

void WifiLinkDeel(void)
{
  //按键4，恢复出厂设置操作
  if(Pt.ReloadPt>0)
  {
    Pt.ReloadPt--;
    if(Pt.ReloadPt==0)
    {
       P4OUT&=~BIT2;//拉高
       
       WDT_CLR;
       delay_ms(100);
       WDT_CLR;
       

       if(Pt.Fg60FF==1)
       {
          StateA2.WorkState=WORK_STATE_STOP;
          POWER_CTL_ALL_OFF;
          LcdOFFX(OFF_BSQ_GPRS_HAND_STOP);//60FF
       }

    }
  }
  
  //WIFI 模块状态监测，如果连续40分钟，没有收到服务器回文，说明有异常情况，WIFI模块进行一次复位操作
  if(++Pt.WifiPt>((u16)60*40))
  {
      Pt.WifiPt=0;
    
      Wifi_NET_Reset();//复位
  }
  
  //发送间隔
  if(Flag.TC_WaitPt>0)
  {
     Flag.TC_WaitPt--;
  }
  
  
  //连接成功
  if(((NLINK_PIN&NLINK_BIT)==0)&&((NREADY_PIN&NREADY_BIT)==0))
  {
        LED_OFF;
        
        if((Flag.TC_WaitPt==0)&&GprsDataHav())//有数据要发送
        {
             WDT_CLR;
             
             Gprs_SF_Tramit_Data();//发送温湿度数据01
             
             Flag.TC_WaitPt=TC_WAIT_T;// 如果未收到回文，下次重发
        }
  }
  //WIFI 没连上
  else
  {
        LED_ON;
        
        Flag.TC_WaitPt=0;
  }
}

//WIFI RF  复位时保留缓冲
#if RF_YQ_EN==1
void Read_EE_LastOne_To_RfBuf(void)
{
    //不带定位 SIZE= 4+1+2*CH_NUM
    //温湿度  ：RTC(4)+BAT(1)+2*CH_NUM  
  
   
    if(PcBsq.Rec16Num>0)//必须是已经有数据记录过了
    {
        u8 j,buf[29];
        u16 vv,EEaddr;
      
        //最后一条数据的地址
        EEaddr=PcBsq.RecPt;
        
        if(EEaddr==0)//刚好记满时
          EEaddr=PcBsq.Rec16Num-1;
        else
          EEaddr=EEaddr-1;
        
        EEaddr=EEaddr*ONE_SIZE;
        
        I2C_EE_BufferRead(buf,EEaddr,ONE_SIZE,0);
        
        //取通道数值，赋值到RF buf
        for(j=0;j<CH_NUM;j++)
        {
            vv=U8_TO_U16(buf[5+2*j],buf[6+2*j]);
            
            //温度的卡片地址与通道号相同，湿度的卡片地址=温度
            if((*((char*)CH1_T_ADDR+j*ONE_CH_CONFIG_BYTES))==_T_T)//是温度，则判断为一个卡片
            {
               Pt.RfData[j][0].value=vv;
               Pt.RfData[j][1].value=SENIOR_NULL;
               
               Pt.RfTimeout[j]=RF_TIMEOUT;//FW,上电，卡片超时时间
            }
            else//湿度，重新赋值
            {  
               if(j>=1)
               {
                 Pt.RfData[j-1][1].value=vv;
               }
            }
        }
        
        Flag.RstFirstSample=0;
        Pt.SampPt=RF_SAMP_TIME-1;//立即转换到通道缓冲

    }
}
#endif





#endif

//TCP  回文 自动对时, RTC校时成功则返回1    A160829191056
//zx =1 为志翔                           AA20170628164520 \ AA20170713114006 
#if ((TCP_RTC_EN==1)||(ZX_EN==1))
u8 TcpRtcAuto(u8* buf,u16 len,u8 zx)
{
                     u8 ok=0;
                     u16 aa;
                     aa=GetXpt(buf,0,len,'A',1);//第1个A  
                     
                     if(aa<10)
                     {
                       if(zx==1)
                       {
                         aa=aa+3;
                       }
                     }
                     else
                     {
                       return 0;
                     }
                     
                     if((aa<10)&&(CK_Buf_Num(&buf[aa+1],12)))//全部是数字
                     {
                          StrcutRtc  Utc;
                          
                          
                          Utc.Year=(buf[aa+1]-0x30)*10+ (buf[aa+2]-0x30);
                          Utc.Month=(buf[aa+3]-0x30)*10+ (buf[aa+4]-0x30);
                          Utc.Day=(buf[aa+5]-0x30)*10+ (buf[aa+6]-0x30);
                          
                          Utc.Hour=(buf[aa+7]-0x30)*10+ (buf[aa+8]-0x30);
                          Utc.Minute=(buf[aa+9]-0x30)*10+ (buf[aa+10]-0x30);
                          Utc.Second=(buf[aa+11]-0x30)*10+ (buf[aa+12]-0x30);
                          
                          if(Rtc_Is_Right(&Utc))//时间格式正确
                          {
                            
                                Utc.SS=DateToSeconds(&Utc);
                                
                                //先读取设备RTC
                                Rtc.SS=ReadRtcD10();
                                
                                //比较，如果时钟 ，自动对时
                                if((Rtc.SS>Utc.SS+D_RTC_TIME)||(Rtc.SS<Utc.SS-D_RTC_TIME))
                                {
                                    SecondsToDate(Utc.SS,&Rtc);
                                              
                                    //设置时钟
                                    RtcD10ToBcd(&Rtc);//转成BCD
                                    RtcSetTime();
                                    RtcBcdToD10(&Rtc);
                                    
                                    ok=1;
      
                                }
                          }
                     }
                     
                     return ok;
}
#endif


#if ((TCP_RTC_EN==1)||(TCP_SET_EN==1))
//300.10.A160829191056
u8 ServerCmdSet(u8* buf)
{
                     u8 ok=0;
                     u8 PosS;
                     u16 aa;

                     PosS=GetPosS(buf,1,10,".1");
                     
                     
                     if(PosS<10)
                     {
                         if(buf[PosS+4]=='A')
                         {
    
                                     //aa=GetXpt(buf,0,len,'A',1);//第1个A 
                                     aa=PosS+4;

                                     if(CK_Buf_Num(&buf[aa+1],12))//全部是数字
                                     {
                                          StrcutRtc  Utc;
                                          
                                          Utc.Year=(buf[aa+1]-0x30)*10+ (buf[aa+2]-0x30);
                                          Utc.Month=(buf[aa+3]-0x30)*10+ (buf[aa+4]-0x30);
                                          Utc.Day=(buf[aa+5]-0x30)*10+ (buf[aa+6]-0x30);
                                          
                                          Utc.Hour=(buf[aa+7]-0x30)*10+ (buf[aa+8]-0x30);
                                          Utc.Minute=(buf[aa+9]-0x30)*10+ (buf[aa+10]-0x30);
                                          Utc.Second=(buf[aa+11]-0x30)*10+ (buf[aa+12]-0x30);
                                          
                                          if(Rtc_Is_Right(&Utc))//时间格式正确
                                          {
                                                Utc.SS=DateToSeconds(&Utc);
                                                
                                                //先读取设备RTC
                                                Rtc.SS=ReadRtcD10();
                                                
                                                //比较，如果时钟 ，自动对时
                                                if((Rtc.SS>Utc.SS+D_RTC_TIME)||(Rtc.SS<Utc.SS-D_RTC_TIME))
                                                {
                                                    SecondsToDate(Utc.SS,&Rtc);
                                                              
                                                    //设置时钟
                                                    RtcD10ToBcd(&Rtc);//转成BCD
                                                    RtcSetTime();
                                                    RtcBcdToD10(&Rtc);
                                                    
                                                    #if WIFI_ENABLE==0
                                                    U1SendStrPC("RTC ");//zz
                                                    #endif
                                                    
                      
                                                }
                                                
                                                ok='A';
                                                
                                          }
                                     }
                                     

                         }
                         
                         
                         #if TCP_SET_EN==1
                         else if(buf[PosS+4]=='B')//设置指令
                         {
                               u8 add=0;
                               u16 byte;
                               u8 j,tmp[10];
                           
                               byte=buf[PosS+5]+11;//字节数
                               
                               if(byte<100)
                               {
                               
                                   add=get_add(buf,byte-1);
                                   
                                   if((add==buf[byte-1])&&(buf[byte-2]=='C'))//校验和正确, 尾正确
                                   {
                                     
                                       I2C_EE_BufferRead(tmp,SERIAL_NO_ADDR,10,0);
                                       if(CheckBuf(tmp,&buf[PosS+6],10))//SN校验正确
                                       {
                                            if(buf[PosS+20]==0x01)//识别码，设置报警上下限报警开关
                                            {
                                         
                                                  if(buf[PosS+21]==CH_NUM)//通道数正确
                                                  {
                                                        for(j=0;j<CH_NUM;j++)
                                                        {
                                                            tmp[0]=buf[PosS+23+j*5];//下限低字节
                                                            tmp[1]=buf[PosS+22+j*5];//下限高字节
                                                            tmp[2]=buf[PosS+25+j*5];
                                                            tmp[3]=buf[PosS+24+j*5];
                                                            tmp[4]=buf[PosS+26+j*5];//开关
                                                          
                                                            alarm_buf_to_flash(tmp,j,1);
                                                            
                                                        }
                                                        
                                                        
                                                        ok='B';
                                                        
                                                        #if WIFI_ENABLE==0
                                                        U1SendStrPC(" SET_AL_OK ");
                                                        #endif
        
                                                        
                                                        
                                                        //设备回复
                                                        add=0;
                                                        add+=UxSendByte('B');//头
                                                        add+=UxSendByte(16);//字节数
                                                        
                                                        add+=i2c_ee_read_to_u0(SERIAL_NO_ADDR,10,0);
                                                        add+=UxSendByte(buf[PosS+16]);//指令序号
                                                        add+=UxSendByte(buf[PosS+17]);
                                                        add+=UxSendByte(buf[PosS+18]);
                                                        add+=UxSendByte(buf[PosS+19]);
                                                        add+=UxSendByte(0x01);//识别码
                                                        add+=UxSendByte(0x01);//成功标志
                                                        add+=UxSendByte('C');//尾
                                                        add+=UxSendByte(add);
                                                        
                                                    
                                                  }
                                            }
                                            
                                             else if(buf[PosS+20]==0x02)//识别码，设置域名和端口，设置成功后自动开启域名开关
                                             {
                                               
                                                       ok='B';
                                                       #if WIFI_ENABLE==0
                                                       U1SendStrPC(" SET_YM_OK ");
                                                       #endif
                                               
                                                       //设置域名
                                                       I2C_EE_BufferWrite(&buf[PosS+21],GPRS_DOMAIN_ADDR,30,0);
                                                         
                                                       //设置端口
                                                       tmp[0]=buf[PosS+52];//低字节
                                                       tmp[1]=buf[PosS+51];
                                                       
                                                       I2C_EE_BufferWrite(tmp,GPRS_PORT_ADDR,2,0);
                                                         
                                                       //域名开关，自动打开
                                                       tmp[0]=0x01;
                                                       I2C_EE_BufferWrite(tmp,GPRS_DOMAIN_EN_ADDR,1,0);
                                                 
                                                      
                                                      
                                                        //设备回复
                                                        add=0;
                                                        add+=UxSendByte('B');//头
                                                        add+=UxSendByte(16);//字节数
                                                        
                                                        add+=i2c_ee_read_to_u0(SERIAL_NO_ADDR,10,0);
                                                        add+=UxSendByte(buf[PosS+16]);//指令序号
                                                        add+=UxSendByte(buf[PosS+17]);
                                                        add+=UxSendByte(buf[PosS+18]);
                                                        add+=UxSendByte(buf[PosS+19]);
                                                        add+=UxSendByte(0x02);//识别码
                                                        add+=UxSendByte(0x01);//成功标志
                                                        add+=UxSendByte('C');//尾
                                                        add+=UxSendByte(add);
                                               
                                             }

                                       }
                                     
                                   }
                               
                               }
                           
                         }
                         
                         #endif
                       

                     }
                     
                     
                     return ok;
}
#endif




//开关门检测
#if ((DOOR1_BJ_EN==1)||(DOOR2_BJ_EN==1))
void DoorDeel(void)
{
    if(StateA2.WorkState==WORK_STATE_RECORDING)//开机时才工作
    {
        #if DOOR1_BJ_EN==1
      
      
          #if G_20_GZ_EN==1
          if((StateC.Value[6]!=SENIOR_NULL)&&(StateC.Value[6]>0))
          #else
          P5DIR&=~BIT0;
          if(P5IN&BIT0)//开着
          #endif
            
          {
             if(Pt.Door1Fg==0)//上一步是关闭状态
             {
                 //保存开门标记和时间
                 Rtc.SB=ReadRtcD10();
                 PCBSQ_RecOne((u8)DOOR1_OPEN);//记录一号门开门标记
                                
             }
            
             Pt.Door1Fg=1;
          }
          else//关着
          {
             if(Pt.Door1Fg==1)//上一步是开门状态
             {
                 //保存关门标记和时间
                 Rtc.SB=ReadRtcD10();
                 PCBSQ_RecOne((u8)DOOR1_CLOSE);
                 
             }
            
             Pt.Door1Fg=0;
          }
        #endif
          
          
          
        #if DOOR2_BJ_EN==1
          P5DIR&=~BIT1;
          if(P5IN&BIT1)//开着
          {
             if(Pt.Door2Fg==0)//上一步是关闭状态
             {
                 //保存开门标记和时间
                 Rtc.SB=ReadRtcD10();
                 PCBSQ_RecOne((u8)DOOR2_OPEN);//记录一号门开门标记
                                
             }
            
             Pt.Door2Fg=1;
          }
          else//关着
          {
             if(Pt.Door2Fg==1)//上一步是开门状态
             {
                 //保存关门标记和时间
                 Rtc.SB=ReadRtcD10();
                 PCBSQ_RecOne((u8)DOOR2_CLOSE);
                 
             }
            
             Pt.Door2Fg=0;
          }
        #endif
          
    }
}
          
#endif


#if ((GPRS_ENABLE==1)||(WIFI_ENABLE==1))
//字节数，包版本，包类型
u8 LG37_Head_Send(u16 x,u8 bVer,u8 bType)
{
        u8 add=0;
        
        RtcReadTime();//读当前RTC

        
        add=0;
        //头--------------------------------------------------------------------------
        add+=UxSendByte(0x37);
        
        //字节数-----------------------------------------------------------------------
        add+=UxSendByte(0xff&(x>>8));//字节数H
        add+=UxSendByte(0xff&(x));//字节数L
        
        //数据包版本-------------------------------------------------------------------
        add+=UxSendByte(bVer);
        
        //SN
        add+=i2c_ee_read_to_u0(SERIAL_NO_ADDR,10,0);
        
        //型号编码-----------------------------------------------------------------------
        add+=UxSendByte(0xff&(JLY_MODEL>>8));//字节数H
        add+=UxSendByte(0xff&(JLY_MODEL));//字节数L
        
        //固件版本--------------------------------------------------------------------------
        add+=UxSendByte(C_VER);
        
        //上传时间-----------------------------------------------------------------------
        add+=UxSendByte(Rtc.Year);
        add+=UxSendByte(Rtc.Month);
        add+=UxSendByte(Rtc.Day);
        add+=UxSendByte(Rtc.Hour);
        add+=UxSendByte(Rtc.Minute);
        add+=UxSendByte(Rtc.Second);
        RtcBcdToD10(&Rtc);
        
        
        //包序号----------------------------------------------------------------------
        add+=UxSendByte(0xff&(Flag.XlhPt>>8));//字节数H
        add+=UxSendByte(0xff&(Flag.XlhPt));//字节数L
        
        
        //包体类型
        add+=UxSendByte(bType);
        
        return add;
}
//设备回复服务器格式
void LG37_ReCmd(u8 bType)
{
        u16 x,c;
        u8 add;
        
        c=1;
        x=c+26;
        
        add=0;
        add+=LG37_Head_Send(x,0x02,bType);//数据包版本，包体类型
        
        //包体版本
        add+=UxSendByte(0x01);
        
        //包体长度
        add+=UxSendByte(0xff&(c>>8));//字节数H
        add+=UxSendByte(0xff&(c));//字节数L
        
        add+=UxSendByte(0x01);//接收结果
        
        
        //数据尾
        add+=UxSendByte(0x38);
        
        //校验和
        add+=UxSendByte(add);
        
}

#if SMS_TCP_EN==1
void TcpSmsSend(void)//TCP短信包协议
{
        u8 add,PhNN;
        u16 len;
        volatile u16 i,j,c,x;
        
        PhNN=GetPhoneNumFromEE();
        
        
        if(Pt.SmsPow)
          len=Pt.SmsPowLen;
        else
          len=Gsm.SmsUniLen;
        c=len+11*PhNN+53;//包体长度
        
        
        x=c+26;//总字节数
        
        add=0;
        
        add+=LG37_Head_Send(x,0x02,0x01);//数据包版本，包体类型
        
        
        //包体----------------------------------------------------------------------
        //包体版本
        add+=UxSendByte(0x02);//短信包体版本01时，返回包体长度为1个字节，包体版本02后，为2字节格式
        //包体长度
        add+=UxSendByte(0xff&(c>>8));//字节数H
        add+=UxSendByte(0xff&(c));//字节数L
        
        //ICCID
        for(j=0;j<20;j++)
          add+=UxSendByte(Pt.SIM_CCID[j]);
        
        //IMSI
        for(j=0;j<15;j++)
          add+=UxSendByte(Pt.SIM_IMSI[j]);
        
        //IMEI
        for(j=0;j<15;j++)
          add+=UxSendByte(Pt.G_IMEI[j]);
        
        //号码个数
        add+=UxSendByte(PhNN);
        
        //PhNN个号码
        for(j=0;j<PhNN;j++)
        {
           GetPhoneHaoFromEE(Gsm.SmsRxPhone,j);//取号码
           
           for(i=0;i<11;i++)
           {
             add+=UxSendByte(Gsm.SmsRxPhone[i]);
           }
        }
        
        
        //短信内容字节数
        add+=UxSendByte(0xff&(len>>8));//字节数H
        add+=UxSendByte(0xff&(len));//字节数L
 
        //短信内容
        for(j=0;j<len;j++)
        {
            if(Pt.SmsPow)
            {
              add+=UxSendByte(Pt.SmsPowUni[j]);
            }
            else
            {
              add+=UxSendByte(Gsm.SmsRecUni[j]);
            }
        }

        
        //数据尾
        add+=UxSendByte(0x38);
        
        //校验和
        add+=UxSendByte(add);
        
        
        
}
#endif
//cmd 0x24 为实时数据指令
u8 TCP_LG37_Send_Head(u16 mm,u8 cmd)//共发送条数mm
{
        u8 add=0;
        u16 c,x,j;
        
        #if WIFI_ENABLE==0
        if(1==Flag.SeeComing)//zz
        {
            ComSendH();
            if(cmd==0x24)
              U1SendString("RT,");
            else
              U1SendString("DT,");
            ComSendL();
        }
        #endif
        
        RtcReadTime();//读当前RTC
        
        c=mm*(17+2*CH_NUM)+3*CH_NUM+4;//包体长度
        x=c+3+23;//包长度
        
        
        add=0;
        
        add+=LG37_Head_Send(x,0x02,0x02);//包版本，包体类型
        
       
        //包体===========================
        //包体版本01
        add+=UxSendByte(0x01);
        
        //包体长度
        add+=UxSendByte(0xff&(c>>8));//字节数H
        add+=UxSendByte(0xff&(c));//字节数L
        
        //记录标志
        if(cmd==0x24)
          add+=UxSendByte(0x00);
        else
          add+=UxSendByte(0x01);
        

        //通道数
        add+=UxSendByte(CH_NUM);
        
        //通道参数
        for(j=0;j<CH_NUM;j++)
        {
          add+=UxSendByte(*((char *)CH1_T_ADDR+j*ONE_CH_CONFIG_BYTES));
          add+=UxSendByte(*((char *)CH1_U_ADDR+j*ONE_CH_CONFIG_BYTES));
          add+=UxSendByte(*((char *)CH1_S_ADDR+j*ONE_CH_CONFIG_BYTES));
        }
        
        //数据条数
        add+=UxSendByte(0xff&(mm>>8));//字节数H
        add+=UxSendByte(0xff&(mm));//字节数L
  
        return add;
}

//取实时数据
u8 TCP_LG_Send_Real(void)
{
        u8 add=0;
        u16 j,vv;
       
        RtcReadTime();//读当前RTC
       
        add+=UxSendByte(Rtc.Year);
        add+=UxSendByte(Rtc.Month);
        add+=UxSendByte(Rtc.Day);
        add+=UxSendByte(Rtc.Hour);
        add+=UxSendByte(Rtc.Minute);
        add+=UxSendByte(Rtc.Second);
        RtcBcdToD10(&Rtc);
        
        add+=UxSendByte(GetBatt());//电量

        if(HavePow())//有外电
        {
          add+=UxSendByte(0x01);
        }
        else
        {
          add+=UxSendByte(0x00);
        }
        
        #if ((GPS_MOUSE_EN==1)||(LBS_JWD_EN==1))
        add+=UxSendByte(0x01);
        
        
        
                          #if ((GPS_MOUSE_EN==1)&&(LBS_JWD_EN==1))// 带定位    
                              
                              if(StateC.GpsOutPt>0)
                              {
                                    add+=UxSendByte(StateC.LongiInt);
                                    add+=UxSendByte(0xff&(StateC.LongiDec>>16));
                                    add+=UxSendByte(0xff&(StateC.LongiDec>>8));
                                    add+=UxSendByte(StateC.LongiDec);
                                    
                                    add+=UxSendByte(StateC.LatiInt);
                                    add+=UxSendByte(0xff&(StateC.LatiDec>>16));
                                    add+=UxSendByte(0xff&(StateC.LatiDec>>8));
                                    add+=UxSendByte(0xff&(StateC.LatiDec));
                              }
                              else
                              {
                                    add+=UxSendByte(StateC.LBS_JdInt);
                                    add+=UxSendByte(0xff&(StateC.LBS_JdDec>>16));
                                    add+=UxSendByte(0xff&(StateC.LBS_JdDec>>8));
                                    add+=UxSendByte(StateC.LBS_JdDec);
                                    
                                    add+=UxSendByte(StateC.LBS_WdInt);
                                    add+=UxSendByte(0xff&(StateC.LBS_WdDec>>16));
                                    add+=UxSendByte(0xff&(StateC.LBS_WdDec>>8));
                                    add+=UxSendByte(0xff&(StateC.LBS_WdDec));
                              }
                              
                              
                              
                              
                          #elif ((GPS_MOUSE_EN==1)&&(LBS_JWD_EN==0))// 带定位
                             
                              add+=UxSendByte(StateC.LongiInt);
                              add+=UxSendByte(0xff&(StateC.LongiDec>>16));
                              add+=UxSendByte(0xff&(StateC.LongiDec>>8));
                              add+=UxSendByte(StateC.LongiDec);
                              
                              add+=UxSendByte(StateC.LatiInt);
                              add+=UxSendByte(0xff&(StateC.LatiDec>>16));
                              add+=UxSendByte(0xff&(StateC.LatiDec>>8));
                              add+=UxSendByte(0xff&(StateC.LatiDec));
                              

                          #elif ((GPS_MOUSE_EN==0)&&(LBS_JWD_EN==1))
                              
                              
                              add+=UxSendByte(StateC.LBS_JdInt);
                              add+=UxSendByte(0xff&(StateC.LBS_JdDec>>16));
                              add+=UxSendByte(0xff&(StateC.LBS_JdDec>>8));
                              add+=UxSendByte(StateC.LBS_JdDec);
                              
                              add+=UxSendByte(StateC.LBS_WdInt);
                              add+=UxSendByte(0xff&(StateC.LBS_WdDec>>16));
                              add+=UxSendByte(0xff&(StateC.LBS_WdDec>>8));
                              add+=UxSendByte(0xff&(StateC.LBS_WdDec));
      
                              
                                                      
                         #endif
        
        
        #else
          add+=UxSendByte(0x00);
          
          for(j=0;j<8;j++)
            add+=UxSendByte(0x00);
        
        #endif
          
        for(j=0;j<CH_NUM;j++)
        {
            vv=StateC.Value[j];
            if(0x01&(StateC.FuhaoBit>>j))//负数
            {
               vv=StateC.Value[j]|0x8000;
            }
                       
            add+=UxSendByte(0xff&(vv>>8));
            add+=UxSendByte(0xff&(vv));

        }
        
        
        return add;
          
        
       
}

//需把记录中的数据转成每条记录通讯格式：  时间RTC(6) 电池电量(1) 外部电源(1) 定位信息(9) n*通道数值(n*2)
u8 TCP_LG_Send_Data(u8* buf)
{
        u8 bbc=0;
        
        //RTC
        u16 j;
        u32 tt;
        StrcutRtc time_bcd;
                    
        tt=U8_TO_U32(buf[0],buf[1],buf[2],buf[3]);
        SecondsToDate(tt,&time_bcd);
        RtcD10ToBcd(&time_bcd);
        
        bbc+=UxSendByte(time_bcd.Year);
        bbc+=UxSendByte(time_bcd.Month);
        bbc+=UxSendByte(time_bcd.Day);
        bbc+=UxSendByte(time_bcd.Hour);
        bbc+=UxSendByte(time_bcd.Minute);
        bbc+=UxSendByte(time_bcd.Second);
        
        //开关机等特殊标记，发送数据时，后面全部是数据都是这个标记
        if((buf[4]==buf[5])&&(buf[4]>=0xF4)&&(buf[4]<=0xFE))//zz
        {
                  for(j=0;j<(11+2*CH_NUM);j++)
                    bbc+=UxSendByte(buf[4]);
        }
        else
        {
              bbc+=UxSendByte(0x7f&buf[4]);//电量
              
              if(0x80&buf[4])
                bbc+=UxSendByte(0x01);//有外部电源
              else
                bbc+=UxSendByte(0x00);//无外部电源
              
              
              #if ((GPS_MOUSE_EN==1)||(LBS_LAC_EN==1)||(LBS_JWD_EN==1))
              
                  #if GPRS_UP_REAL_EN==1
                  bbc+=UxSendByte(0x01);//定位标志
                  #endif
              
                  //经度,纬度等位置信息
                  bbc+=UxSendByte(buf[5]);
                  bbc+=UxSendByte(buf[6]);
                  bbc+=UxSendByte(buf[7]);
                  bbc+=UxSendByte(buf[8]);
                         
                  
                  bbc+=UxSendByte(buf[9]);
                  bbc+=UxSendByte(buf[10]);
                  bbc+=UxSendByte(buf[11]);
                  bbc+=UxSendByte(buf[12]);
                  
                  #if GPRS_UP_REAL_EN==0
                  bbc+=UxSendByte(0x00);//预留
                  #endif
          
                  
                  //通道数据
                  for(j=0;j<CH_NUM;j++)
                  {
                      bbc+=UxSendByte(buf[13+2*j]);
                      bbc+=UxSendByte(buf[14+2*j]);
                  }
                  
              #else
                  //预留
                  for(j=0;j<9;j++)
                    bbc+=UxSendByte(0x00);
                  
                  //通道数据
                  #if RF_YQ_SS_EN==1
                  
                    for(j=0;j<CH_NUM;j++)
                    {
                        bbc+=UxSendByte(0xff&(Pt.RfData[Pt.GprsRePt][0].value>>8));
                        bbc+=UxSendByte(0xff&(Pt.RfData[Pt.GprsRePt][0].value));
                    }   
                  
                  
                  #else
                  
                    for(j=0;j<CH_NUM;j++)
                    {
                        bbc+=UxSendByte(buf[5+2*j]);
                        bbc+=UxSendByte(buf[6+2*j]);
                    }      
                    
                  #endif
                  
                  
                  

              #endif
        }

        Pt.GprsRealN++;//每发送一条，+1
        
     
        #if WIFI_ENABLE==0
          if(1==Flag.SeeComing)//zz
          {
               u8 mm;
               ComSendH();
               mm=BCD_TO_D10(time_bcd.Hour);
               U1SendValue(mm/10);
               U1SendValue(mm%10);
               U1SendByte(':');
               mm=BCD_TO_D10(time_bcd.Minute);
               U1SendValue(mm/10);
               U1SendValue(mm%10);
               U1SendByte(',');
               ComSendL();
            
            
           }
           else
           {
             DelayMs(15);//zz
           }
        #endif  
          
        return bbc;
}

u8 GprsUpSend(u8* buf,u8 cmd)
{

        u8 bbc=0;
        

        
        #if GPRS_UP_REAL_EN==1
        
                if(Pt.GprsRealN==0)//第一条，先发送包头
                {
                    bbc+=TCP_LG37_Send_Head(Pt.GprsThisDueOut,cmd);
                }
                
                if(cmd==0x24)
                    bbc+=TCP_LG_Send_Real();
                else
                    bbc+=TCP_LG_Send_Data(buf);

        
       #else
        
          
          if(Pt.GprsRealN==0)//第一条，先发送包头
          {
              bbc+=TCP_LG31_Send_Head(Pt.GprsThisDueOut);          
          }
          
          bbc+=TCP_LG_Send_Data(buf);
        
       #endif
  
        return bbc;
  
  
}

#endif


#if PRINT_52_42_EN==1

//保存 BCSS  BCAL  
void SaveBcToEE(void)
{
   u8 BufTmp[4];
   
   BufTmp[0]=0xff&(Pt.bcSS>>24);
   BufTmp[1]=0xff&(Pt.bcSS>>16);
   BufTmp[2]=0xff&(Pt.bcSS>>8);
   BufTmp[3]=0xff&Pt.bcSS;
   I2C_EE_BufferWrite(BufTmp,BC_SS_ADDR,4,0);//保存标志
   
   BufTmp[0]=Pt.bcAL;
   I2C_EE_BufferWrite(BufTmp,BC_AL_ADDR,1,0);//保存标志
}
//读取 BCSS  BCAL
void GetBcFromEE(void)
{
    u8 BufTmp[4];
    
    I2C_EE_BufferRead(BufTmp,BC_SS_ADDR,4,0);
    Pt.bcSS=U8_TO_U32(BufTmp[0],BufTmp[1],BufTmp[2],BufTmp[3]);
    
    I2C_EE_BufferRead(BufTmp,BC_AL_ADDR,1,0);
    Pt.bcAL=BufTmp[0];
}

#endif


#if JD_LED_EN==1
void JDledDeel(void)
{  
  u8 xx;
  
  if(StateA2.WorkState==WORK_STATE_RECORDING)
  {
        if(Flag.RstFirstSample==1)
        {
          xx=GetBatt();
          if(xx<=20)
          {
              LD_GRN_OFF;
              
              LD_RED_ON;
              delay_us(200);
              LD_RED_OFF;
          }
          else
          {
              LD_GRN_ON;
              delay_us(200);
              LD_GRN_OFF;
              
              LD_RED_OFF;
          }
        }
  }
}
#endif


//-------------------------------------------------------------------------------


